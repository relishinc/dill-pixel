{"version":3,"file":"dill-pixel-plugin-arcade-physics.mjs","sources":["../node_modules/arcade-physics/lib/math/const.js","../node_modules/arcade-physics/lib/math/DegToRad.js","../node_modules/arcade-physics/lib/math/distance/DistanceBetween.js","../node_modules/arcade-physics/lib/math/distance/DistanceSquared.js","../node_modules/arcade-physics/lib/physics/arcade/const.js","../node_modules/arcade-physics/lib/physics/arcade/events/index.js","../node_modules/arcade-physics/lib/geom/rectangle/Contains.js","../node_modules/arcade-physics/lib/geom/rectangle/Perimeter.js","../node_modules/arcade-physics/lib/utils/Class.js","../node_modules/arcade-physics/lib/geom/const.js","../node_modules/arcade-physics/lib/geom/point/Point.js","../node_modules/arcade-physics/lib/geom/rectangle/GetPoint.js","../node_modules/arcade-physics/lib/geom/rectangle/GetPoints.js","../node_modules/arcade-physics/lib/geom/line/GetPoint.js","../node_modules/arcade-physics/lib/geom/line/Length.js","../node_modules/arcade-physics/lib/geom/line/GetPoints.js","../node_modules/arcade-physics/lib/geom/line/Random.js","../node_modules/arcade-physics/lib/math/fuzzy/Equal.js","../node_modules/arcade-physics/lib/math/Vector2.js","../node_modules/arcade-physics/lib/geom/line/Line.js","../node_modules/arcade-physics/lib/geom/rectangle/Random.js","../node_modules/arcade-physics/lib/geom/rectangle/Rectangle.js","../node_modules/arcade-physics/lib/physics/arcade/Body.js","../node_modules/arcade-physics/lib/geom/circle/Contains.js","../node_modules/arcade-physics/lib/physics/arcade/StaticBody.js","../node_modules/arcade-physics/lib/physics/arcade/Factory.js","../node_modules/arcade-physics/lib/physics/arcade/components/OverlapRect.js","../node_modules/arcade-physics/lib/geom/circle/CircumferencePoint.js","../node_modules/arcade-physics/lib/math/Clamp.js","../node_modules/arcade-physics/lib/math/FromPercent.js","../node_modules/arcade-physics/lib/geom/circle/GetPoint.js","../node_modules/arcade-physics/lib/geom/circle/Circumference.js","../node_modules/arcade-physics/lib/geom/circle/GetPoints.js","../node_modules/arcade-physics/lib/geom/circle/Random.js","../node_modules/arcade-physics/lib/geom/circle/Circle.js","../node_modules/arcade-physics/lib/geom/intersects/CircleToCircle.js","../node_modules/arcade-physics/lib/geom/intersects/CircleToRectangle.js","../node_modules/arcade-physics/lib/physics/arcade/components/OverlapCirc.js","../node_modules/arcade-physics/lib/math/angle/BetweenPoints.js","../node_modules/arcade-physics/node_modules/eventemitter3/index.js","../node_modules/arcade-physics/lib/math/fuzzy/GreaterThan.js","../node_modules/arcade-physics/lib/math/fuzzy/LessThan.js","../node_modules/arcade-physics/lib/physics/arcade/GetOverlapX.js","../node_modules/arcade-physics/lib/physics/arcade/GetOverlapY.js","../node_modules/arcade-physics/lib/utils/object/GetValue.js","../node_modules/rbush/rbush.min.js","../node_modules/arcade-physics/lib/structs/RTree.js","../node_modules/arcade-physics/lib/physics/arcade/ProcessX.js","../node_modules/arcade-physics/lib/physics/arcade/SeparateX.js","../node_modules/arcade-physics/lib/physics/arcade/ProcessY.js","../node_modules/arcade-physics/lib/physics/arcade/SeparateY.js","../node_modules/arcade-physics/lib/math/Wrap.js","../node_modules/arcade-physics/lib/physics/arcade/Collider.js","../node_modules/arcade-physics/lib/structs/events.js","../node_modules/arcade-physics/lib/structs/ProcessQueue.js","../node_modules/arcade-physics/lib/physics/arcade/World.js","../node_modules/arcade-physics/lib/physics/arcade/ArcadePhysics.js","../src/ArcadePhysicsPlugin.ts","../src/mixins.ts","../src/Body.ts","../src/Entity.ts","../node_modules/arcade-physics/lib/index.js"],"sourcesContent":["\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Math const */\nvar MATH_CONST;\n(function (MATH_CONST) {\n    /** The value of PI * 2 */\n    MATH_CONST[MATH_CONST[\"PI2\"] = Math.PI * 2] = \"PI2\";\n    /** The value of PI * 0.5 */\n    MATH_CONST[MATH_CONST[\"TAU\"] = Math.PI * 0.5] = \"TAU\";\n    /** An epsilon value (1.0e-6) */\n    MATH_CONST[MATH_CONST[\"EPSILON\"] = 0.000001] = \"EPSILON\";\n    /** For converting degrees to radians (PI / 180) */\n    MATH_CONST[MATH_CONST[\"DEG_TO_RAD\"] = Math.PI / 180] = \"DEG_TO_RAD\";\n    /** For converting radians to degrees (180 / PI) */\n    MATH_CONST[MATH_CONST[\"RAD_TO_DEG\"] = 180 / Math.PI] = \"RAD_TO_DEG\";\n    /**\n     * An instance of the Random Number Generator.\n     * This is not set until the Game boots.\n     */\n    // RND = null,\n    /**\n     * The minimum safe integer this browser supports.\n     * We use a const for backward compatibility with Internet Explorer.\n     */\n    MATH_CONST[MATH_CONST[\"MIN_SAFE_INTEGER\"] = Number.MIN_SAFE_INTEGER || -9007199254740991] = \"MIN_SAFE_INTEGER\";\n    /**\n     * The maximum safe integer this browser supports.\n     * We use a const for backward compatibility with Internet Explorer.\n     */\n    MATH_CONST[MATH_CONST[\"MAX_SAFE_INTEGER\"] = Number.MAX_SAFE_INTEGER || 9007199254740991] = \"MAX_SAFE_INTEGER\";\n})(MATH_CONST || (MATH_CONST = {}));\nexports.default = MATH_CONST;\n//# sourceMappingURL=const.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst const_1 = __importDefault(require(\"./const\"));\n/**\n * Convert the given angle from degrees, to the equivalent angle in radians.\n *\n * @function Phaser.Math.DegToRad\n * @since 3.0.0\n *\n * @param {number} degrees - The angle (in degrees) to convert to radians.\n *\n * @return {number} The given angle converted to radians.\n */\nconst DegToRad = degrees => {\n    return degrees * const_1.default.DEG_TO_RAD;\n};\nexports.default = DegToRad;\n//# sourceMappingURL=DegToRad.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculate the distance between two sets of coordinates (points).\n *\n * @function Phaser.Math.Distance.Between\n * @since 3.0.0\n *\n * @param {number} x1 - The x coordinate of the first point.\n * @param {number} y1 - The y coordinate of the first point.\n * @param {number} x2 - The x coordinate of the second point.\n * @param {number} y2 - The y coordinate of the second point.\n *\n * @return {number} The distance between each point.\n */\nconst DistanceBetween = (x1, y1, x2, y2) => {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return Math.sqrt(dx * dx + dy * dy);\n};\nexports.default = DistanceBetween;\n//# sourceMappingURL=DistanceBetween.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculate the distance between two sets of coordinates (points), squared.\n *\n * @function Phaser.Math.Distance.Squared\n * @since 3.0.0\n *\n * @param {number} x1 - The x coordinate of the first point.\n * @param {number} y1 - The y coordinate of the first point.\n * @param {number} x2 - The x coordinate of the second point.\n * @param {number} y2 - The y coordinate of the second point.\n *\n * @return {number} The distance between each point, squared.\n */\nconst DistanceSquared = (x1, y1, x2, y2) => {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return dx * dx + dy * dy;\n};\nexports.default = DistanceSquared;\n//# sourceMappingURL=DistanceSquared.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FACING = exports.PHYSICS_TYPE = void 0;\n/** Physics Types */\nvar PHYSICS_TYPE;\n(function (PHYSICS_TYPE) {\n    /** Dynamic Body. */\n    PHYSICS_TYPE[PHYSICS_TYPE[\"DYNAMIC_BODY\"] = 0] = \"DYNAMIC_BODY\";\n    /** Static Body. */\n    PHYSICS_TYPE[PHYSICS_TYPE[\"STATIC_BODY\"] = 1] = \"STATIC_BODY\";\n    /** Arcade Physics Group containing Dynamic Bodies. */\n    PHYSICS_TYPE[PHYSICS_TYPE[\"GROUP\"] = 2] = \"GROUP\";\n    /** A Tilemap Layer. */\n    PHYSICS_TYPE[PHYSICS_TYPE[\"TILEMAPLAYER\"] = 3] = \"TILEMAPLAYER\";\n})(PHYSICS_TYPE = exports.PHYSICS_TYPE || (exports.PHYSICS_TYPE = {}));\n/** Facing direction. */\nvar FACING;\n(function (FACING) {\n    /** Facing no direction (initial value). */\n    FACING[FACING[\"FACING_NONE\"] = 10] = \"FACING_NONE\";\n    /** Facing up. */\n    FACING[FACING[\"FACING_UP\"] = 11] = \"FACING_UP\";\n    /** Facing down. */\n    FACING[FACING[\"FACING_DOWN\"] = 12] = \"FACING_DOWN\";\n    /** Facing left. */\n    FACING[FACING[\"FACING_LEFT\"] = 13] = \"FACING_LEFT\";\n    /** Facing right. */\n    FACING[FACING[\"FACING_RIGHT\"] = 14] = \"FACING_RIGHT\";\n})(FACING = exports.FACING || (exports.FACING = {}));\nexports.default = {\n    PHYSICS_TYPE,\n    FACING\n};\n//# sourceMappingURL=const.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    /**\n     * The Arcade Physics World Collide Event.\n     *\n     * This event is dispatched by an Arcade Physics World instance if two bodies collide _and_ at least\n     * one of them has their [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.\n     *\n     * It provides an alternative means to handling collide events rather than using the callback approach.\n     *\n     * Listen to it from a Scene using: `this.physics.world.on('collide', listener)`.\n     *\n     * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject1 - The first Game Object involved in the collision. This is the parent of `body1`.\n     * @param {Phaser.GameObjects.GameObject} gameObject2 - The second Game Object involved in the collision. This is the parent of `body2`.\n     * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body1 - The first Physics Body involved in the collision.\n     * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body2 - The second Physics Body involved in the collision.\n     */\n    COLLIDE: 'collide',\n    /**\n     * The Arcade Physics World Overlap Event.\n     *\n     * This event is dispatched by an Arcade Physics World instance if two bodies overlap _and_ at least\n     * one of them has their [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.\n     *\n     * It provides an alternative means to handling overlap events rather than using the callback approach.\n     *\n     * Listen to it from a Scene using: `this.physics.world.on('overlap', listener)`.\n     *\n     * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.\n     *\n     * @event Phaser.Physics.Arcade.Events#OVERLAP\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject1 - The first Game Object involved in the overlap. This is the parent of `body1`.\n     * @param {Phaser.GameObjects.GameObject} gameObject2 - The second Game Object involved in the overlap. This is the parent of `body2`.\n     * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body1 - The first Physics Body involved in the overlap.\n     * @param {Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody} body2 - The second Physics Body involved in the overlap.\n     */\n    OVERLAP: 'overlap',\n    /**\n     * The Arcade Physics World Pause Event.\n     *\n     * This event is dispatched by an Arcade Physics World instance when it is paused.\n     *\n     * Listen to it from a Scene using: `this.physics.world.on('pause', listener)`.\n     *\n     * @event Phaser.Physics.Arcade.Events#PAUSE\n     * @since 3.0.0\n     */\n    PAUSE: 'pause',\n    /**\n     * The Arcade Physics World Resume Event.\n     *\n     * This event is dispatched by an Arcade Physics World instance when it resumes from a paused state.\n     *\n     * Listen to it from a Scene using: `this.physics.world.on('resume', listener)`.\n     *\n     * @event Phaser.Physics.Arcade.Events#RESUME\n     * @since 3.0.0\n     */\n    RESUME: 'resume',\n    /**\n     * The Arcade Physics Tile Collide Event.\n     *\n     * This event is dispatched by an Arcade Physics World instance if a body collides with a Tile _and_\n     * has its [onCollide]{@link Phaser.Physics.Arcade.Body#onCollide} property set to `true`.\n     *\n     * It provides an alternative means to handling collide events rather than using the callback approach.\n     *\n     * Listen to it from a Scene using: `this.physics.world.on('tilecollide', listener)`.\n     *\n     * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.\n     *\n     * @event Phaser.Physics.Arcade.Events#TILE_COLLIDE\n     * @since 3.16.1\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object involved in the collision. This is the parent of `body`.\n     * @param {Phaser.Tilemaps.Tile} tile - The tile the body collided with.\n     * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body of the Game Object involved in the collision.\n     */\n    TILE_COLLIDE: 'tilecollide',\n    /**\n     * The Arcade Physics Tile Overlap Event.\n     *\n     * This event is dispatched by an Arcade Physics World instance if a body overlaps with a Tile _and_\n     * has its [onOverlap]{@link Phaser.Physics.Arcade.Body#onOverlap} property set to `true`.\n     *\n     * It provides an alternative means to handling overlap events rather than using the callback approach.\n     *\n     * Listen to it from a Scene using: `this.physics.world.on('tileoverlap', listener)`.\n     *\n     * Please note that 'collide' and 'overlap' are two different things in Arcade Physics.\n     *\n     * @event Phaser.Physics.Arcade.Events#TILE_OVERLAP\n     * @since 3.16.1\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object involved in the overlap. This is the parent of `body`.\n     * @param {Phaser.Tilemaps.Tile} tile - The tile the body overlapped.\n     * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body of the Game Object involved in the overlap.\n     */\n    TILE_OVERLAP: 'tileoverlap',\n    /**\n     * The Arcade Physics World Bounds Event.\n     *\n     * This event is dispatched by an Arcade Physics World instance if a body makes contact with the world bounds _and_\n     * it has its [onWorldBounds]{@link Phaser.Physics.Arcade.Body#onWorldBounds} property set to `true`.\n     *\n     * It provides an alternative means to handling collide events rather than using the callback approach.\n     *\n     * Listen to it from a Scene using: `this.physics.world.on('worldbounds', listener)`.\n     *\n     * @event Phaser.Physics.Arcade.Events#WORLD_BOUNDS\n     * @since 3.0.0\n     *\n     * @param {Phaser.Physics.Arcade.Body} body - The Arcade Physics Body that hit the world bounds.\n     * @param {boolean} up - Is the Body blocked up? I.e. collided with the top of the world bounds.\n     * @param {boolean} down - Is the Body blocked down? I.e. collided with the bottom of the world bounds.\n     * @param {boolean} left - Is the Body blocked left? I.e. collided with the left of the world bounds.\n     * @param {boolean} right - Is the Body blocked right? I.e. collided with the right of the world bounds.\n     */\n    WORLD_BOUNDS: 'worldbounds',\n    /**\n     * The Arcade Physics World Step Event.\n     *\n     * This event is dispatched by an Arcade Physics World instance whenever a physics step is run.\n     * It is emitted _after_ the bodies and colliders have been updated.\n     *\n     * In high framerate settings this can be multiple times per game frame.\n     *\n     * Listen to it from a Scene using: `this.physics.world.on('worldstep', listener)`.\n     *\n     * @event Phaser.Physics.Arcade.Events#WORLD_STEP\n     * @since 3.18.0\n     *\n     * @param {number} delta - The delta time amount of this step, in seconds.\n     */\n    WORLD_STEP: 'worldstep'\n};\n//# sourceMappingURL=index.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Checks if a given point is inside a Rectangle's bounds.\n *\n * @function Phaser.Geom.Rectangle.Contains\n * @since 3.0.0\n *\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to check.\n * @param {number} x - The X coordinate of the point to check.\n * @param {number} y - The Y coordinate of the point to check.\n *\n * @return {boolean} `true` if the point is within the Rectangle's bounds, otherwise `false`.\n */\nconst Contains = (rect, x, y) => {\n    if (rect.width <= 0 || rect.height <= 0) {\n        return false;\n    }\n    return rect.x <= x && rect.x + rect.width >= x && rect.y <= y && rect.y + rect.height >= y;\n};\nexports.default = Contains;\n//# sourceMappingURL=Contains.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculates the perimeter of a Rectangle.\n *\n * @function Phaser.Geom.Rectangle.Perimeter\n * @since 3.0.0\n *\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to use.\n *\n * @return {number} The perimeter of the Rectangle, equal to `(width * 2) + (height * 2)`.\n */\nconst Perimeter = rect => {\n    return 2 * (rect.width + rect.height);\n};\nexports.default = Perimeter;\n//# sourceMappingURL=Perimeter.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//  Taken from klasse by mattdesl https://github.com/mattdesl/klasse\nfunction hasGetterOrSetter(def) {\n    return (!!def.get && typeof def.get === 'function') || (!!def.set && typeof def.set === 'function');\n}\nfunction getProperty(definition, k, isClassDescriptor) {\n    //  This may be a lightweight object, OR it might be a property that was defined previously.\n    //  For simple class descriptors we can just assume its NOT previously defined.\n    let def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\n    if (!isClassDescriptor && def.value && typeof def.value === 'object') {\n        def = def.value;\n    }\n    //  This might be a regular property, or it may be a getter/setter the user defined in a class.\n    if (def && hasGetterOrSetter(def)) {\n        if (typeof def.enumerable === 'undefined') {\n            def.enumerable = true;\n        }\n        if (typeof def.configurable === 'undefined') {\n            def.configurable = true;\n        }\n        return def;\n    }\n    else {\n        return false;\n    }\n}\nfunction hasNonConfigurable(obj, k) {\n    let prop = Object.getOwnPropertyDescriptor(obj, k);\n    if (!prop) {\n        return false;\n    }\n    if (prop.value && typeof prop.value === 'object') {\n        prop = prop.value;\n    }\n    if (prop.configurable === false) {\n        return true;\n    }\n    return false;\n}\n/**\n * Extends the given `myClass` object's prototype with the properties of `definition`.\n *\n * @function extend\n * @ignore\n * @param {Object} ctor The constructor object to mix into.\n * @param {Object} definition A dictionary of functions for the class.\n * @param {boolean} isClassDescriptor Is the definition a class descriptor?\n * @param {Object} [extend] The parent constructor object.\n */\nfunction extend(ctor, definition, isClassDescriptor, extend) {\n    for (const k in definition) {\n        if (!definition.hasOwnProperty(k)) {\n            continue;\n        }\n        const def = getProperty(definition, k, isClassDescriptor);\n        if (def !== false) {\n            //  If Extends is used, we will check its prototype to see if the final variable exists.\n            const parent = extend || ctor;\n            if (hasNonConfigurable(parent.prototype, k)) {\n                //  Just skip the final property\n                if (Class.ignoreFinals) {\n                    continue;\n                }\n                //  We cannot re-define a property that is configurable=false.\n                //  So we will consider them final and throw an error. This is by\n                //  default so it is clear to the developer what is happening.\n                //  You can set ignoreFinals to true if you need to extend a class\n                //  which has configurable=false; it will simply not re-define final properties.\n                throw new Error(`cannot override final property '${k}', set Class.ignoreFinals = true to skip`);\n            }\n            Object.defineProperty(ctor.prototype, k, def);\n        }\n        else {\n            ctor.prototype[k] = definition[k];\n        }\n    }\n}\n/**\n * Applies the given `mixins` to the prototype of `myClass`.\n *\n * @function mixin\n * @ignore\n * @param {Object} myClass The constructor object to mix into.\n * @param {Object|Array<Object>} mixins The mixins to apply to the constructor.\n */\nfunction mixin(myClass, mixins) {\n    if (!mixins) {\n        return;\n    }\n    if (!Array.isArray(mixins)) {\n        mixins = [mixins];\n    }\n    for (let i = 0; i < mixins.length; i++) {\n        extend(myClass, mixins[i].prototype || mixins[i]);\n    }\n}\n/**\n * Creates a new class with the given descriptor.\n * The constructor, defined by the name `initialize`,\n * is an optional function. If unspecified, an anonymous\n * function will be used which calls the parent class (if\n * one exists).\n *\n * You can also use `Extends` and `Mixins` to provide subclassing\n * and inheritance.\n *\n * @class Phaser.Class\n * @constructor\n * @param {Object} definition a dictionary of functions for the class\n * @example\n *\n *      var MyClass = new Phaser.Class({\n *\n *          initialize: function() {\n *              this.foo = 2.0;\n *          },\n *\n *          bar: function() {\n *              return this.foo + 5;\n *          }\n *      });\n */\nfunction Class(definition) {\n    if (!definition) {\n        definition = {};\n    }\n    //  The variable name here dictates what we see in Chrome debugger\n    let initialize;\n    let Extends;\n    if (definition.initialize) {\n        if (typeof definition.initialize !== 'function') {\n            throw new Error('initialize must be a function');\n        }\n        initialize = definition.initialize;\n        //  Usually we should avoid 'delete' in V8 at all costs.\n        //  However, its unlikely to make any performance difference\n        //  here since we only call this on class creation (i.e. not object creation).\n        delete definition.initialize;\n    }\n    else if (definition.Extends) {\n        const base = definition.Extends;\n        initialize = function () {\n            base.apply(this, arguments);\n        };\n    }\n    else {\n        initialize = () => { };\n    }\n    if (definition.Extends) {\n        initialize.prototype = Object.create(definition.Extends.prototype);\n        initialize.prototype.constructor = initialize;\n        //  For getOwnPropertyDescriptor to work, we need to act directly on the Extends (or Mixin)\n        Extends = definition.Extends;\n        delete definition.Extends;\n    }\n    else {\n        initialize.prototype.constructor = initialize;\n    }\n    //  Grab the mixins, if they are specified...\n    let mixins = null;\n    if (definition.Mixins) {\n        mixins = definition.Mixins;\n        delete definition.Mixins;\n    }\n    //  First, mixin if we can.\n    mixin(initialize, mixins);\n    //  Now we grab the actual definition which defines the overrides.\n    extend(initialize, definition, true, Extends);\n    return initialize;\n}\nClass.extend = extend;\nClass.mixin = mixin;\nClass.ignoreFinals = false;\nexports.default = Class;\n//# sourceMappingURL=Class.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GEOM_CONST = {\n    /**\n     * A Circle Geometry object type.\n     *\n     * @name Phaser.Geom.CIRCLE\n     * @type {number}\n     * @since 3.19.0\n     */\n    CIRCLE: 0,\n    /**\n     * An Ellipse Geometry object type.\n     *\n     * @name Phaser.Geom.ELLIPSE\n     * @type {number}\n     * @since 3.19.0\n     */\n    ELLIPSE: 1,\n    /**\n     * A Line Geometry object type.\n     *\n     * @name Phaser.Geom.LINE\n     * @type {number}\n     * @since 3.19.0\n     */\n    LINE: 2,\n    /**\n     * A Point Geometry object type.\n     *\n     * @name Phaser.Geom.POINT\n     * @type {number}\n     * @since 3.19.0\n     */\n    POINT: 3,\n    /**\n     * A Polygon Geometry object type.\n     *\n     * @name Phaser.Geom.POLYGON\n     * @type {number}\n     * @since 3.19.0\n     */\n    POLYGON: 4,\n    /**\n     * A Rectangle Geometry object type.\n     *\n     * @name Phaser.Geom.RECTANGLE\n     * @type {number}\n     * @since 3.19.0\n     */\n    RECTANGLE: 5,\n    /**\n     * A Triangle Geometry object type.\n     *\n     * @name Phaser.Geom.TRIANGLE\n     * @type {number}\n     * @since 3.19.0\n     */\n    TRIANGLE: 6\n};\nexports.default = GEOM_CONST;\n//# sourceMappingURL=const.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Class_1 = __importDefault(require(\"../../utils/Class\"));\nconst const_1 = __importDefault(require(\"../const\"));\n/**\n * @classdesc\n * Defines a Point in 2D space, with an x and y component.\n *\n * @class Point\n * @memberof Phaser.Geom\n * @constructor\n * @since 3.0.0\n *\n * @param {number} [x=0] - The x coordinate of this Point.\n * @param {number} [y=x] - The y coordinate of this Point.\n */\nconst Point = new Class_1.default({\n    initialize: function Point(x, y) {\n        if (x === undefined) {\n            x = 0;\n        }\n        if (y === undefined) {\n            y = x;\n        }\n        /**\n         * The geometry constant type of this object: `GEOM_CONST.POINT`.\n         * Used for fast type comparisons.\n         *\n         * @name Phaser.Geom.Point#type\n         * @type {number}\n         * @readonly\n         * @since 3.19.0\n         */\n        this.type = const_1.default.POINT;\n        /**\n         * The x coordinate of this Point.\n         *\n         * @name Phaser.Geom.Point#x\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.x = x;\n        /**\n         * The y coordinate of this Point.\n         *\n         * @name Phaser.Geom.Point#y\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.y = y;\n    },\n    /**\n     * Set the x and y coordinates of the point to the given values.\n     *\n     * @method Phaser.Geom.Point#setTo\n     * @since 3.0.0\n     *\n     * @param {number} [x=0] - The x coordinate of this Point.\n     * @param {number} [y=x] - The y coordinate of this Point.\n     *\n     * @return {this} This Point object.\n     */\n    setTo: function (x, y) {\n        if (x === undefined) {\n            x = 0;\n        }\n        if (y === undefined) {\n            y = x;\n        }\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n});\nexports.default = Point;\n//# sourceMappingURL=Point.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Perimeter_1 = __importDefault(require(\"./Perimeter\"));\nconst Point_1 = __importDefault(require(\"../point/Point\"));\n/**\n * Calculates the coordinates of a point at a certain `position` on the Rectangle's perimeter.\n *\n * The `position` is a fraction between 0 and 1 which defines how far into the perimeter the point is.\n *\n * A value of 0 or 1 returns the point at the top left corner of the rectangle, while a value of 0.5 returns the point at the bottom right corner of the rectangle. Values between 0 and 0.5 are on the top or the right side and values between 0.5 and 1 are on the bottom or the left side.\n *\n * @function Phaser.Geom.Rectangle.GetPoint\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point} O - [out,$return]\n *\n * @param {Phaser.Geom.Rectangle} rectangle - The Rectangle to get the perimeter point from.\n * @param {number} position - The normalized distance into the Rectangle's perimeter to return.\n * @param {(Phaser.Geom.Point|object)} [out] - An object to update with the `x` and `y` coordinates of the point.\n *\n * @return {Phaser.Geom.Point} The updated `output` object, or a new Point if no `output` object was given.\n */\nconst GetPoint = (rectangle, position, out) => {\n    if (out === undefined) {\n        out = new Point_1.default();\n    }\n    if (position <= 0 || position >= 1) {\n        out.x = rectangle.x;\n        out.y = rectangle.y;\n        return out;\n    }\n    let p = (0, Perimeter_1.default)(rectangle) * position;\n    if (position > 0.5) {\n        p -= rectangle.width + rectangle.height;\n        if (p <= rectangle.width) {\n            //  Face 3\n            out.x = rectangle.right - p;\n            out.y = rectangle.bottom;\n        }\n        else {\n            //  Face 4\n            out.x = rectangle.x;\n            out.y = rectangle.bottom - (p - rectangle.width);\n        }\n    }\n    else if (p <= rectangle.width) {\n        //  Face 1\n        out.x = rectangle.x + p;\n        out.y = rectangle.y;\n    }\n    else {\n        //  Face 2\n        out.x = rectangle.right;\n        out.y = rectangle.y + (p - rectangle.width);\n    }\n    return out;\n};\nexports.default = GetPoint;\n//# sourceMappingURL=GetPoint.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst GetPoint_1 = __importDefault(require(\"./GetPoint\"));\nconst Perimeter_1 = __importDefault(require(\"./Perimeter\"));\n//  Return an array of points from the perimeter of the rectangle\n//  each spaced out based on the quantity or step required\n/**\n * Return an array of points from the perimeter of the rectangle, each spaced out based on the quantity or step required.\n *\n * @function Phaser.Geom.Rectangle.GetPoints\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\n *\n * @param {Phaser.Geom.Rectangle} rectangle - The Rectangle object to get the points from.\n * @param {number} step - Step between points. Used to calculate the number of points to return when quantity is falsey. Ignored if quantity is positive.\n * @param {number} quantity - The number of evenly spaced points from the rectangles perimeter to return. If falsey, step param will be used to calculate the number of points.\n * @param {(array|Phaser.Geom.Point[])} [out] - An optional array to store the points in.\n *\n * @return {(array|Phaser.Geom.Point[])} An array of Points from the perimeter of the rectangle.\n */\nconst GetPoints = (rectangle, quantity, stepRate, out) => {\n    if (out === undefined) {\n        out = [];\n    }\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\n    if (!quantity && stepRate > 0) {\n        quantity = (0, Perimeter_1.default)(rectangle) / stepRate;\n    }\n    for (let i = 0; i < quantity; i++) {\n        const position = i / quantity;\n        out.push((0, GetPoint_1.default)(rectangle, position));\n    }\n    return out;\n};\nexports.default = GetPoints;\n//# sourceMappingURL=GetPoints.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Point_1 = __importDefault(require(\"../point/Point\"));\n/**\n * Get a point on a line that's a given percentage along its length.\n *\n * @function Phaser.Geom.Line.GetPoint\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point} O - [out,$return]\n *\n * @param {Phaser.Geom.Line} line - The line.\n * @param {number} position - A value between 0 and 1, where 0 is the start, 0.5 is the middle and 1 is the end of the line.\n * @param {(Phaser.Geom.Point|object)} [out] - An optional point, or point-like object, to store the coordinates of the point on the line.\n *\n * @return {(Phaser.Geom.Point|object)} The point on the line.\n */\nconst GetPoint = (line, position, out) => {\n    if (out === undefined) {\n        out = new Point_1.default();\n    }\n    out.x = line.x1 + (line.x2 - line.x1) * position;\n    out.y = line.y1 + (line.y2 - line.y1) * position;\n    return out;\n};\nexports.default = GetPoint;\n//# sourceMappingURL=GetPoint.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Calculate the length of the given line.\n *\n * @function Phaser.Geom.Line.Length\n * @since 3.0.0\n *\n * @param {Phaser.Geom.Line} line - The line to calculate the length of.\n *\n * @return {number} The length of the line.\n */\nconst Length = line => {\n    return Math.sqrt((line.x2 - line.x1) * (line.x2 - line.x1) + (line.y2 - line.y1) * (line.y2 - line.y1));\n};\nexports.default = Length;\n//# sourceMappingURL=Length.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Length_1 = __importDefault(require(\"./Length\"));\nconst Point_1 = __importDefault(require(\"../point/Point\"));\n/**\n * Get a number of points along a line's length.\n *\n * Provide a `quantity` to get an exact number of points along the line.\n *\n * Provide a `stepRate` to ensure a specific distance between each point on the line. Set `quantity` to `0` when\n * providing a `stepRate`.\n *\n * @function Phaser.Geom.Line.GetPoints\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point[]} O - [out,$return]\n *\n * @param {Phaser.Geom.Line} line - The line.\n * @param {number} quantity - The number of points to place on the line. Set to `0` to use `stepRate` instead.\n * @param {number} [stepRate] - The distance between each point on the line. When set, `quantity` is implied and should be set to `0`.\n * @param {(array|Phaser.Geom.Point[])} [out] - An optional array of Points, or point-like objects, to store the coordinates of the points on the line.\n *\n * @return {(array|Phaser.Geom.Point[])} An array of Points, or point-like objects, containing the coordinates of the points on the line.\n */\nconst GetPoints = (line, quantity, stepRate, out) => {\n    if (out === undefined) {\n        out = [];\n    }\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\n    if (!quantity && stepRate > 0) {\n        quantity = (0, Length_1.default)(line) / stepRate;\n    }\n    const x1 = line.x1;\n    const y1 = line.y1;\n    const x2 = line.x2;\n    const y2 = line.y2;\n    for (let i = 0; i < quantity; i++) {\n        const position = i / quantity;\n        const x = x1 + (x2 - x1) * position;\n        const y = y1 + (y2 - y1) * position;\n        out.push(new Point_1.default(x, y));\n    }\n    return out;\n};\nexports.default = GetPoints;\n//# sourceMappingURL=GetPoints.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Point_1 = __importDefault(require(\"../point/Point\"));\n/**\n * Returns a random point on a given Line.\n *\n * @function Phaser.Geom.Line.Random\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point} O - [out,$return]\n *\n * @param {Phaser.Geom.Line} line - The Line to calculate the random Point on.\n * @param {(Phaser.Geom.Point|object)} [out] - An instance of a Point to be modified.\n *\n * @return {(Phaser.Geom.Point|object)} A random Point on the Line.\n */\nconst Random = (line, out) => {\n    if (out === undefined) {\n        out = new Point_1.default();\n    }\n    const t = Math.random();\n    out.x = line.x1 + t * (line.x2 - line.x1);\n    out.y = line.y1 + t * (line.y2 - line.y1);\n    return out;\n};\nexports.default = Random;\n//# sourceMappingURL=Random.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Check whether the given values are fuzzily equal.\n *\n * Two numbers are fuzzily equal if their difference is less than `epsilon`.\n *\n * @function Phaser.Math.Fuzzy.Equal\n * @since 3.0.0\n *\n * @param {number} a - The first value.\n * @param {number} b - The second value.\n * @param {number} [epsilon=0.0001] - The epsilon.\n *\n * @return {boolean} `true` if the values are fuzzily equal, otherwise `false`.\n */\nconst Equal = (a, b, epsilon) => {\n    if (epsilon === undefined) {\n        epsilon = 0.0001;\n    }\n    return Math.abs(a - b) < epsilon;\n};\nexports.default = Equal;\n//# sourceMappingURL=Equal.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Vector2 = void 0;\n//  Adapted from [gl-matrix](https://github.com/toji/gl-matrix) by toji\n//  and [vecmath](https://github.com/mattdesl/vecmath) by mattdesl\n// let Class = require('../utils/Class')\nconst FuzzyEqual = require('../math/fuzzy/Equal');\n/**\n * @classdesc\n * A representation of a vector in 2D space.\n *\n * A two-component vector.\n *\n * @class Vector2\n * @memberof Phaser.Math\n * @constructor\n * @since 3.0.0\n *\n * @param {number|Phaser.Types.Math.Vector2Like} [x] - The x component, or an object with `x` and `y` properties.\n * @param {number} [y] - The y component.\n */\nclass Vector2 {\n    constructor(x, y) {\n        /**\n         * The x component of this Vector.\n         *\n         * @name Phaser.Math.Vector2#x\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.x = 0;\n        /**\n         * The y component of this Vector.\n         *\n         * @name Phaser.Math.Vector2#y\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.y = 0;\n        if (typeof x === 'object') {\n            this.x = x.x || 0;\n            this.y = x.y || 0;\n        }\n        else {\n            if (y === undefined) {\n                y = x;\n            }\n            this.x = x || 0;\n            this.y = y || 0;\n        }\n    }\n    /**\n     * Make a clone of this Vector2.\n     *\n     * @method Phaser.Math.Vector2#clone\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} A clone of this Vector2.\n     */\n    clone() {\n        return new Vector2(this.x, this.y);\n    }\n    /**\n     * Copy the components of a given Vector into this Vector.\n     *\n     * @method Phaser.Math.Vector2#copy\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to copy the components from.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    copy(src) {\n        this.x = src.x || 0;\n        this.y = src.y || 0;\n        return this;\n    }\n    /**\n     * Set the component values of this Vector from a given Vector2Like object.\n     *\n     * @method Phaser.Math.Vector2#setFromObject\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} obj - The object containing the component values to set for this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    setFromObject(obj) {\n        this.x = obj.x || 0;\n        this.y = obj.y || 0;\n        return this;\n    }\n    /**\n     * Set the `x` and `y` components of the this Vector to the given `x` and `y` values.\n     *\n     * @method Phaser.Math.Vector2#set\n     * @since 3.0.0\n     *\n     * @param {number} x - The x value to set for this Vector.\n     * @param {number} [y=x] - The y value to set for this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    set(x, y) {\n        if (y === undefined) {\n            y = x;\n        }\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    /**\n     * This method is an alias for `Vector2.set`.\n     *\n     * @method Phaser.Math.Vector2#setTo\n     * @since 3.4.0\n     *\n     * @param {number} x - The x value to set for this Vector.\n     * @param {number} [y=x] - The y value to set for this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    setTo(x, y) {\n        return this.set(x, y);\n    }\n    /**\n     * Sets the `x` and `y` values of this object from a given polar coordinate.\n     *\n     * @method Phaser.Math.Vector2#setToPolar\n     * @since 3.0.0\n     *\n     * @param {number} azimuth - The angular coordinate, in radians.\n     * @param {number} [radius=1] - The radial coordinate (length).\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    setToPolar(azimuth, radius) {\n        if (radius == null) {\n            radius = 1;\n        }\n        this.x = Math.cos(azimuth) * radius;\n        this.y = Math.sin(azimuth) * radius;\n        return this;\n    }\n    /**\n     * Check whether this Vector is equal to a given Vector.\n     *\n     * Performs a strict equality check against each Vector's components.\n     *\n     * @method Phaser.Math.Vector2#equals\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} v - The vector to compare with this Vector.\n     *\n     * @return {boolean} Whether the given Vector is equal to this Vector.\n     */\n    equals(v) {\n        return this.x === v.x && this.y === v.y;\n    }\n    /**\n     * Check whether this Vector is approximately equal to a given Vector.\n     *\n     * @method Phaser.Math.Vector2#fuzzyEquals\n     * @since 3.23.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} v - The vector to compare with this Vector.\n     * @param {number} [epsilon=0.0001] - The tolerance value.\n     *\n     * @return {boolean} Whether both absolute differences of the x and y components are smaller than `epsilon`.\n     */\n    fuzzyEquals(v, epsilon) {\n        return FuzzyEqual(this.x, v.x, epsilon) && FuzzyEqual(this.y, v.y, epsilon);\n    }\n    /**\n     * Calculate the angle between this Vector and the positive x-axis, in radians.\n     *\n     * @method Phaser.Math.Vector2#angle\n     * @since 3.0.0\n     *\n     * @return {number} The angle between this Vector, and the positive x-axis, given in radians.\n     */\n    angle() {\n        // computes the angle in radians with respect to the positive x-axis\n        let angle = Math.atan2(this.y, this.x);\n        if (angle < 0) {\n            angle += 2 * Math.PI;\n        }\n        return angle;\n    }\n    /**\n     * Set the angle of this Vector.\n     *\n     * @method Phaser.Math.Vector2#setAngle\n     * @since 3.23.0\n     *\n     * @param {number} angle - The angle, in radians.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    setAngle(angle) {\n        return this.setToPolar(angle, this.length());\n    }\n    /**\n     * Add a given Vector to this Vector. Addition is component-wise.\n     *\n     * @method Phaser.Math.Vector2#add\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to add to this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    add(src) {\n        this.x += src.x;\n        this.y += src.y;\n        return this;\n    }\n    /**\n     * Subtract the given Vector from this Vector. Subtraction is component-wise.\n     *\n     * @method Phaser.Math.Vector2#subtract\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to subtract from this Vector.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    subtract(src) {\n        this.x -= src.x;\n        this.y -= src.y;\n        return this;\n    }\n    /**\n     * Perform a component-wise multiplication between this Vector and the given Vector.\n     *\n     * Multiplies this Vector by the given Vector.\n     *\n     * @method Phaser.Math.Vector2#multiply\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to multiply this Vector by.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    multiply(src) {\n        this.x *= src.x;\n        this.y *= src.y;\n        return this;\n    }\n    /**\n     * Scale this Vector by the given value.\n     *\n     * @method Phaser.Math.Vector2#scale\n     * @since 3.0.0\n     *\n     * @param {number} value - The value to scale this Vector by.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    scale(value) {\n        if (isFinite(value)) {\n            this.x *= value;\n            this.y *= value;\n        }\n        else {\n            this.x = 0;\n            this.y = 0;\n        }\n        return this;\n    }\n    /**\n     * Perform a component-wise division between this Vector and the given Vector.\n     *\n     * Divides this Vector by the given Vector.\n     *\n     * @method Phaser.Math.Vector2#divide\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to divide this Vector by.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    divide(src) {\n        this.x /= src.x;\n        this.y /= src.y;\n        return this;\n    }\n    /**\n     * Negate the `x` and `y` components of this Vector.\n     *\n     * @method Phaser.Math.Vector2#negate\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    negate() {\n        this.x = -this.x;\n        this.y = -this.y;\n        return this;\n    }\n    /**\n     * Calculate the distance between this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector2#distance\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to calculate the distance to.\n     *\n     * @return {number} The distance from this Vector to the given Vector.\n     */\n    distance(src) {\n        const dx = src.x - this.x;\n        const dy = src.y - this.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    /**\n     * Calculate the distance between this Vector and the given Vector, squared.\n     *\n     * @method Phaser.Math.Vector2#distanceSq\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector to calculate the distance to.\n     *\n     * @return {number} The distance from this Vector to the given Vector, squared.\n     */\n    distanceSq(src) {\n        const dx = src.x - this.x;\n        const dy = src.y - this.y;\n        return dx * dx + dy * dy;\n    }\n    /**\n     * Calculate the length (or magnitude) of this Vector.\n     *\n     * @method Phaser.Math.Vector2#length\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Vector.\n     */\n    length() {\n        const x = this.x;\n        const y = this.y;\n        return Math.sqrt(x * x + y * y);\n    }\n    /**\n     * Set the length (or magnitude) of this Vector.\n     *\n     * @method Phaser.Math.Vector2#setLength\n     * @since 3.23.0\n     *\n     * @param {number} length\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    setLength(length) {\n        return this.normalize().scale(length);\n    }\n    /**\n     * Calculate the length of this Vector squared.\n     *\n     * @method Phaser.Math.Vector2#lengthSq\n     * @since 3.0.0\n     *\n     * @return {number} The length of this Vector, squared.\n     */\n    lengthSq() {\n        const x = this.x;\n        const y = this.y;\n        return x * x + y * y;\n    }\n    /**\n     * Normalize this Vector.\n     *\n     * Makes the vector a unit length vector (magnitude of 1) in the same direction.\n     *\n     * @method Phaser.Math.Vector2#normalize\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    normalize() {\n        const x = this.x;\n        const y = this.y;\n        let len = x * x + y * y;\n        if (len > 0) {\n            len = 1 / Math.sqrt(len);\n            this.x = x * len;\n            this.y = y * len;\n        }\n        return this;\n    }\n    /**\n     * Rotate this Vector to its perpendicular, in the positive direction.\n     *\n     * @method Phaser.Math.Vector2#normalizeRightHand\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    normalizeRightHand() {\n        const x = this.x;\n        this.x = this.y * -1;\n        this.y = x;\n        return this;\n    }\n    /**\n     * Rotate this Vector to its perpendicular, in the negative direction.\n     *\n     * @method Phaser.Math.Vector2#normalizeLeftHand\n     * @since 3.23.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    normalizeLeftHand() {\n        const x = this.x;\n        this.x = this.y;\n        this.y = x * -1;\n        return this;\n    }\n    /**\n     * Calculate the dot product of this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector2#dot\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to dot product with this Vector2.\n     *\n     * @return {number} The dot product of this Vector and the given Vector.\n     */\n    dot(src) {\n        return this.x * src.x + this.y * src.y;\n    }\n    /**\n     * Calculate the cross product of this Vector and the given Vector.\n     *\n     * @method Phaser.Math.Vector2#cross\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to cross with this Vector2.\n     *\n     * @return {number} The cross product of this Vector and the given Vector.\n     */\n    cross(src) {\n        return this.x * src.y - this.y * src.x;\n    }\n    /**\n     * Linearly interpolate between this Vector and the given Vector.\n     *\n     * Interpolates this Vector towards the given Vector.\n     *\n     * @method Phaser.Math.Vector2#lerp\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Math.Vector2Like} src - The Vector2 to interpolate towards.\n     * @param {number} [t=0] - The interpolation percentage, between 0 and 1.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    lerp(src, t) {\n        if (t === undefined) {\n            t = 0;\n        }\n        const ax = this.x;\n        const ay = this.y;\n        this.x = ax + t * (src.x - ax);\n        this.y = ay + t * (src.y - ay);\n        return this;\n    }\n    /**\n     * Transform this Vector with the given Matrix.\n     *\n     * @method Phaser.Math.Vector2#transformMat3\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix3} mat - The Matrix3 to transform this Vector2 with.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    transformMat3(mat) {\n        const x = this.x;\n        const y = this.y;\n        const m = mat.val;\n        this.x = m[0] * x + m[3] * y + m[6];\n        this.y = m[1] * x + m[4] * y + m[7];\n        return this;\n    }\n    /**\n     * Transform this Vector with the given Matrix.\n     *\n     * @method Phaser.Math.Vector2#transformMat4\n     * @since 3.0.0\n     *\n     * @param {Phaser.Math.Matrix4} mat - The Matrix4 to transform this Vector2 with.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    transformMat4(mat) {\n        const x = this.x;\n        const y = this.y;\n        const m = mat.val;\n        this.x = m[0] * x + m[4] * y + m[12];\n        this.y = m[1] * x + m[5] * y + m[13];\n        return this;\n    }\n    /**\n     * Make this Vector the zero vector (0, 0).\n     *\n     * @method Phaser.Math.Vector2#reset\n     * @since 3.0.0\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    reset() {\n        this.x = 0;\n        this.y = 0;\n        return this;\n    }\n    /**\n     * Limit the length (or magnitude) of this Vector.\n     *\n     * @method Phaser.Math.Vector2#limit\n     * @since 3.23.0\n     *\n     * @param {number} max - The maximum length.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    limit(max) {\n        const len = this.length();\n        if (len && len > max) {\n            this.scale(max / len);\n        }\n        return this;\n    }\n    /**\n     * Reflect this Vector off a line defined by a normal.\n     *\n     * @method Phaser.Math.Vector2#reflect\n     * @since 3.23.0\n     *\n     * @param {Phaser.Math.Vector2} normal - A vector perpendicular to the line.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    reflect(normal) {\n        normal = normal.clone().normalize();\n        return this.subtract(normal.scale(2 * this.dot(normal)));\n    }\n    /**\n     * Reflect this Vector across another.\n     *\n     * @method Phaser.Math.Vector2#mirror\n     * @since 3.23.0\n     *\n     * @param {Phaser.Math.Vector2} axis - A vector to reflect across.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    mirror(axis) {\n        return this.reflect(axis).negate();\n    }\n    /**\n     * Rotate this Vector by an angle amount.\n     *\n     * @method Phaser.Math.Vector2#rotate\n     * @since 3.23.0\n     *\n     * @param {number} delta - The angle to rotate by, in radians.\n     *\n     * @return {Phaser.Math.Vector2} This Vector2.\n     */\n    rotate(delta) {\n        const cos = Math.cos(delta);\n        const sin = Math.sin(delta);\n        return this.set(cos * this.x - sin * this.y, sin * this.x + cos * this.y);\n    }\n}\nexports.Vector2 = Vector2;\n/**\n * A static zero Vector2 for use by reference.\n *\n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.ZERO\n * @type {Phaser.Math.Vector2}\n * @since 3.1.0\n */\nVector2.ZERO = new Vector2();\n/**\n * A static right Vector2 for use by reference.\n *\n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.RIGHT\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.RIGHT = new Vector2(1, 0);\n/**\n * A static left Vector2 for use by reference.\n *\n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.LEFT\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.LEFT = new Vector2(-1, 0);\n/**\n * A static up Vector2 for use by reference.\n *\n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.UP\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.UP = new Vector2(0, -1);\n/**\n * A static down Vector2 for use by reference.\n *\n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.DOWN\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.DOWN = new Vector2(0, 1);\n/**\n * A static one Vector2 for use by reference.\n *\n * This constant is meant for comparison operations and should not be modified directly.\n *\n * @constant\n * @name Phaser.Math.Vector2.ONE\n * @type {Phaser.Math.Vector2}\n * @since 3.16.0\n */\nVector2.ONE = new Vector2(1, 1);\n//# sourceMappingURL=Vector2.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Class_1 = __importDefault(require(\"../../utils/Class\"));\nconst GetPoint_1 = __importDefault(require(\"./GetPoint\"));\nconst GetPoints_1 = __importDefault(require(\"./GetPoints\"));\nconst const_1 = __importDefault(require(\"../const\"));\nconst Random_1 = __importDefault(require(\"./Random\"));\nconst Vector2_1 = __importDefault(require(\"../../math/Vector2\"));\n/**\n * @classdesc\n * Defines a Line segment, a part of a line between two endpoints.\n *\n * @class Line\n * @memberof Phaser.Geom\n * @constructor\n * @since 3.0.0\n *\n * @param {number} [x1=0] - The x coordinate of the lines starting point.\n * @param {number} [y1=0] - The y coordinate of the lines starting point.\n * @param {number} [x2=0] - The x coordinate of the lines ending point.\n * @param {number} [y2=0] - The y coordinate of the lines ending point.\n */\nconst Line = new Class_1.default({\n    initialize: function Line(x1, y1, x2, y2) {\n        if (x1 === undefined) {\n            x1 = 0;\n        }\n        if (y1 === undefined) {\n            y1 = 0;\n        }\n        if (x2 === undefined) {\n            x2 = 0;\n        }\n        if (y2 === undefined) {\n            y2 = 0;\n        }\n        /**\n         * The geometry constant type of this object: `GEOM_CONST.LINE`.\n         * Used for fast type comparisons.\n         *\n         * @name Phaser.Geom.Line#type\n         * @type {number}\n         * @readonly\n         * @since 3.19.0\n         */\n        this.type = const_1.default.LINE;\n        /**\n         * The x coordinate of the lines starting point.\n         *\n         * @name Phaser.Geom.Line#x1\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.x1 = x1;\n        /**\n         * The y coordinate of the lines starting point.\n         *\n         * @name Phaser.Geom.Line#y1\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.y1 = y1;\n        /**\n         * The x coordinate of the lines ending point.\n         *\n         * @name Phaser.Geom.Line#x2\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.x2 = x2;\n        /**\n         * The y coordinate of the lines ending point.\n         *\n         * @name Phaser.Geom.Line#y2\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.y2 = y2;\n    },\n    /**\n     * Get a point on a line that's a given percentage along its length.\n     *\n     * @method Phaser.Geom.Line#getPoint\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point} O - [output,$return]\n     *\n     * @param {number} position - A value between 0 and 1, where 0 is the start, 0.5 is the middle and 1 is the end of the line.\n     * @param {(Phaser.Geom.Point|object)} [output] - An optional point, or point-like object, to store the coordinates of the point on the line.\n     *\n     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point on the line.\n     */\n    getPoint: function (position, output) {\n        return (0, GetPoint_1.default)(this, position, output);\n    },\n    /**\n     * Get a number of points along a line's length.\n     *\n     * Provide a `quantity` to get an exact number of points along the line.\n     *\n     * Provide a `stepRate` to ensure a specific distance between each point on the line. Set `quantity` to `0` when\n     * providing a `stepRate`.\n     *\n     * @method Phaser.Geom.Line#getPoints\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\n     *\n     * @param {number} quantity - The number of points to place on the line. Set to `0` to use `stepRate` instead.\n     * @param {number} [stepRate] - The distance between each point on the line. When set, `quantity` is implied and should be set to `0`.\n     * @param {(array|Phaser.Geom.Point[])} [output] - An optional array of Points, or point-like objects, to store the coordinates of the points on the line.\n     *\n     * @return {(array|Phaser.Geom.Point[])} An array of Points, or point-like objects, containing the coordinates of the points on the line.\n     */\n    getPoints: function (quantity, stepRate, output) {\n        return (0, GetPoints_1.default)(this, quantity, stepRate, output);\n    },\n    /**\n     * Get a random Point on the Line.\n     *\n     * @method Phaser.Geom.Line#getRandomPoint\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point} O - [point,$return]\n     *\n     * @param {(Phaser.Geom.Point|object)} [point] - An instance of a Point to be modified.\n     *\n     * @return {Phaser.Geom.Point} A random Point on the Line.\n     */\n    getRandomPoint: function (point) {\n        return (0, Random_1.default)(this, point);\n    },\n    /**\n     * Set new coordinates for the line endpoints.\n     *\n     * @method Phaser.Geom.Line#setTo\n     * @since 3.0.0\n     *\n     * @param {number} [x1=0] - The x coordinate of the lines starting point.\n     * @param {number} [y1=0] - The y coordinate of the lines starting point.\n     * @param {number} [x2=0] - The x coordinate of the lines ending point.\n     * @param {number} [y2=0] - The y coordinate of the lines ending point.\n     *\n     * @return {this} This Line object.\n     */\n    setTo: function (x1, y1, x2, y2) {\n        if (x1 === undefined) {\n            x1 = 0;\n        }\n        if (y1 === undefined) {\n            y1 = 0;\n        }\n        if (x2 === undefined) {\n            x2 = 0;\n        }\n        if (y2 === undefined) {\n            y2 = 0;\n        }\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        return this;\n    },\n    /**\n     * Returns a Vector2 object that corresponds to the start of this Line.\n     *\n     * @method Phaser.Geom.Line#getPointA\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Math.Vector2} O - [vec2,$return]\n     *\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.\n     *\n     * @return {Phaser.Math.Vector2} A Vector2 object that corresponds to the start of this Line.\n     */\n    getPointA: function (vec2) {\n        if (vec2 === undefined) {\n            vec2 = new Vector2_1.default();\n        }\n        vec2.set(this.x1, this.y1);\n        return vec2;\n    },\n    /**\n     * Returns a Vector2 object that corresponds to the end of this Line.\n     *\n     * @method Phaser.Geom.Line#getPointB\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Math.Vector2} O - [vec2,$return]\n     *\n     * @param {Phaser.Math.Vector2} [vec2] - A Vector2 object to set the results in. If `undefined` a new Vector2 will be created.\n     *\n     * @return {Phaser.Math.Vector2} A Vector2 object that corresponds to the end of this Line.\n     */\n    getPointB: function (vec2) {\n        if (vec2 === undefined) {\n            vec2 = new Vector2_1.default();\n        }\n        vec2.set(this.x2, this.y2);\n        return vec2;\n    },\n    /**\n     * The left position of the Line.\n     *\n     * @name Phaser.Geom.Line#left\n     * @type {number}\n     * @since 3.0.0\n     */\n    left: {\n        get: function () {\n            return Math.min(this.x1, this.x2);\n        },\n        set: function (value) {\n            if (this.x1 <= this.x2) {\n                this.x1 = value;\n            }\n            else {\n                this.x2 = value;\n            }\n        }\n    },\n    /**\n     * The right position of the Line.\n     *\n     * @name Phaser.Geom.Line#right\n     * @type {number}\n     * @since 3.0.0\n     */\n    right: {\n        get: function () {\n            return Math.max(this.x1, this.x2);\n        },\n        set: function (value) {\n            if (this.x1 > this.x2) {\n                this.x1 = value;\n            }\n            else {\n                this.x2 = value;\n            }\n        }\n    },\n    /**\n     * The top position of the Line.\n     *\n     * @name Phaser.Geom.Line#top\n     * @type {number}\n     * @since 3.0.0\n     */\n    top: {\n        get: function () {\n            return Math.min(this.y1, this.y2);\n        },\n        set: function (value) {\n            if (this.y1 <= this.y2) {\n                this.y1 = value;\n            }\n            else {\n                this.y2 = value;\n            }\n        }\n    },\n    /**\n     * The bottom position of the Line.\n     *\n     * @name Phaser.Geom.Line#bottom\n     * @type {number}\n     * @since 3.0.0\n     */\n    bottom: {\n        get: function () {\n            return Math.max(this.y1, this.y2);\n        },\n        set: function (value) {\n            if (this.y1 > this.y2) {\n                this.y1 = value;\n            }\n            else {\n                this.y2 = value;\n            }\n        }\n    }\n});\nexports.default = Line;\n//# sourceMappingURL=Line.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Point_1 = __importDefault(require(\"../point/Point\"));\n/**\n * Returns a random point within a Rectangle.\n *\n * @function Phaser.Geom.Rectangle.Random\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point} O - [out,$return]\n *\n * @param {Phaser.Geom.Rectangle} rect - The Rectangle to return a point from.\n * @param {Phaser.Geom.Point} out - The object to update with the point's coordinates.\n *\n * @return {Phaser.Geom.Point} The modified `out` object, or a new Point if none was provided.\n */\nconst Random = (rect, out) => {\n    if (out === undefined) {\n        out = new Point_1.default();\n    }\n    out.x = rect.x + Math.random() * rect.width;\n    out.y = rect.y + Math.random() * rect.height;\n    return out;\n};\nexports.default = Random;\n//# sourceMappingURL=Random.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Rectangle = void 0;\nconst Contains_1 = __importDefault(require(\"./Contains\"));\nconst GetPoint_1 = __importDefault(require(\"./GetPoint\"));\nconst GetPoints_1 = __importDefault(require(\"./GetPoints\"));\nconst const_1 = __importDefault(require(\"../const\"));\nconst Line_1 = __importDefault(require(\"../line/Line\"));\nconst Random_1 = __importDefault(require(\"./Random\"));\n/**\n * @classdesc\n * Encapsulates a 2D rectangle defined by its corner point in the top-left and its extends in x (width) and y (height)\n *\n * @class Rectangle\n * @memberof Phaser.Geom\n * @constructor\n * @since 3.0.0\n *\n * @param {number} [x=0] - The X coordinate of the top left corner of the Rectangle.\n * @param {number} [y=0] - The Y coordinate of the top left corner of the Rectangle.\n * @param {number} [width=0] - The width of the Rectangle.\n * @param {number} [height=0] - The height of the Rectangle.\n */\nclass Rectangle {\n    constructor(x, y, width, height) {\n        if (x === undefined) {\n            x = 0;\n        }\n        if (y === undefined) {\n            y = 0;\n        }\n        if (width === undefined) {\n            width = 0;\n        }\n        if (height === undefined) {\n            height = 0;\n        }\n        /**\n         * The geometry constant type of this object: `GEOM_CONST.RECTANGLE`.\n         * Used for fast type comparisons.\n         *\n         * @name Phaser.Geom.Rectangle#type\n         * @type {number}\n         * @readonly\n         * @since 3.19.0\n         */\n        this.type = const_1.default.RECTANGLE;\n        /**\n         * The X coordinate of the top left corner of the Rectangle.\n         *\n         * @name Phaser.Geom.Rectangle#x\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.x = x;\n        /**\n         * The Y coordinate of the top left corner of the Rectangle.\n         *\n         * @name Phaser.Geom.Rectangle#y\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.y = y;\n        /**\n         * The width of the Rectangle, i.e. the distance between its left side (defined by `x`) and its right side.\n         *\n         * @name Phaser.Geom.Rectangle#width\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.width = width;\n        /**\n         * The height of the Rectangle, i.e. the distance between its top side (defined by `y`) and its bottom side.\n         *\n         * @name Phaser.Geom.Rectangle#height\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.height = height;\n    }\n    /**\n     * Checks if the given point is inside the Rectangle's bounds.\n     *\n     * @method Phaser.Geom.Rectangle#contains\n     * @since 3.0.0\n     *\n     * @param {number} x - The X coordinate of the point to check.\n     * @param {number} y - The Y coordinate of the point to check.\n     *\n     * @return {boolean} `true` if the point is within the Rectangle's bounds, otherwise `false`.\n     */\n    contains(x, y) {\n        return (0, Contains_1.default)(this, x, y);\n    }\n    /**\n     * Calculates the coordinates of a point at a certain `position` on the Rectangle's perimeter.\n     *\n     * The `position` is a fraction between 0 and 1 which defines how far into the perimeter the point is.\n     *\n     * A value of 0 or 1 returns the point at the top left corner of the rectangle, while a value of 0.5 returns the point at the bottom right corner of the rectangle. Values between 0 and 0.5 are on the top or the right side and values between 0.5 and 1 are on the bottom or the left side.\n     *\n     * @method Phaser.Geom.Rectangle#getPoint\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point} O - [output,$return]\n     *\n     * @param {number} position - The normalized distance into the Rectangle's perimeter to return.\n     * @param {(Phaser.Geom.Point|object)} [output] - An object to update with the `x` and `y` coordinates of the point.\n     *\n     * @return {(Phaser.Geom.Point|object)} The updated `output` object, or a new Point if no `output` object was given.\n     */\n    getPoint(position, output) {\n        return (0, GetPoint_1.default)(this, position, output);\n    }\n    /**\n     * Returns an array of points from the perimeter of the Rectangle, each spaced out based on the quantity or step required.\n     *\n     * @method Phaser.Geom.Rectangle#getPoints\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\n     *\n     * @param {number} quantity - The number of points to return. Set to `false` or 0 to return an arbitrary number of points (`perimeter / stepRate`) evenly spaced around the Rectangle based on the `stepRate`.\n     * @param {number} [stepRate] - If `quantity` is 0, determines the normalized distance between each returned point.\n     * @param {(array|Phaser.Geom.Point[])} [output] - An array to which to append the points.\n     *\n     * @return {(array|Phaser.Geom.Point[])} The modified `output` array, or a new array if none was provided.\n     */\n    getPoints(quantity, stepRate, output) {\n        return (0, GetPoints_1.default)(this, quantity, stepRate, output);\n    }\n    /**\n     * Returns a random point within the Rectangle's bounds.\n     *\n     * @method Phaser.Geom.Rectangle#getRandomPoint\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point} O - [point,$return]\n     *\n     * @param {Phaser.Geom.Point} [point] - The object in which to store the `x` and `y` coordinates of the point.\n     *\n     * @return {Phaser.Geom.Point} The updated `point`, or a new Point if none was provided.\n     */\n    getRandomPoint(point) {\n        return (0, Random_1.default)(this, point);\n    }\n    /**\n     * Sets the position, width, and height of the Rectangle.\n     *\n     * @method Phaser.Geom.Rectangle#setTo\n     * @since 3.0.0\n     *\n     * @param {number} x - The X coordinate of the top left corner of the Rectangle.\n     * @param {number} y - The Y coordinate of the top left corner of the Rectangle.\n     * @param {number} width - The width of the Rectangle.\n     * @param {number} height - The height of the Rectangle.\n     *\n     * @return {this} This Rectangle object.\n     */\n    setTo(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n    /**\n     * Resets the position, width, and height of the Rectangle to 0.\n     *\n     * @method Phaser.Geom.Rectangle#setEmpty\n     * @since 3.0.0\n     *\n     * @return {this} This Rectangle object.\n     */\n    setEmpty() {\n        return this.setTo(0, 0, 0, 0);\n    }\n    /**\n     * Sets the position of the Rectangle.\n     *\n     * @method Phaser.Geom.Rectangle#setPosition\n     * @since 3.0.0\n     *\n     * @param {number} x - The X coordinate of the top left corner of the Rectangle.\n     * @param {number} [y=x] - The Y coordinate of the top left corner of the Rectangle.\n     *\n     * @return {this} This Rectangle object.\n     */\n    setPosition(x, y) {\n        if (y === undefined) {\n            y = x;\n        }\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    /**\n     * Sets the width and height of the Rectangle.\n     *\n     * @method Phaser.Geom.Rectangle#setSize\n     * @since 3.0.0\n     *\n     * @param {number} width - The width to set the Rectangle to.\n     * @param {number} [height=width] - The height to set the Rectangle to.\n     *\n     * @return {this} This Rectangle object.\n     */\n    setSize(width, height) {\n        if (height === undefined) {\n            height = width;\n        }\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n    /**\n     * Determines if the Rectangle is empty. A Rectangle is empty if its width or height is less than or equal to 0.\n     *\n     * @method Phaser.Geom.Rectangle#isEmpty\n     * @since 3.0.0\n     *\n     * @return {boolean} `true` if the Rectangle is empty. A Rectangle object is empty if its width or height is less than or equal to 0.\n     */\n    isEmpty() {\n        return this.width <= 0 || this.height <= 0;\n    }\n    /**\n     * Returns a Line object that corresponds to the top of this Rectangle.\n     *\n     * @method Phaser.Geom.Rectangle#getLineA\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Line} O - [line,$return]\n     *\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\n     *\n     * @return {Phaser.Geom.Line} A Line object that corresponds to the top of this Rectangle.\n     */\n    getLineA(line) {\n        if (line === undefined) {\n            line = new Line_1.default();\n        }\n        line.setTo(this.x, this.y, this.right, this.y);\n        return line;\n    }\n    /**\n     * Returns a Line object that corresponds to the right of this Rectangle.\n     *\n     * @method Phaser.Geom.Rectangle#getLineB\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Line} O - [line,$return]\n     *\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\n     *\n     * @return {Phaser.Geom.Line} A Line object that corresponds to the right of this Rectangle.\n     */\n    getLineB(line) {\n        if (line === undefined) {\n            line = new Line_1.default();\n        }\n        line.setTo(this.right, this.y, this.right, this.bottom);\n        return line;\n    }\n    /**\n     * Returns a Line object that corresponds to the bottom of this Rectangle.\n     *\n     * @method Phaser.Geom.Rectangle#getLineC\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Line} O - [line,$return]\n     *\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\n     *\n     * @return {Phaser.Geom.Line} A Line object that corresponds to the bottom of this Rectangle.\n     */\n    getLineC(line) {\n        if (line === undefined) {\n            line = new Line_1.default();\n        }\n        line.setTo(this.right, this.bottom, this.x, this.bottom);\n        return line;\n    }\n    /**\n     * Returns a Line object that corresponds to the left of this Rectangle.\n     *\n     * @method Phaser.Geom.Rectangle#getLineD\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Line} O - [line,$return]\n     *\n     * @param {Phaser.Geom.Line} [line] - A Line object to set the results in. If `undefined` a new Line will be created.\n     *\n     * @return {Phaser.Geom.Line} A Line object that corresponds to the left of this Rectangle.\n     */\n    getLineD(line) {\n        if (line === undefined) {\n            line = new Line_1.default();\n        }\n        line.setTo(this.x, this.bottom, this.x, this.y);\n        return line;\n    }\n    /**\n     * The x coordinate of the left of the Rectangle.\n     * Changing the left property of a Rectangle object has no effect on the y and height properties. However it does affect the width property, whereas changing the x value does not affect the width property.\n     *\n     * @name Phaser.Geom.Rectangle#left\n     * @type {number}\n     * @since 3.0.0\n     */\n    get left() {\n        return this.x;\n    }\n    set left(value) {\n        if (value >= this.right) {\n            this.width = 0;\n        }\n        else {\n            this.width = this.right - value;\n        }\n        this.x = value;\n    }\n    /**\n     * The sum of the x and width properties.\n     * Changing the right property of a Rectangle object has no effect on the x, y and height properties, however it does affect the width property.\n     *\n     * @name Phaser.Geom.Rectangle#right\n     * @type {number}\n     * @since 3.0.0\n     */\n    get right() {\n        return this.x + this.width;\n    }\n    set right(value) {\n        if (value <= this.x) {\n            this.width = 0;\n        }\n        else {\n            this.width = value - this.x;\n        }\n    }\n    /**\n     * The y coordinate of the top of the Rectangle. Changing the top property of a Rectangle object has no effect on the x and width properties.\n     * However it does affect the height property, whereas changing the y value does not affect the height property.\n     *\n     * @name Phaser.Geom.Rectangle#top\n     * @type {number}\n     * @since 3.0.0\n     */\n    get top() {\n        return this.y;\n    }\n    set top(value) {\n        if (value >= this.bottom) {\n            this.height = 0;\n        }\n        else {\n            this.height = this.bottom - value;\n        }\n        this.y = value;\n    }\n    /**\n     * The sum of the y and height properties.\n     * Changing the bottom property of a Rectangle object has no effect on the x, y and width properties, but does change the height property.\n     *\n     * @name Phaser.Geom.Rectangle#bottom\n     * @type {number}\n     * @since 3.0.0\n     */\n    get bottom() {\n        return this.y + this.height;\n    }\n    set bottom(value) {\n        if (value <= this.y) {\n            this.height = 0;\n        }\n        else {\n            this.height = value - this.y;\n        }\n    }\n    /**\n     * The x coordinate of the center of the Rectangle.\n     *\n     * @name Phaser.Geom.Rectangle#centerX\n     * @type {number}\n     * @since 3.0.0\n     */\n    get centerX() {\n        return this.x + this.width / 2;\n    }\n    set centerX(value) {\n        this.x = value - this.width / 2;\n    }\n    /**\n     * The y coordinate of the center of the Rectangle.\n     *\n     * @name Phaser.Geom.Rectangle#centerY\n     * @type {number}\n     * @since 3.0.0\n     */\n    get centerY() {\n        return this.y + this.height / 2;\n    }\n    set centerY(value) {\n        this.y = value - this.height / 2;\n    }\n}\nexports.Rectangle = Rectangle;\n//# sourceMappingURL=Rectangle.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @author       Benjamin D. Richards <benjamindrichards@gmail.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Body = void 0;\nconst const_1 = __importDefault(require(\"./const\"));\nconst events_1 = __importDefault(require(\"./events\"));\nconst Rectangle_1 = require(\"../../geom/rectangle/Rectangle\");\nconst Contains_1 = __importDefault(require(\"../../geom/rectangle/Contains\"));\nconst Vector2_1 = require(\"../../math/Vector2\");\n/** A Dynamic Arcade Body. */\nclass Body {\n    constructor(world, x, y, width = 64, height = 64) {\n        /** Whether this Body is updated by the physics simulation. */\n        this.enable = true;\n        /** Whether this Body is circular (true) or rectangular (false). */\n        this.isCircle = false;\n        /**\n         * If this Body is circular, this is the unscaled radius of the Body, as set by setCircle(), in source pixels.\n         * The true radius is equal to `halfWidth`.\n         */\n        this.radius = 0;\n        /** Whether this Body's `rotation` is affected by its angular acceleration and angular velocity. */\n        this.allowRotation = true;\n        /** The Body's velocity, in pixels per second. */\n        this.velocity = new Vector2_1.Vector2();\n        /**\n         * The Body's change in position (due to velocity) at the last step, in pixels.\n         *\n         * The size of this value depends on the simulation's step rate.\n         */\n        this.newVelocity = new Vector2_1.Vector2();\n        /** The Body's absolute maximum change in position, in pixels per step. */\n        this.deltaMax = new Vector2_1.Vector2();\n        /** The Body's change in velocity, in pixels per second squared. */\n        this.acceleration = new Vector2_1.Vector2();\n        /** Whether this Body's velocity is affected by its `drag`. */\n        this.allowDrag = true;\n        /**\n         * When `useDamping` is false (the default), this is absolute loss of velocity due to movement, in pixels per second squared.\n         *\n         * When `useDamping` is true, this is a damping multiplier between 0 and 1.\n         * A value of 0 means the Body stops instantly.\n         * A value of 0.01 mean the Body keeps 1% of its velocity per second, losing 99%.\n         * A value of 0.1 means the Body keeps 10% of its velocity per second, losing 90%.\n         * A value of 1 means the Body loses no velocity.\n         * You can use very small values (e.g., 0.001) to stop the Body quickly.\n         *\n         * The x and y components are applied separately.\n         *\n         * Drag is applied only when `acceleration` is zero.\n         */\n        this.drag = new Vector2_1.Vector2();\n        /** Whether this Body's position is affected by gravity (local or world). */\n        this.allowGravity = true;\n        /**\n         * Acceleration due to gravity (specific to this Body), in pixels per second squared.\n         * Total gravity is the sum of this vector and the simulation's `gravity`.\n         */\n        this.gravity = new Vector2_1.Vector2();\n        /** Rebound following a collision, relative to 1. */\n        this.bounce = new Vector2_1.Vector2();\n        /**\n         * Rebound following a collision with the world boundary, relative to 1.\n         * If null, `bounce` is used instead.\n         */\n        this.worldBounce = null;\n        /** Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true). */\n        this.onWorldBounds = false;\n        /** Whether the simulation emits a `collide` event when this Body collides with another. */\n        this.onCollide = false;\n        /** Whether the simulation emits an `overlap` event when this Body overlaps with another. */\n        this.onOverlap = false;\n        /**\n         * The Body's absolute maximum velocity, in pixels per second.\n         * The horizontal and vertical components are applied separately.\n         */\n        this.maxVelocity = new Vector2_1.Vector2(10000, 10000);\n        /**\n         * The maximum speed this Body is allowed to reach, in pixels per second.\n         *\n         * If not negative it limits the scalar value of speed.\n         *\n         * Any negative value means no maximum is being applied (the default).\n         */\n        this.maxSpeed = -1;\n        /**\n         * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\n         * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.\n         * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.\n         * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.\n         */\n        this.friction = new Vector2_1.Vector2(1, 0);\n        /**\n         * If this Body is using `drag` for deceleration this property controls how the drag is applied.\n         * If set to `true` drag will use a damping effect rather than a linear approach. If you are\n         * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\n         * the game Asteroids) then you will get a far smoother and more visually correct deceleration\n         * by using damping, avoiding the axis-drift that is prone with linear deceleration.\n         *\n         * If you enable this property then you should use far smaller `drag` values than with linear, as\n         * they are used as a multiplier on the velocity. Values such as 0.05 will give a nice slow\n         * deceleration.\n         */\n        this.useDamping = false;\n        /** The rate of change of this Body's `rotation`, in degrees per second.  */\n        this.angularVelocity = 0;\n        /** The Body's angular acceleration (change in angular velocity), in degrees per second squared. */\n        this.angularAcceleration = 0;\n        /**\n         * Loss of angular velocity due to angular movement, in degrees per second.\n         *\n         * Angular drag is applied only when angular acceleration is zero.\n         */\n        this.angularDrag = 0;\n        /** The Body's maximum angular velocity, in degrees per second. */\n        this.maxAngular = 1000;\n        /**\n         * The Body's inertia, relative to a default unit (1).\n         * With `bounce`, this affects the exchange of momentum (velocities) during collisions.\n         */\n        this.mass = 1;\n        /** The calculated angle of this Body's velocity vector, in radians, during the last step. */\n        this.angle = 0;\n        /** The calculated magnitude of the Body's velocity, in pixels per second, during the last step. */\n        this.speed = 0;\n        /**\n         * The direction of the Body's velocity, as calculated during the last step.\n         * This is a numeric constant value (FACING_UP, FACING_DOWN, FACING_LEFT, FACING_RIGHT).\n         * If the Body is moving on both axes, this describes motion on the vertical axis only.\n         */\n        this.facing = const_1.default.FACING.FACING_NONE;\n        /** Whether this Body can be moved by collisions with another Body. */\n        this.immovable = false;\n        /**\n         * Sets if this Body can be pushed by another Body.\n         *\n         * A body that cannot be pushed will reflect back all of the velocity it is given to the\n         * colliding body. If that body is also not pushable, then the separation will be split\n         * between them evenly.\n         *\n         * If you want your body to never move or seperate at all, see the `setImmovable` method.\n         *\n         * By default, Dynamic Bodies are always pushable.\n         */\n        this.pushable = true;\n        /** Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity. */\n        this.moves = true;\n        /**\n         * A flag disabling the default horizontal separation of colliding bodies.\n         * Pass your own `collideCallback` to the collider.\n         */\n        this.customSeparateX = false;\n        /**\n         * A flag disabling the default vertical separation of colliding bodies.\n         * Pass your own `collideCallback` to the collider.\n         */\n        this.customSeparateY = false;\n        /** The amount of horizontal overlap (before separation), if this Body is colliding with another. */\n        this.overlapX = 0;\n        /** The amount of vertical overlap (before separation), if this Body is colliding with another. */\n        this.overlapY = 0;\n        /** The amount of overlap (before separation), if this Body is circular and colliding with another circular body. */\n        this.overlapR = 0;\n        /** Whether this Body is overlapped with another and both are not moving, on at least one axis. */\n        this.embedded = false;\n        /** Whether this Body interacts with the world boundary. */\n        this.collideWorldBounds = false;\n        /**\n         * Whether this Body is checked for collisions and for which directions.\n         * You can set `checkCollision.none = true` to disable collision checks.\n         */\n        this.checkCollision = {\n            none: false,\n            up: true,\n            down: true,\n            left: true,\n            right: true\n        };\n        /**\n         * Whether this Body is colliding with a Body or Static Body and in which direction.\n         * In a collision where both bodies have zero velocity, `embedded` will be set instead.\n         */\n        this.touching = {\n            none: true,\n            up: false,\n            down: false,\n            left: false,\n            right: false\n        };\n        /** This Body's `touching` value during the previous step.  */\n        this.wasTouching = {\n            none: true,\n            up: false,\n            down: false,\n            left: false,\n            right: false\n        };\n        /**\n         * Whether this Body is colliding with a Static Body, a tile, or the world boundary.\n         * In a collision with a Static Body, if this Body has zero velocity then `embedded` will be set instead.\n         */\n        this.blocked = {\n            none: true,\n            up: false,\n            down: false,\n            left: false,\n            right: false\n        };\n        /** The Body's physics type (dynamic or static). */\n        this.physicsType = const_1.default.PHYSICS_TYPE.DYNAMIC_BODY;\n        /** The calculated change in the Body's horizontal position during the last step. */\n        this._dx = 0;\n        /** The calculated change in the Body's vertical position during the last step. */\n        this._dy = 0;\n        /** The final calculated change in the Body's horizontal position as of `postUpdate`. */\n        this._tx = 0;\n        /** The final calculated change in the Body's vertical position as of `postUpdate`. */\n        this._ty = 0;\n        /** Stores the Game Object's bounds. */\n        this._bounds = new Rectangle_1.Rectangle();\n        this.isBody = true;\n        this.world = world;\n        this.debugShowBody = world.defaults.debugShowBody;\n        this.debugShowVelocity = world.defaults.debugShowVelocity;\n        this.debugBodyColor = world.defaults.bodyDebugColor;\n        this.position = new Vector2_1.Vector2(x, y);\n        this.prev = this.position.clone();\n        this.prevFrame = this.position.clone();\n        this.rotation = 0;\n        this.preRotation = 0;\n        this.width = width;\n        this.height = height;\n        this.sourceWidth = width;\n        this.sourceHeight = height;\n        this.halfWidth = Math.abs(width / 2);\n        this.halfHeight = Math.abs(height / 2);\n        this.center = new Vector2_1.Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n        this.customBoundsRectangle = world.bounds;\n        this._sx = 1;\n        this._sy = 1;\n    }\n    // used for the btree\n    get minX() {\n        return this.x;\n    }\n    get minY() {\n        return this.y;\n    }\n    get maxX() {\n        return this.x + this.width;\n    }\n    get maxY() {\n        return this.y + this.height;\n    }\n    /** Updates the Body's `center` from its `position`, `width`, and `height`. */\n    updateCenter() {\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n    }\n    /**\n     * Prepares the Body for a physics step by resetting the `wasTouching`, `touching` and `blocked` states.\n     *\n     * This method is only called if the physics world is going to run a step this frame.\n     */\n    resetFlags(clear = false) {\n        //  Store and reset collision flags\n        const wasTouching = this.wasTouching;\n        const touching = this.touching;\n        const blocked = this.blocked;\n        if (clear) {\n            wasTouching.none = true;\n            wasTouching.up = false;\n            wasTouching.down = false;\n            wasTouching.left = false;\n            wasTouching.right = false;\n        }\n        else {\n            wasTouching.none = touching.none;\n            wasTouching.up = touching.up;\n            wasTouching.down = touching.down;\n            wasTouching.left = touching.left;\n            wasTouching.right = touching.right;\n        }\n        touching.none = true;\n        touching.up = false;\n        touching.down = false;\n        touching.left = false;\n        touching.right = false;\n        blocked.none = true;\n        blocked.up = false;\n        blocked.down = false;\n        blocked.left = false;\n        blocked.right = false;\n        this.overlapR = 0;\n        this.overlapX = 0;\n        this.overlapY = 0;\n        this.embedded = false;\n    }\n    /**\n     * Syncs the position body position with the parent Game Object.\n     *\n     * This method is called every game frame, regardless if the world steps or not.\n     *\n     * @param willStep - Will this Body run an update as well?\n     * @param delta - The delta time, in seconds, elapsed since the last frame.\n     */\n    preUpdate(willStep, delta) {\n        if (willStep)\n            this.resetFlags();\n        // MOD(yandeu): not sure we can to call this here\n        // this.updateFromGameObject()\n        // this.rotation = this.transform.rotation\n        this.preRotation = this.rotation;\n        if (this.moves) {\n            this.prev.x = this.position.x;\n            this.prev.y = this.position.y;\n            this.prevFrame.x = this.position.x;\n            this.prevFrame.y = this.position.y;\n        }\n        if (willStep)\n            this.update(delta);\n    }\n    /**\n     * Performs a single physics step and updates the body velocity, angle, speed and other properties.\n     *\n     * This method can be called multiple times per game frame, depending on the physics step rate.\n     *\n     * The results are synced back to the Game Object in `postUpdate`.\n     *\n     * @param delta - The delta time, in seconds, elapsed since the last frame.\n     */\n    update(delta) {\n        this.prev.x = this.position.x;\n        this.prev.y = this.position.y;\n        if (this.moves) {\n            this.world.updateMotion(this, delta);\n            const vx = this.velocity.x;\n            const vy = this.velocity.y;\n            this.newVelocity.set(vx * delta, vy * delta);\n            this.position.add(this.newVelocity);\n            this.updateCenter();\n            this.angle = Math.atan2(vy, vx);\n            this.speed = Math.sqrt(vx * vx + vy * vy);\n            //  Now the update will throw collision checks at the Body\n            //  And finally we'll integrate the new position back to the Sprite in postUpdate\n            if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {\n                this.world.emit(events_1.default.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);\n            }\n        }\n        this._dx = this.position.x - this.prev.x;\n        this._dy = this.position.y - this.prev.y;\n    }\n    /**\n     * Feeds the Body results back into the parent Game Object.\n     *\n     * This method is called every game frame, regardless if the world steps or not.\n     */\n    postUpdate() {\n        let dx = this.position.x - this.prevFrame.x;\n        let dy = this.position.y - this.prevFrame.y;\n        if (this.moves) {\n            const mx = this.deltaMax.x;\n            const my = this.deltaMax.y;\n            if (mx !== 0 && dx !== 0) {\n                if (dx < 0 && dx < -mx) {\n                    dx = -mx;\n                }\n                else if (dx > 0 && dx > mx) {\n                    dx = mx;\n                }\n            }\n            if (my !== 0 && dy !== 0) {\n                if (dy < 0 && dy < -my) {\n                    dy = -my;\n                }\n                else if (dy > 0 && dy > my) {\n                    dy = my;\n                }\n            }\n            // this.gameObject.x += dx\n            // this.gameObject.y += dy\n        }\n        if (dx < 0) {\n            this.facing = const_1.default.FACING.FACING_LEFT;\n        }\n        else if (dx > 0) {\n            this.facing = const_1.default.FACING.FACING_RIGHT;\n        }\n        if (dy < 0) {\n            this.facing = const_1.default.FACING.FACING_UP;\n        }\n        else if (dy > 0) {\n            this.facing = const_1.default.FACING.FACING_DOWN;\n        }\n        if (this.allowRotation) {\n            // this.gameObject.angle += this.deltaZ()\n        }\n        this._tx = dx;\n        this._ty = dy;\n    }\n    /**\n     * Sets a custom collision boundary rectangle. Use if you want to have a custom\n     * boundary instead of the world boundaries.\n     *\n     * @param bounds - The new boundary rectangle. Pass `null` to use the World bounds.\n     */\n    setBoundsRectangle(bounds) {\n        this.customBoundsRectangle = !bounds ? this.world.bounds : bounds;\n        return this;\n    }\n    /**\n     * Checks for collisions between this Body and the world boundary and separates them.\n     *\n     * Returns true if this Body is colliding with the world boundary.\n     */\n    checkWorldBounds() {\n        const pos = this.position;\n        const bounds = this.customBoundsRectangle;\n        const check = this.world.checkCollision;\n        const bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;\n        const by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;\n        let wasSet = false;\n        if (pos.x < bounds.x && check.left) {\n            pos.x = bounds.x;\n            this.velocity.x *= bx;\n            this.blocked.left = true;\n            wasSet = true;\n        }\n        else if (this.right > bounds.right && check.right) {\n            pos.x = bounds.right - this.width;\n            this.velocity.x *= bx;\n            this.blocked.right = true;\n            wasSet = true;\n        }\n        if (pos.y < bounds.y && check.up) {\n            pos.y = bounds.y;\n            this.velocity.y *= by;\n            this.blocked.up = true;\n            wasSet = true;\n        }\n        else if (this.bottom > bounds.bottom && check.down) {\n            pos.y = bounds.bottom - this.height;\n            this.velocity.y *= by;\n            this.blocked.down = true;\n            wasSet = true;\n        }\n        if (wasSet) {\n            this.blocked.none = false;\n            this.updateCenter();\n        }\n        return wasSet;\n    }\n    /**\n     * Sizes and positions this Body, as a rectangle.\n     *\n     * @param width - The width of the Body in pixels. Cannot be zero.\n     * @param height - The height of the Body in pixels. Cannot be zero.\n     */\n    setSize(width, height) {\n        this.sourceWidth = width;\n        this.sourceHeight = height;\n        this.width = this.sourceWidth * this._sx;\n        this.height = this.sourceHeight * this._sy;\n        this.halfWidth = Math.floor(this.width / 2);\n        this.halfHeight = Math.floor(this.height / 2);\n        this.updateCenter();\n        this.isCircle = false;\n        this.radius = 0;\n        return this;\n    }\n    /**\n     * Sizes and positions this Body, as a circle.\n     *\n     * @param radius - The radius of the Body, in source pixels.\n     */\n    setCircle(radius) {\n        if (radius > 0) {\n            this.isCircle = true;\n            this.radius = radius;\n            this.sourceWidth = radius * 2;\n            this.sourceHeight = radius * 2;\n            this.width = this.sourceWidth * this._sx;\n            this.height = this.sourceHeight * this._sy;\n            this.halfWidth = Math.floor(this.width / 2);\n            this.halfHeight = Math.floor(this.height / 2);\n            this.updateCenter();\n        }\n        else {\n            this.isCircle = false;\n        }\n        return this;\n    }\n    /**\n     * Resets this Body at the new coordinates.\n     * If the Body had any velocity or acceleration it is lost as a result of calling this.\n     *\n     * @param x - The horizontal position to place the Body.\n     * @param y - The vertical position to place the Body.\n     */\n    reset(x, y) {\n        this.stop();\n        this.position.set(x, y);\n        this.prev.copy(this.position);\n        this.prevFrame.copy(this.position);\n        // this.rotation = gameObject.angle\n        // this.preRotation = gameObject.angle\n        this.updateCenter();\n        this.resetFlags(true);\n    }\n    /** Sets acceleration, velocity, and speed to zero. */\n    stop() {\n        this.velocity.set(0);\n        this.acceleration.set(0);\n        this.speed = 0;\n        this.angularVelocity = 0;\n        this.angularAcceleration = 0;\n        return this;\n    }\n    /**\n     * Copies the coordinates of this Body's edges into an object.\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - An object to copy the values into.\n     *\n     * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} - An object with {x, y, right, bottom}.\n     */\n    getBounds(obj) {\n        obj.x = this.x;\n        obj.y = this.y;\n        obj.right = this.right;\n        obj.bottom = this.bottom;\n        return obj;\n    }\n    /**\n     * Tests if the coordinates are within this Body.\n     *\n     * Returns true if (x, y) is within this Body.\n     *\n     * @param x - The horizontal coordinate.\n     * @param y - The vertical coordinate.\n     */\n    hitTest(x, y) {\n        if (!this.isCircle) {\n            return (0, Contains_1.default)(this, x, y);\n        }\n        //  Check if x/y are within the bounds first\n        if (this.radius > 0 && x >= this.left && x <= this.right && y >= this.top && y <= this.bottom) {\n            const dx = (this.center.x - x) * (this.center.x - x);\n            const dy = (this.center.y - y) * (this.center.y - y);\n            return dx + dy <= this.radius * this.radius;\n        }\n        return false;\n    }\n    /**\n     * Whether this Body is touching a tile or the world boundary while moving down.\n     *\n     * Returns true if touching.\n     */\n    onFloor() {\n        return this.blocked.down;\n    }\n    /**\n     * Whether this Body is touching a tile or the world boundary while moving up.\n     *\n     * Returns true if touching.\n     */\n    onCeiling() {\n        return this.blocked.up;\n    }\n    /**\n     * Whether this Body is touching a tile or the world boundary while moving left or right.\n     *\n     * Returns true if touching.\n     */\n    onWall() {\n        return this.blocked.left || this.blocked.right;\n    }\n    /**\n     * The absolute (non-negative) change in this Body's horizontal position from the previous step.\n     *\n     * Returns the delta value.\n     */\n    deltaAbsX() {\n        return this._dx > 0 ? this._dx : -this._dx;\n    }\n    /**\n     * The absolute (non-negative) change in this Body's vertical position from the previous step.\n     *\n     * Returns the delta value.\n     */\n    deltaAbsY() {\n        return this._dy > 0 ? this._dy : -this._dy;\n    }\n    /**\n     * The change in this Body's horizontal position from the previous step.\n     * This value is set during the Body's update phase.\n     *\n     * As a Body can update multiple times per step this may not hold the final\n     * delta value for the Body. In this case, please see the `deltaXFinal` method.\n     *\n     * Returns the delta value.\n     */\n    deltaX() {\n        return this._dx;\n    }\n    /**\n     * The change in this Body's vertical position from the previous step.\n     * This value is set during the Body's update phase.\n     *\n     * As a Body can update multiple times per step this may not hold the final\n     * delta value for the Body. In this case, please see the `deltaYFinal` method.\n     *\n     * Returns the delta value.\n     */\n    deltaY() {\n        return this._dy;\n    }\n    /**\n     * The change in this Body's horizontal position from the previous game update.\n     *\n     * This value is set during the `postUpdate` phase and takes into account the\n     * `deltaMax` and final position of the Body.\n     *\n     * Because this value is not calculated until `postUpdate`, you must listen for it\n     * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will\n     * not be calculated by that point. If you _do_ use these values in `update` they\n     * will represent the delta from the _previous_ game frame.\n     *\n     * Returns the final delta x value.\n     */\n    deltaXFinal() {\n        return this._tx;\n    }\n    /**\n     * The change in this Body's vertical position from the previous game update.\n     *\n     * This value is set during the `postUpdate` phase and takes into account the\n     * `deltaMax` and final position of the Body.\n     *\n     * Because this value is not calculated until `postUpdate`, you must listen for it\n     * during a Scene `POST_UPDATE` or `RENDER` event, and not in `update`, as it will\n     * not be calculated by that point. If you _do_ use these values in `update` they\n     * will represent the delta from the _previous_ game frame.\n     *\n     * Returns the final delta y value.\n     */\n    deltaYFinal() {\n        return this._ty;\n    }\n    /**\n     * The change in this Body's rotation from the previous step, in degrees.\n     *\n     * Returns the delta value.\n     */\n    deltaZ() {\n        return this.rotation - this.preRotation;\n    }\n    /**\n     * Disables this Body and marks it for deletion by the simulation.\n     *\n     * @method Phaser.Physics.Arcade.Body#destroy\n     * @since 3.0.0\n     */\n    destroy() {\n        this.enable = false;\n        if (this.world) {\n            this.world.pendingDestroy.add(this);\n        }\n    }\n    /**\n     * Draws this Body and its velocity, if enabled.\n     *\n     * @method Phaser.Physics.Arcade.Body#drawDebug\n     * @since 3.0.0\n     *\n     * @param {CanvasRenderingContext2D} Context2D - The Context2D to draw on.\n     */\n    drawDebug(ctx) {\n        var _a, _b;\n        const pos = this.position;\n        const x = pos.x + this.halfWidth;\n        const y = pos.y + this.halfHeight;\n        const defaultStrokeWidth = 1;\n        const lineBetween = (x1, y1, x2, y2) => {\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n        };\n        const colorToHex = num => {\n            num >>>= 0;\n            let b = (num & 0xff).toString(16);\n            let g = ((num & 0xff00) >>> 8).toString(16);\n            let r = ((num & 0xff0000) >>> 16).toString(16);\n            if (b === '0')\n                b = '00';\n            if (g === '0')\n                g = '00';\n            if (r === '0')\n                r = '00';\n            return `#${b}${g}${r}`;\n        };\n        const lineStyle = (width, color, unknown) => {\n            ctx.lineWidth = width;\n            ctx.strokeStyle = colorToHex(color);\n        };\n        const strokeCircle = (x, y, radius) => {\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\n        };\n        if (this.debugShowBody) {\n            ctx.beginPath();\n            lineStyle(defaultStrokeWidth, this.debugBodyColor);\n            if (this.isCircle) {\n                strokeCircle(x, y, this.width / 2);\n            }\n            else {\n                //  Only draw the sides where checkCollision is true, similar to debugger in layer\n                if (this.checkCollision.up) {\n                    lineBetween(pos.x, pos.y, pos.x + this.width, pos.y);\n                }\n                if (this.checkCollision.right) {\n                    lineBetween(pos.x + this.width, pos.y, pos.x + this.width, pos.y + this.height);\n                }\n                if (this.checkCollision.down) {\n                    lineBetween(pos.x, pos.y + this.height, pos.x + this.width, pos.y + this.height);\n                }\n                if (this.checkCollision.left) {\n                    lineBetween(pos.x, pos.y, pos.x, pos.y + this.height);\n                }\n            }\n            ctx.stroke();\n        }\n        if (this.debugShowVelocity) {\n            ctx.beginPath();\n            lineStyle(defaultStrokeWidth, ((_b = (_a = this.world) === null || _a === void 0 ? void 0 : _a.defaults) === null || _b === void 0 ? void 0 : _b.velocityDebugColor) || 0x00ff00, 1);\n            lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);\n            ctx.stroke();\n        }\n    }\n    /**\n     * Whether this Body will be drawn to the debug display.\n     *\n     * @method Phaser.Physics.Arcade.Body#willDrawDebug\n     * @since 3.0.0\n     *\n     * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.\n     */\n    willDrawDebug() {\n        return this.debugShowBody || this.debugShowVelocity;\n    }\n    /**\n     * Sets whether this Body collides with the world boundary.\n     *\n     * Optionally also sets the World Bounce and `onWorldBounds` values.\n     *\n     * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\n     * @since 3.0.0\n     *\n     * @param {boolean} [value=true] - `true` if the Body should collide with the world bounds, otherwise `false`.\n     * @param {number} [bounceX] - If given this replaces the Body's `worldBounce.x` value.\n     * @param {number} [bounceY] - If given this replaces the Body's `worldBounce.y` value.\n     * @param {boolean} [onWorldBounds] - If given this replaces the Body's `onWorldBounds` value.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setCollideWorldBounds(value, bounceX, bounceY, onWorldBounds) {\n        if (value === undefined) {\n            value = true;\n        }\n        this.collideWorldBounds = value;\n        const setBounceX = bounceX !== undefined;\n        const setBounceY = bounceY !== undefined;\n        if (setBounceX || setBounceY) {\n            if (!this.worldBounce) {\n                this.worldBounce = new Vector2_1.Vector2();\n            }\n            if (setBounceX) {\n                this.worldBounce.x = bounceX;\n            }\n            if (setBounceY) {\n                this.worldBounce.y = bounceY;\n            }\n        }\n        if (onWorldBounds !== undefined) {\n            this.onWorldBounds = onWorldBounds;\n        }\n        return this;\n    }\n    /**\n     * Sets the Body's velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setVelocity\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal velocity, in pixels per second.\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setVelocity(x, y) {\n        this.velocity.set(x, y);\n        x = this.velocity.x;\n        y = this.velocity.y;\n        this.speed = Math.sqrt(x * x + y * y);\n        return this;\n    }\n    /**\n     * Sets the Body's horizontal velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setVelocityX\n     * @since 3.0.0\n     *\n     * @param {number} value - The velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setVelocityX(value) {\n        this.velocity.x = value;\n        const x = value;\n        const y = this.velocity.y;\n        this.speed = Math.sqrt(x * x + y * y);\n        return this;\n    }\n    /**\n     * Sets the Body's vertical velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setVelocityY\n     * @since 3.0.0\n     *\n     * @param {number} value - The velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setVelocityY(value) {\n        this.velocity.y = value;\n        const x = this.velocity.x;\n        const y = value;\n        this.speed = Math.sqrt(x * x + y * y);\n        return this;\n    }\n    /**\n     * Sets the Body's maximum velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocity\n     * @since 3.10.0\n     *\n     * @param {number} x - The horizontal velocity, in pixels per second.\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setMaxVelocity(x, y) {\n        this.maxVelocity.set(x, y);\n        return this;\n    }\n    /**\n     * Sets the Body's maximum horizontal velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocityX\n     * @since 3.50.0\n     *\n     * @param {number} value - The maximum horizontal velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setMaxVelocityX(value) {\n        this.maxVelocity.x = value;\n        return this;\n    }\n    /**\n     * Sets the Body's maximum vertical velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocityY\n     * @since 3.50.0\n     *\n     * @param {number} value - The maximum vertical velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setMaxVelocityY(value) {\n        this.maxVelocity.y = value;\n        return this;\n    }\n    /**\n     * Sets the maximum speed the Body can move.\n     *\n     * @method Phaser.Physics.Arcade.Body#setMaxSpeed\n     * @since 3.16.0\n     *\n     * @param {number} value - The maximum speed value, in pixels per second. Set to a negative value to disable.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setMaxSpeed(value) {\n        this.maxSpeed = value;\n        return this;\n    }\n    /**\n     * Sets the Body's bounce.\n     *\n     * @method Phaser.Physics.Arcade.Body#setBounce\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal bounce, relative to 1.\n     * @param {number} y - The vertical bounce, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setBounce(x, y) {\n        this.bounce.set(x, y);\n        return this;\n    }\n    /**\n     * Sets the Body's horizontal bounce.\n     *\n     * @method Phaser.Physics.Arcade.Body#setBounceX\n     * @since 3.0.0\n     *\n     * @param {number} value - The bounce, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setBounceX(value) {\n        this.bounce.x = value;\n        return this;\n    }\n    /**\n     * Sets the Body's vertical bounce.\n     *\n     * @method Phaser.Physics.Arcade.Body#setBounceY\n     * @since 3.0.0\n     *\n     * @param {number} value - The bounce, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setBounceY(value) {\n        this.bounce.y = value;\n        return this;\n    }\n    /**\n     * Sets the Body's acceleration.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAcceleration\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal component, in pixels per second squared.\n     * @param {number} y - The vertical component, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAcceleration(x, y) {\n        this.acceleration.set(x, y);\n        return this;\n    }\n    /**\n     * Sets the Body's horizontal acceleration.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAccelerationX\n     * @since 3.0.0\n     *\n     * @param {number} value - The acceleration, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAccelerationX(value) {\n        this.acceleration.x = value;\n        return this;\n    }\n    /**\n     * Sets the Body's vertical acceleration.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAccelerationY\n     * @since 3.0.0\n     *\n     * @param {number} value - The acceleration, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAccelerationY(value) {\n        this.acceleration.y = value;\n        return this;\n    }\n    /**\n     * Enables or disables drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAllowDrag\n     * @since 3.9.0\n     * @see Phaser.Physics.Arcade.Body#allowDrag\n     *\n     * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAllowDrag(value) {\n        if (value === undefined) {\n            value = true;\n        }\n        this.allowDrag = value;\n        return this;\n    }\n    /**\n     * Enables or disables gravity's effect on this Body.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAllowGravity\n     * @since 3.9.0\n     * @see Phaser.Physics.Arcade.Body#allowGravity\n     *\n     * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAllowGravity(value) {\n        if (value === undefined) {\n            value = true;\n        }\n        this.allowGravity = value;\n        return this;\n    }\n    /**\n     * Enables or disables rotation.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAllowRotation\n     * @since 3.9.0\n     * @see Phaser.Physics.Arcade.Body#allowRotation\n     *\n     * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAllowRotation(value) {\n        if (value === undefined) {\n            value = true;\n        }\n        this.allowRotation = value;\n        return this;\n    }\n    /**\n     * Sets the Body's drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setDrag\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal component, in pixels per second squared.\n     * @param {number} y - The vertical component, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setDrag(x, y) {\n        this.drag.set(x, y);\n        return this;\n    }\n    /**\n     * If this Body is using `drag` for deceleration this property controls how the drag is applied.\n     * If set to `true` drag will use a damping effect rather than a linear approach. If you are\n     * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\n     * the game Asteroids) then you will get a far smoother and more visually correct deceleration\n     * by using damping, avoiding the axis-drift that is prone with linear deceleration.\n     *\n     * If you enable this property then you should use far smaller `drag` values than with linear, as\n     * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\n     * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\n     *\n     * @method Phaser.Physics.Arcade.Body#setDamping\n     * @since 3.50.0\n     *\n     * @param {boolean} value - `true` to use damping, or `false` to use drag.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setDamping(value) {\n        this.useDamping = value;\n        return this;\n    }\n    /**\n     * Sets the Body's horizontal drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setDragX\n     * @since 3.0.0\n     *\n     * @param {number} value - The drag, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setDragX(value) {\n        this.drag.x = value;\n        return this;\n    }\n    /**\n     * Sets the Body's vertical drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setDragY\n     * @since 3.0.0\n     *\n     * @param {number} value - The drag, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setDragY(value) {\n        this.drag.y = value;\n        return this;\n    }\n    /**\n     * Sets the Body's gravity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setGravity\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal component, in pixels per second squared.\n     * @param {number} y - The vertical component, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setGravity(x, y) {\n        this.gravity.set(x, y);\n        return this;\n    }\n    /**\n     * Sets the Body's horizontal gravity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setGravityX\n     * @since 3.0.0\n     *\n     * @param {number} value - The gravity, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setGravityX(value) {\n        this.gravity.x = value;\n        return this;\n    }\n    /**\n     * Sets the Body's vertical gravity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setGravityY\n     * @since 3.0.0\n     *\n     * @param {number} value - The gravity, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setGravityY(value) {\n        this.gravity.y = value;\n        return this;\n    }\n    /**\n     * Sets the Body's friction.\n     *\n     * @method Phaser.Physics.Arcade.Body#setFriction\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal component, relative to 1.\n     * @param {number} y - The vertical component, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setFriction(x, y) {\n        this.friction.set(x, y);\n        return this;\n    }\n    /**\n     * Sets the Body's horizontal friction.\n     *\n     * @method Phaser.Physics.Arcade.Body#setFrictionX\n     * @since 3.0.0\n     *\n     * @param {number} value - The friction value, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setFrictionX(value) {\n        this.friction.x = value;\n        return this;\n    }\n    /**\n     * Sets the Body's vertical friction.\n     *\n     * @method Phaser.Physics.Arcade.Body#setFrictionY\n     * @since 3.0.0\n     *\n     * @param {number} value - The friction value, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setFrictionY(value) {\n        this.friction.y = value;\n        return this;\n    }\n    /**\n     * Sets the Body's angular velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAngularVelocity\n     * @since 3.0.0\n     *\n     * @param {number} value - The velocity, in degrees per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAngularVelocity(value) {\n        this.angularVelocity = value;\n        return this;\n    }\n    /**\n     * Sets the Body's angular acceleration.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\n     * @since 3.0.0\n     *\n     * @param {number} value - The acceleration, in degrees per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAngularAcceleration(value) {\n        this.angularAcceleration = value;\n        return this;\n    }\n    /**\n     * Sets the Body's angular drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAngularDrag\n     * @since 3.0.0\n     *\n     * @param {number} value - The drag, in degrees per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAngularDrag(value) {\n        this.angularDrag = value;\n        return this;\n    }\n    /**\n     * Sets the Body's mass.\n     *\n     * @method Phaser.Physics.Arcade.Body#setMass\n     * @since 3.0.0\n     *\n     * @param {number} value - The mass value, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setMass(value) {\n        this.mass = value;\n        return this;\n    }\n    /**\n     * Sets the Body's `immovable` property.\n     *\n     * @method Phaser.Physics.Arcade.Body#setImmovable\n     * @since 3.0.0\n     *\n     * @param {boolean} [value=true] - The value to assign to `immovable`.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setImmovable(value) {\n        if (value === undefined) {\n            value = true;\n        }\n        this.immovable = value;\n        return this;\n    }\n    /**\n     * Sets the Body's `enable` property.\n     *\n     * @method Phaser.Physics.Arcade.Body#setEnable\n     * @since 3.15.0\n     *\n     * @param {boolean} [value=true] - The value to assign to `enable`.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setEnable(value) {\n        if (value === undefined) {\n            value = true;\n        }\n        this.enable = value;\n        return this;\n    }\n    /**\n     * This is an internal handler, called by the `ProcessX` function as part\n     * of the collision step. You should almost never call this directly.\n     *\n     * @method Phaser.Physics.Arcade.Body#processX\n     * @since 3.50.0\n     *\n     * @param {number} x - The amount to add to the Body position.\n     * @param {number} [vx] - The amount to add to the Body velocity.\n     * @param {boolean} [left] - Set the blocked.left value?\n     * @param {boolean} [right] - Set the blocked.right value?\n     */\n    processX(x, vx, left, right) {\n        this.x += x;\n        this.updateCenter();\n        if (vx !== null) {\n            this.velocity.x = vx;\n        }\n        const blocked = this.blocked;\n        if (left) {\n            blocked.left = true;\n        }\n        if (right) {\n            blocked.right = true;\n        }\n    }\n    /**\n     * This is an internal handler, called by the `ProcessY` function as part\n     * of the collision step. You should almost never call this directly.\n     *\n     * @method Phaser.Physics.Arcade.Body#processY\n     * @since 3.50.0\n     *\n     * @param {number} y - The amount to add to the Body position.\n     * @param {number} [vy] - The amount to add to the Body velocity.\n     * @param {boolean} [up] - Set the blocked.up value?\n     * @param {boolean} [down] - Set the blocked.down value?\n     */\n    processY(y, vy, up, down) {\n        this.y += y;\n        this.updateCenter();\n        if (vy !== null) {\n            this.velocity.y = vy;\n        }\n        const blocked = this.blocked;\n        if (up) {\n            blocked.up = true;\n        }\n        if (down) {\n            blocked.down = true;\n        }\n    }\n    /**\n     * The Bodys horizontal position (left edge).\n     *\n     * @name Phaser.Physics.Arcade.Body#x\n     * @type {number}\n     * @since 3.0.0\n     */\n    get x() {\n        return this.position.x;\n    }\n    set x(value) {\n        this.position.x = value;\n    }\n    /**\n     * The Bodys vertical position (top edge).\n     *\n     * @name Phaser.Physics.Arcade.Body#y\n     * @type {number}\n     * @since 3.0.0\n     */\n    get y() {\n        return this.position.y;\n    }\n    set y(value) {\n        this.position.y = value;\n    }\n    /**\n     * The left edge of the Body. Identical to x.\n     *\n     * @name Phaser.Physics.Arcade.Body#left\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    get left() {\n        return this.position.x;\n    }\n    /**\n     * The right edge of the Body.\n     *\n     * @name Phaser.Physics.Arcade.Body#right\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    get right() {\n        return this.position.x + this.width;\n    }\n    /**\n     * The top edge of the Body. Identical to y.\n     *\n     * @name Phaser.Physics.Arcade.Body#top\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    get top() {\n        return this.position.y;\n    }\n    /**\n     * The bottom edge of this Body.\n     *\n     * @name Phaser.Physics.Arcade.Body#bottom\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    get bottom() {\n        return this.position.y + this.height;\n    }\n}\nexports.Body = Body;\n//# sourceMappingURL=Body.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Check to see if the Circle contains the given x / y coordinates.\n *\n * @function Phaser.Geom.Circle.Contains\n * @since 3.0.0\n *\n * @param {Phaser.Geom.Circle} circle - The Circle to check.\n * @param {number} x - The x coordinate to check within the circle.\n * @param {number} y - The y coordinate to check within the circle.\n *\n * @return {boolean} True if the coordinates are within the circle, otherwise false.\n */\nconst Contains = (circle, x, y) => {\n    //  Check if x/y are within the bounds first\n    if (circle.radius > 0 && x >= circle.left && x <= circle.right && y >= circle.top && y <= circle.bottom) {\n        const dx = (circle.x - x) * (circle.x - x);\n        const dy = (circle.y - y) * (circle.y - y);\n        return dx + dy <= circle.radius * circle.radius;\n    }\n    else {\n        return false;\n    }\n};\nexports.default = Contains;\n//# sourceMappingURL=Contains.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StaticBody = void 0;\nconst Contains_1 = __importDefault(require(\"../../geom/circle/Contains\"));\nconst Contains_2 = __importDefault(require(\"../../geom/rectangle/Contains\"));\nconst const_1 = __importDefault(require(\"./const\"));\nconst Vector2_1 = require(\"../../math/Vector2\");\nclass StaticBody {\n    /**\n     * A Static Arcade Physics Body.\n     *\n     * A Static Body never moves, and isn't automatically synchronized with its parent Game Object.\n     * That means if you make any change to the parent's origin, position, or scale after creating or adding the body, you'll need to update the Static Body manually.\n     *\n     * A Static Body can collide with other Bodies, but is never moved by collisions.\n     *\n     * Its dynamic counterpart is {@link Body}.\n     *\n     * @param world The Arcade Physics simulation this Static Body belongs to.\n     * @param x\n     * @param y\n     * @param width\n     * @param height\n     */\n    constructor(world, x, y, width = 64, height = 64) {\n        this.world = world;\n        /** Whether this Static Body is updated by the physics simulation. */\n        this.enable = true;\n        /** Whether this Static Body's boundary is circular (`true`) or rectangular (`false`). */\n        this.isCircle = false;\n        /**\n         * If this Static Body is circular, this is the radius of the boundary, as set by {@link setCircle} in pixels.\n         * Equal to `halfWidth`.\n         */\n        this.radius = 0;\n        /**\n         * The offset set by {@link setCircle} or {@link setSize}.\n         *\n         * This doesn't affect the Static Body's position, because a Static Body does not follow its Game Object.\n         */\n        this.offset = new Vector2_1.Vector2();\n        this._dx = 0;\n        this._dy = 0;\n        this.isBody = true;\n        /** Whether the Static Body's boundary is drawn to the debug display. */\n        this.debugShowBody = world.defaults.debugShowStaticBody;\n        /** The color of this Static Body on the debug display. */\n        this.debugBodyColor = world.defaults.staticBodyDebugColor;\n        /**\n         * The position of this Static Body within the simulation.\n         * @type {Phaser.Math.Vector2}\n         */\n        this.position = new Vector2_1.Vector2(x, y);\n        /**\n         * The width of the Static Body's boundary, in pixels.\n         * If the Static Body is circular, this is also the Static Body's diameter.\n         *\n         * @type {number}\n         */\n        this.width = width;\n        /**\n         * The height of the Static Body's boundary, in pixels.\n         * If the Static Body is circular, this is also the Static Body's diameter.\n         *\n         * @type {number}\n         */\n        this.height = height;\n        /**\n         * Half the Static Body's width, in pixels.\n         * If the Static Body is circular, this is also the Static Body's radius.\n         *\n         * @type {number}\n         */\n        this.halfWidth = Math.abs(this.width / 2);\n        /**\n         * Half the Static Body's height, in pixels.\n         * If the Static Body is circular, this is also the Static Body's radius.\n         *\n         * @type {number}\n         */\n        this.halfHeight = Math.abs(this.height / 2);\n        /**\n         * The center of the Static Body's boundary.\n         * This is the midpoint of its `position` (top-left corner) and its bottom-right corner.\n         *\n         * @type {Phaser.Math.Vector2}\n         */\n        this.center = new Vector2_1.Vector2(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n        /**\n         * A constant zero velocity used by the Arcade Physics simulation for calculations.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#velocity\n         * @type {Phaser.Math.Vector2}\n         * @readonly\n         * @since 3.0.0\n         */\n        this.velocity = Vector2_1.Vector2.ZERO;\n        /**\n         * A constant `false` value expected by the Arcade Physics simulation.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#allowGravity\n         * @type {boolean}\n         * @readonly\n         * @default false\n         * @since 3.0.0\n         */\n        this.allowGravity = false;\n        /**\n         * Gravitational force applied specifically to this Body. Values are in pixels per second squared. Always zero for a Static Body.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#gravity\n         * @type {Phaser.Math.Vector2}\n         * @readonly\n         * @since 3.0.0\n         */\n        this.gravity = Vector2_1.Vector2.ZERO;\n        /**\n         * Rebound, or restitution, following a collision, relative to 1. Always zero for a Static Body.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#bounce\n         * @type {Phaser.Math.Vector2}\n         * @readonly\n         * @since 3.0.0\n         */\n        this.bounce = Vector2_1.Vector2.ZERO;\n        //  If true this Body will dispatch events\n        /**\n         * Whether the simulation emits a `worldbounds` event when this StaticBody collides with the world boundary.\n         * Always false for a Static Body. (Static Bodies never collide with the world boundary and never trigger a `worldbounds` event.)\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#onWorldBounds\n         * @type {boolean}\n         * @readonly\n         * @default false\n         * @since 3.0.0\n         */\n        this.onWorldBounds = false;\n        /**\n         * Whether the simulation emits a `collide` event when this StaticBody collides with another.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#onCollide\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.onCollide = false;\n        /**\n         * Whether the simulation emits an `overlap` event when this StaticBody overlaps with another.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#onOverlap\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.onOverlap = false;\n        /**\n         * The StaticBody's inertia, relative to a default unit (1). With `bounce`, this affects the exchange of momentum (velocities) during collisions.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#mass\n         * @type {number}\n         * @default 1\n         * @since 3.0.0\n         */\n        this.mass = 1;\n        /**\n         * Whether this object can be moved by collisions with another body.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#immovable\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.immovable = true;\n        /**\n         * Sets if this Body can be pushed by another Body.\n         *\n         * A body that cannot be pushed will reflect back all of the velocity it is given to the\n         * colliding body. If that body is also not pushable, then the separation will be split\n         * between them evenly.\n         *\n         * If you want your body to never move or seperate at all, see the `setImmovable` method.\n         *\n         * By default, Static Bodies are not pushable.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#pushable\n         * @type {boolean}\n         * @default false\n         * @since 3.50.0\n         * @see Phaser.GameObjects.Components.Pushable#setPushable\n         */\n        this.pushable = false;\n        /**\n         * A flag disabling the default horizontal separation of colliding bodies. Pass your own `collideHandler` to the collider.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#customSeparateX\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.customSeparateX = false;\n        /**\n         * A flag disabling the default vertical separation of colliding bodies. Pass your own `collideHandler` to the collider.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#customSeparateY\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.customSeparateY = false;\n        /**\n         * The amount of horizontal overlap (before separation), if this Body is colliding with another.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#overlapX\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.overlapX = 0;\n        /**\n         * The amount of vertical overlap (before separation), if this Body is colliding with another.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#overlapY\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.overlapY = 0;\n        /**\n         * The amount of overlap (before separation), if this StaticBody is circular and colliding with another circular body.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#overlapR\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.overlapR = 0;\n        /**\n         * Whether this StaticBody has ever overlapped with another while both were not moving.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#embedded\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.embedded = false;\n        /**\n         * Whether this StaticBody interacts with the world boundary.\n         * Always false for a Static Body. (Static Bodies never collide with the world boundary.)\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#collideWorldBounds\n         * @type {boolean}\n         * @readonly\n         * @default false\n         * @since 3.0.0\n         */\n        this.collideWorldBounds = false;\n        /** Whether this StaticBody is checked for collisions and for which directions. You can set `checkCollision.none = false` to disable collision checks. */\n        this.checkCollision = {\n            none: false,\n            up: true,\n            down: true,\n            left: true,\n            right: true\n        };\n        /**\n         * This property is kept for compatibility with Dynamic Bodies.\n         * Avoid using it.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#touching\n         * @type {Phaser.Types.Physics.Arcade.CollisionCallback}\n         * @since 3.0.0\n         */\n        this.touching = {\n            none: true,\n            up: false,\n            down: false,\n            left: false,\n            right: false\n        };\n        /**\n         * This property is kept for compatibility with Dynamic Bodies.\n         * Avoid using it.\n         * The values are always false for a Static Body.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#wasTouching\n         * @type {Phaser.Types.Physics.Arcade.CollisionCallback}\n         * @since 3.0.0\n         */\n        this.wasTouching = {\n            none: true,\n            up: false,\n            down: false,\n            left: false,\n            right: false\n        };\n        /**\n         * This property is kept for compatibility with Dynamic Bodies.\n         * Avoid using it.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#blocked\n         * @type {Phaser.Types.Physics.Arcade.CollisionCallback}\n         * @since 3.0.0\n         */\n        this.blocked = {\n            none: true,\n            up: false,\n            down: false,\n            left: false,\n            right: false\n        };\n        /**\n         * The StaticBody's physics type (static by default).\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#physicsType\n         * @type {number}\n         * @default Phaser.Physics.Arcade.STATIC_BODY\n         * @since 3.0.0\n         */\n        this.physicsType = const_1.default.PHYSICS_TYPE.STATIC_BODY;\n        /**\n         * The calculated change in the Static Body's horizontal position during the current step.\n         * For a static body this is always zero.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#_dx\n         * @type {number}\n         * @private\n         * @default 0\n         * @since 3.10.0\n         */\n        this._dx = 0;\n        /**\n         * The calculated change in the Static Body's vertical position during the current step.\n         * For a static body this is always zero.\n         *\n         * @name Phaser.Physics.Arcade.StaticBody#_dy\n         * @type {number}\n         * @private\n         * @default 0\n         * @since 3.10.0\n         */\n        this._dy = 0;\n    }\n    // used for the btree\n    get minX() {\n        return this.x;\n    }\n    get minY() {\n        return this.y;\n    }\n    get maxX() {\n        return this.x + this.width;\n    }\n    get maxY() {\n        return this.y + this.height;\n    }\n    // /**\n    //  * Changes the Game Object this Body is bound to.\n    //  * First it removes its reference from the old Game Object, then sets the new one.\n    //  * You can optionally update the position and dimensions of this Body to reflect that of the new Game Object.\n    //  *\n    //  * @method Phaser.Physics.Arcade.StaticBody#setGameObject\n    //  * @since 3.1.0\n    //  *\n    //  * @param {Phaser.GameObjects.GameObject} gameObject - The new Game Object that will own this Body.\n    //  * @param {boolean} [update=true] - Reposition and resize this Body to match the new Game Object?\n    //  *\n    //  * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\n    //  *\n    //  * @see Phaser.Physics.Arcade.StaticBody#updateFromGameObject\n    //  */\n    // setGameObject(gameObject, update) {\n    //   if (gameObject && gameObject !== this.gameObject) {\n    //     //  Remove this body from the old game object\n    //     // @ts-ignore\n    //     this.gameObject.body = null\n    //     gameObject.body = this\n    //     //  Update our reference\n    //     this.gameObject = gameObject\n    //   }\n    //   if (update) {\n    //     this.updateFromGameObject()\n    //   }\n    //   return this\n    // }\n    preUpdate() {\n        // nothing to pre-update on a static body.\n    }\n    update() {\n        // nothing to update on a static body.\n    }\n    /**\n     * Sets the size of the Static Body.\n     * Resets the width and height to match current frame, if no width and height provided and a frame is found.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#setSize\n     * @since 3.0.0\n     *\n     * @param {number} [width] - The width of the Static Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\n     * @param {number} [height] - The height of the Static Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\n     *\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\n     */\n    setSize(width, height) {\n        this.world.staticTree.remove(this);\n        this.width = width;\n        this.height = height;\n        this.halfWidth = Math.floor(width / 2);\n        this.halfHeight = Math.floor(height / 2);\n        this.updateCenter();\n        this.isCircle = false;\n        this.radius = 0;\n        this.world.staticTree.insert(this);\n        return this;\n    }\n    /**\n     * Sets this Static Body to have a circular body and sets its size and position.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#setCircle\n     * @since 3.0.0\n     *\n     * @param {number} radius - The radius of the StaticBody, in pixels.\n     * @param {number} [offsetX] - The horizontal offset of the StaticBody from its Game Object, in pixels.\n     * @param {number} [offsetY] - The vertical offset of the StaticBody from its Game Object, in pixels.\n     *\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\n     */\n    setCircle(radius, offsetX, offsetY) {\n        if (offsetX === undefined) {\n            offsetX = this.offset.x;\n        }\n        if (offsetY === undefined) {\n            offsetY = this.offset.y;\n        }\n        if (radius > 0) {\n            this.world.staticTree.remove(this);\n            this.isCircle = true;\n            this.radius = radius;\n            this.width = radius * 2;\n            this.height = radius * 2;\n            this.halfWidth = Math.floor(this.width / 2);\n            this.halfHeight = Math.floor(this.height / 2);\n            this.offset.set(offsetX, offsetY);\n            this.updateCenter();\n            this.world.staticTree.insert(this);\n        }\n        else {\n            this.isCircle = false;\n        }\n        return this;\n    }\n    /**\n     * Updates the StaticBody's `center` from its `position` and dimensions.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#updateCenter\n     * @since 3.0.0\n     */\n    updateCenter() {\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n    }\n    /**\n     * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#reset\n     * @since 3.0.0\n     *\n     * @param {number} [x] - The x coordinate to reset the body to.\n     * @param {number} [y] - The y coordinate to reset the body to.\n     */\n    reset(x, y) {\n        this.world.staticTree.remove(this);\n        this.position.set(x, y);\n        this.updateCenter();\n        this.world.staticTree.insert(this);\n    }\n    /**\n     * NOOP function. A Static Body cannot be stopped.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#stop\n     * @since 3.0.0\n     *\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\n     */\n    stop() {\n        return this;\n    }\n    /**\n     * Returns the x and y coordinates of the top left and bottom right points of the StaticBody.\n     *\n     * @param {ArcadeBodyBounds} obj - The object which will hold the coordinates of the bounds.\n     * @return {ArcadeBodyBounds} The same object that was passed with `x`, `y`, `right` and `bottom` values matching the respective values of the StaticBody.\n     */\n    getBounds(obj) {\n        obj.x = this.x;\n        obj.y = this.y;\n        obj.right = this.right;\n        obj.bottom = this.bottom;\n        return obj;\n    }\n    /**\n     * Checks to see if a given x,y coordinate is colliding with this Static Body.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#hitTest\n     * @since 3.0.0\n     *\n     * @param {number} x - The x coordinate to check against this body.\n     * @param {number} y - The y coordinate to check against this body.\n     *\n     * @return {boolean} `true` if the given coordinate lies within this body, otherwise `false`.\n     */\n    hitTest(x, y) {\n        return this.isCircle ? (0, Contains_1.default)(this, x, y) : (0, Contains_2.default)(this, x, y);\n    }\n    /**\n     * NOOP\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#postUpdate\n     * @since 3.12.0\n     */\n    postUpdate() { }\n    /**\n     * The absolute (non-negative) change in this StaticBody's horizontal position from the previous step. Always zero.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsX\n     * @since 3.0.0\n     *\n     * @return {number} Always zero for a Static Body.\n     */\n    deltaAbsX() {\n        return 0;\n    }\n    /**\n     * The absolute (non-negative) change in this StaticBody's vertical position from the previous step. Always zero.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#deltaAbsY\n     * @since 3.0.0\n     *\n     * @return {number} Always zero for a Static Body.\n     */\n    deltaAbsY() {\n        return 0;\n    }\n    /**\n     * The change in this StaticBody's horizontal position from the previous step. Always zero.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#deltaX\n     * @since 3.0.0\n     *\n     * @return {number} The change in this StaticBody's velocity from the previous step. Always zero.\n     */\n    deltaX() {\n        return 0;\n    }\n    /**\n     * The change in this StaticBody's vertical position from the previous step. Always zero.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#deltaY\n     * @since 3.0.0\n     *\n     * @return {number} The change in this StaticBody's velocity from the previous step. Always zero.\n     */\n    deltaY() {\n        return 0;\n    }\n    /**\n     * The change in this StaticBody's rotation from the previous step. Always zero.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#deltaZ\n     * @since 3.0.0\n     *\n     * @return {number} The change in this StaticBody's rotation from the previous step. Always zero.\n     */\n    deltaZ() {\n        return 0;\n    }\n    /**\n     * Disables this Body and marks it for destruction during the next step.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#destroy\n     * @since 3.0.0\n     */\n    destroy() {\n        this.enable = false;\n        this.world.pendingDestroy.add(this);\n    }\n    /**\n     * Draws a graphical representation of the StaticBody for visual debugging purposes.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#drawDebug\n     * @since 3.0.0\n     *\n     * @param {CanvasRenderingContext2D} Context2D - The Context2D to use for the debug drawing of the StaticBody.\n     */\n    drawDebug(ctx) {\n        const pos = this.position;\n        const x = pos.x + this.halfWidth;\n        const y = pos.y + this.halfHeight;\n        const defaultStrokeWidth = 1;\n        const colorToHex = num => {\n            num >>>= 0;\n            let b = (num & 0xff).toString(16);\n            let g = ((num & 0xff00) >>> 8).toString(16);\n            let r = ((num & 0xff0000) >>> 16).toString(16);\n            if (b === '0')\n                b = '00';\n            if (g === '0')\n                g = '00';\n            if (r === '0')\n                r = '00';\n            return `#${b}${g}${r}`;\n        };\n        const strokeRect = (x, y, w, h) => {\n            ctx.rect(x, y, w, h);\n        };\n        const lineStyle = (width, color, unknown) => {\n            ctx.lineWidth = width;\n            ctx.strokeStyle = colorToHex(color);\n        };\n        const strokeCircle = (x, y, radius) => {\n            ctx.arc(x, y, radius, 0, 2 * Math.PI);\n        };\n        if (this.debugShowBody) {\n            ctx.beginPath();\n            lineStyle(defaultStrokeWidth, this.debugBodyColor || 0x0000ff, 1);\n            if (this.isCircle) {\n                strokeCircle(x, y, this.width / 2);\n            }\n            else {\n                strokeRect(pos.x, pos.y, this.width, this.height);\n            }\n            ctx.stroke();\n        }\n    }\n    /**\n     * Indicates whether the StaticBody is going to be showing a debug visualization during postUpdate.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#willDrawDebug\n     * @since 3.0.0\n     *\n     * @return {boolean} Whether or not the StaticBody is going to show the debug visualization during postUpdate.\n     */\n    willDrawDebug() {\n        return this.debugShowBody;\n    }\n    /**\n     * Sets the Mass of the StaticBody. Will set the Mass to 0.1 if the value passed is less than or equal to zero.\n     *\n     * @method Phaser.Physics.Arcade.StaticBody#setMass\n     * @since 3.0.0\n     *\n     * @param {number} value - The value to set the Mass to. Values of zero or less are changed to 0.1.\n     *\n     * @return {Phaser.Physics.Arcade.StaticBody} This Static Body object.\n     */\n    setMass(value) {\n        if (value <= 0) {\n            //  Causes havoc otherwise\n            value = 0.1;\n        }\n        this.mass = value;\n        return this;\n    }\n    /**\n     * The x coordinate of the StaticBody.\n     *\n     * @name Phaser.Physics.Arcade.StaticBody#x\n     * @type {number}\n     * @since 3.0.0\n     */\n    get x() {\n        return this.position.x;\n    }\n    set x(value) {\n        this.world.staticTree.remove(this);\n        this.position.x = value;\n        this.world.staticTree.insert(this);\n    }\n    /**\n     * The y coordinate of the StaticBody.\n     *\n     * @name Phaser.Physics.Arcade.StaticBody#y\n     * @type {number}\n     * @since 3.0.0\n     */\n    get y() {\n        return this.position.y;\n    }\n    set y(value) {\n        this.world.staticTree.remove(this);\n        this.position.y = value;\n        this.world.staticTree.insert(this);\n    }\n    /**\n     * Returns the left-most x coordinate of the area of the StaticBody.\n     *\n     * @name Phaser.Physics.Arcade.StaticBody#left\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    get left() {\n        return this.position.x;\n    }\n    /**\n     * The right-most x coordinate of the area of the StaticBody.\n     *\n     * @name Phaser.Physics.Arcade.StaticBody#right\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    get right() {\n        return this.position.x + this.width;\n    }\n    /**\n     * The highest y coordinate of the area of the StaticBody.\n     *\n     * @name Phaser.Physics.Arcade.StaticBody#top\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    get top() {\n        return this.position.y;\n    }\n    /**\n     * The lowest y coordinate of the area of the StaticBody. (y + height)\n     *\n     * @name Phaser.Physics.Arcade.StaticBody#bottom\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    get bottom() {\n        return this.position.y + this.height;\n    }\n}\nexports.StaticBody = StaticBody;\n//# sourceMappingURL=StaticBody.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Factory = void 0;\nconst Body_1 = require(\"./Body\");\nconst StaticBody_1 = require(\"./StaticBody\");\nclass Factory {\n    /**\n     * The Arcade Physics Factory allows you to easily create Arcade Physics enabled Game Objects.\n     * Objects that are created by this Factory are automatically added to the physics world.\n     *\n     * @param world The Arcade Physics World instance.\n     */\n    constructor(world) {\n        this.world = world;\n        /** A reference to the Scene this Arcade Physics instance belongs to. */\n        this.scene = world.scene;\n        /** A reference to the Scene.Systems this Arcade Physics instance belongs to.  */\n        this.sys = world.scene.sys;\n    }\n    /** Creates a new Dynamic Arcade Body. */\n    body(x, y, width = 64, height = 64) {\n        const body = new Body_1.Body(this.world, x, y, width, height);\n        this.world.add(body);\n        return body;\n    }\n    /** Creates a new Static Arcade Physics Body. */\n    staticBody(x, y, width = 64, height = 64) {\n        const staticBody = new StaticBody_1.StaticBody(this.world, x, y, width, height);\n        this.world.add(staticBody);\n        return staticBody;\n    }\n    /**\n     * Creates a new Arcade Physics Collider object.\n     *\n     * @param body1 - The first object to check for collision.\n     * @param body2 - The second object to check for collision.\n     * @param [collideCallback] - The callback to invoke when the two objects collide.\n     * @param [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\n     * @param [callbackContext] - The scope in which to call the callbacks.\n     *\n     * @return The Collider that was created.\n     */\n    collider(body1, body2, collideCallback, processCallback, callbackContext) {\n        return this.world.addCollider(body1, body2, collideCallback, processCallback, callbackContext);\n    }\n    /**\n     * Creates a new Arcade Physics Collider Overlap object.\n     *\n     * @param body1 - The first object to check for overlap.\n     * @param body2 - The second object to check for overlap.\n     * @param [collideCallback] - The callback to invoke when the two objects collide.\n     * @param [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\n     * @param [callbackContext] - The scope in which to call the callbacks.\n     *\n     * @return The Collider that was created.\n     */\n    overlap(body1, body2, collideCallback, processCallback, callbackContext) {\n        return this.world.addOverlap(body1, body2, collideCallback, processCallback, callbackContext);\n    }\n    /** Destroys this Factory. */\n    destroy() {\n        // @ts-ignore\n        this.world = null;\n        // @ts-ignore\n        this.scene = null;\n        // @ts-ignore\n        this.sys = null;\n    }\n}\nexports.Factory = Factory;\n//# sourceMappingURL=Factory.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * This method will search the given rectangular area and return an array of all physics bodies that\n * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\n *\n * A body only has to intersect with the search area to be considered, it doesn't have to be fully\n * contained within it.\n *\n * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\n * otherwise the search is O(N) for Dynamic Bodies.\n *\n * @function Phaser.Physics.Arcade.Components.OverlapRect\n * @since 3.17.0\n *\n * @param {number} x - The top-left x coordinate of the area to search within.\n * @param {number} y - The top-left y coordinate of the area to search within.\n * @param {number} width - The width of the area to search within.\n * @param {number} height - The height of the area to search within.\n * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\n * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\n *\n * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\n */\nconst OverlapRect = function (world, x, y, width, height, includeDynamic = true, includeStatic = false) {\n    let dynamicBodies = [];\n    let staticBodies = [];\n    const minMax = world.treeMinMax;\n    minMax.minX = x;\n    minMax.minY = y;\n    minMax.maxX = x + width;\n    minMax.maxY = y + height;\n    if (includeStatic) {\n        staticBodies = world.staticTree.search(minMax);\n    }\n    if (includeDynamic && world.useTree) {\n        dynamicBodies = world.tree.search(minMax);\n    }\n    //\n    else if (includeDynamic) {\n        const bodies = world.bodies;\n        const fakeBody = {\n            position: {\n                x: x,\n                y: y\n            },\n            left: x,\n            top: y,\n            right: x + width,\n            bottom: y + height,\n            isCircle: false\n        };\n        bodies.forEach(target => {\n            if (world.intersects(target, fakeBody)) {\n                dynamicBodies.push(target);\n            }\n        });\n    }\n    return [...staticBodies, ...dynamicBodies];\n};\nexports.default = OverlapRect;\n//# sourceMappingURL=OverlapRect.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Point_1 = __importDefault(require(\"../point/Point\"));\n/**\n * Returns a Point object containing the coordinates of a point on the circumference of the Circle based on the given angle.\n *\n * @function Phaser.Geom.Circle.CircumferencePoint\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point} O - [out,$return]\n *\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference point on.\n * @param {number} angle - The angle from the center of the Circle to the circumference to return the point from. Given in radians.\n * @param {(Phaser.Geom.Point|object)} [out] - A Point, or point-like object, to store the results in. If not given a Point will be created.\n *\n * @return {(Phaser.Geom.Point|object)} A Point object where the `x` and `y` properties are the point on the circumference.\n */\nconst CircumferencePoint = (circle, angle, out) => {\n    if (out === undefined) {\n        out = new Point_1.default();\n    }\n    out.x = circle.x + circle.radius * Math.cos(angle);\n    out.y = circle.y + circle.radius * Math.sin(angle);\n    return out;\n};\nexports.default = CircumferencePoint;\n//# sourceMappingURL=CircumferencePoint.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Force a value within the boundaries by clamping it to the range `min`, `max`.\n *\n * @function Phaser.Math.Clamp\n * @since 3.0.0\n *\n * @param {number} value - The value to be clamped.\n * @param {number} min - The minimum bounds.\n * @param {number} max - The maximum bounds.\n *\n * @return {number} The clamped value.\n */\nconst Clamp = (value, min, max) => {\n    return Math.max(min, Math.min(max, value));\n};\nexports.default = Clamp;\n//# sourceMappingURL=Clamp.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Clamp_1 = __importDefault(require(\"./Clamp\"));\n/**\n * Return a value based on the range between `min` and `max` and the percentage given.\n *\n * @function Phaser.Math.FromPercent\n * @since 3.0.0\n *\n * @param {number} percent - A value between 0 and 1 representing the percentage.\n * @param {number} min - The minimum value.\n * @param {number} [max] - The maximum value.\n *\n * @return {number} The value that is `percent` percent between `min` and `max`.\n */\nconst FromPercent = (percent, min, max) => {\n    percent = (0, Clamp_1.default)(percent, 0, 1);\n    return (max - min) * percent + min;\n};\nexports.default = FromPercent;\n//# sourceMappingURL=FromPercent.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CircumferencePoint_1 = __importDefault(require(\"./CircumferencePoint\"));\nconst FromPercent_1 = __importDefault(require(\"../../math/FromPercent\"));\nconst const_1 = __importDefault(require(\"../../math/const\"));\nconst Point_1 = __importDefault(require(\"../point/Point\"));\n/**\n * Returns a Point object containing the coordinates of a point on the circumference of the Circle\n * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\n * at 180 degrees around the circle.\n *\n * @function Phaser.Geom.Circle.GetPoint\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point} O - [out,$return]\n *\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference point on.\n * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.\n * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\n *\n * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the circle.\n */\nconst GetPoint = (circle, position, out) => {\n    if (out === undefined) {\n        out = new Point_1.default();\n    }\n    const angle = (0, FromPercent_1.default)(position, 0, const_1.default.PI2);\n    return (0, CircumferencePoint_1.default)(circle, angle, out);\n};\nexports.default = GetPoint;\n//# sourceMappingURL=GetPoint.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns the circumference of the given Circle.\n *\n * @function Phaser.Geom.Circle.Circumference\n * @since 3.0.0\n *\n * @param {Phaser.Geom.Circle} circle - The Circle to get the circumference of.\n *\n * @return {number} The circumference of the Circle.\n */\nconst Circumference = circle => {\n    return 2 * (Math.PI * circle.radius);\n};\nexports.default = Circumference;\n//# sourceMappingURL=Circumference.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Circumference_1 = __importDefault(require(\"./Circumference\"));\nconst CircumferencePoint_1 = __importDefault(require(\"./CircumferencePoint\"));\nconst FromPercent_1 = __importDefault(require(\"../../math/FromPercent\"));\nconst const_1 = __importDefault(require(\"../../math/const\"));\n/**\n * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,\n * based on the given quantity or stepRate values.\n *\n * @function Phaser.Geom.Circle.GetPoints\n * @since 3.0.0\n *\n * @param {Phaser.Geom.Circle} circle - The Circle to get the points from.\n * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\n * @param {number} [stepRate] - Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.\n * @param {array} [output] - An array to insert the points in to. If not provided a new array will be created.\n *\n * @return {Phaser.Geom.Point[]} An array of Point objects pertaining to the points around the circumference of the circle.\n */\nconst GetPoints = (circle, quantity, stepRate, out) => {\n    if (out === undefined) {\n        out = [];\n    }\n    //  If quantity is a falsey value (false, null, 0, undefined, etc) then we calculate it based on the stepRate instead.\n    if (!quantity && stepRate > 0) {\n        quantity = (0, Circumference_1.default)(circle) / stepRate;\n    }\n    for (let i = 0; i < quantity; i++) {\n        const angle = (0, FromPercent_1.default)(i / quantity, 0, const_1.default.PI2);\n        out.push((0, CircumferencePoint_1.default)(circle, angle));\n    }\n    return out;\n};\nexports.default = GetPoints;\n//# sourceMappingURL=GetPoints.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Point_1 = __importDefault(require(\"../point/Point\"));\n/**\n * Returns a uniformly distributed random point from anywhere within the given Circle.\n *\n * @function Phaser.Geom.Circle.Random\n * @since 3.0.0\n *\n * @generic {Phaser.Geom.Point} O - [out,$return]\n *\n * @param {Phaser.Geom.Circle} circle - The Circle to get a random point from.\n * @param {(Phaser.Geom.Point|object)} [out] - A Point or point-like object to set the random `x` and `y` values in.\n *\n * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\n */\nconst Random = (circle, out) => {\n    if (out === undefined) {\n        out = new Point_1.default();\n    }\n    const t = 2 * Math.PI * Math.random();\n    const u = Math.random() + Math.random();\n    const r = u > 1 ? 2 - u : u;\n    const x = r * Math.cos(t);\n    const y = r * Math.sin(t);\n    out.x = circle.x + x * circle.radius;\n    out.y = circle.y + y * circle.radius;\n    return out;\n};\nexports.default = Random;\n//# sourceMappingURL=Random.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Circle = void 0;\nconst Class_1 = __importDefault(require(\"../../utils/Class\"));\nconst Contains_1 = __importDefault(require(\"./Contains\"));\nconst GetPoint_1 = __importDefault(require(\"./GetPoint\"));\nconst GetPoints_1 = __importDefault(require(\"./GetPoints\"));\nconst const_1 = __importDefault(require(\"../const\"));\nconst Random_1 = __importDefault(require(\"./Random\"));\n/**\n * @classdesc\n * A Circle object.\n *\n * This is a geometry object, containing numerical values and related methods to inspect and modify them.\n * It is not a Game Object, in that you cannot add it to the display list, and it has no texture.\n * To render a Circle you should look at the capabilities of the Graphics class.\n *\n * @class Circle\n * @memberof Phaser.Geom\n * @constructor\n * @since 3.0.0\n *\n * @param {number} [x=0] - The x position of the center of the circle.\n * @param {number} [y=0] - The y position of the center of the circle.\n * @param {number} [radius=0] - The radius of the circle.\n */\nclass Circle {\n    constructor(x, y, radius) {\n        if (x === undefined) {\n            x = 0;\n        }\n        if (y === undefined) {\n            y = 0;\n        }\n        if (radius === undefined) {\n            radius = 0;\n        }\n        /**\n         * The geometry constant type of this object: `GEOM_CONST.CIRCLE`.\n         * Used for fast type comparisons.\n         *\n         * @name Phaser.Geom.Circle#type\n         * @type {number}\n         * @readonly\n         * @since 3.19.0\n         */\n        this.type = const_1.default.CIRCLE;\n        /**\n         * The x position of the center of the circle.\n         *\n         * @name Phaser.Geom.Circle#x\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.x = x;\n        /**\n         * The y position of the center of the circle.\n         *\n         * @name Phaser.Geom.Circle#y\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.y = y;\n        /**\n         * The internal radius of the circle.\n         *\n         * @name Phaser.Geom.Circle#_radius\n         * @type {number}\n         * @private\n         * @since 3.0.0\n         */\n        this._radius = radius;\n        /**\n         * The internal diameter of the circle.\n         *\n         * @name Phaser.Geom.Circle#_diameter\n         * @type {number}\n         * @private\n         * @since 3.0.0\n         */\n        this._diameter = radius * 2;\n    }\n    /**\n     * Check to see if the Circle contains the given x / y coordinates.\n     *\n     * @method Phaser.Geom.Circle#contains\n     * @since 3.0.0\n     *\n     * @param {number} x - The x coordinate to check within the circle.\n     * @param {number} y - The y coordinate to check within the circle.\n     *\n     * @return {boolean} True if the coordinates are within the circle, otherwise false.\n     */\n    contains(x, y) {\n        return (0, Contains_1.default)(this, x, y);\n    }\n    /**\n     * Returns a Point object containing the coordinates of a point on the circumference of the Circle\n     * based on the given angle normalized to the range 0 to 1. I.e. a value of 0.5 will give the point\n     * at 180 degrees around the circle.\n     *\n     * @method Phaser.Geom.Circle#getPoint\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point} O - [out,$return]\n     *\n     * @param {number} position - A value between 0 and 1, where 0 equals 0 degrees, 0.5 equals 180 degrees and 1 equals 360 around the circle.\n     * @param {(Phaser.Geom.Point|object)} [out] - An object to store the return values in. If not given a Point object will be created.\n     *\n     * @return {(Phaser.Geom.Point|object)} A Point, or point-like object, containing the coordinates of the point around the circle.\n     */\n    getPoint(position, point) {\n        return (0, GetPoint_1.default)(this, position, point);\n    }\n    /**\n     * Returns an array of Point objects containing the coordinates of the points around the circumference of the Circle,\n     * based on the given quantity or stepRate values.\n     *\n     * @method Phaser.Geom.Circle#getPoints\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point[]} O - [output,$return]\n     *\n     * @param {number} quantity - The amount of points to return. If a falsey value the quantity will be derived from the `stepRate` instead.\n     * @param {number} [stepRate] - Sets the quantity by getting the circumference of the circle and dividing it by the stepRate.\n     * @param {(array|Phaser.Geom.Point[])} [output] - An array to insert the points in to. If not provided a new array will be created.\n     *\n     * @return {(array|Phaser.Geom.Point[])} An array of Point objects pertaining to the points around the circumference of the circle.\n     */\n    getPoints(quantity, stepRate, output) {\n        return (0, GetPoints_1.default)(this, quantity, stepRate, output);\n    }\n    /**\n     * Returns a uniformly distributed random point from anywhere within the Circle.\n     *\n     * @method Phaser.Geom.Circle#getRandomPoint\n     * @since 3.0.0\n     *\n     * @generic {Phaser.Geom.Point} O - [point,$return]\n     *\n     * @param {(Phaser.Geom.Point|object)} [point] - A Point or point-like object to set the random `x` and `y` values in.\n     *\n     * @return {(Phaser.Geom.Point|object)} A Point object with the random values set in the `x` and `y` properties.\n     */\n    getRandomPoint(point) {\n        return (0, Random_1.default)(this, point);\n    }\n    /**\n     * Sets the x, y and radius of this circle.\n     *\n     * @method Phaser.Geom.Circle#setTo\n     * @since 3.0.0\n     *\n     * @param {number} [x=0] - The x position of the center of the circle.\n     * @param {number} [y=0] - The y position of the center of the circle.\n     * @param {number} [radius=0] - The radius of the circle.\n     *\n     * @return {this} This Circle object.\n     */\n    setTo(x, y, radius) {\n        this.x = x;\n        this.y = y;\n        this._radius = radius;\n        this._diameter = radius * 2;\n        return this;\n    }\n    /**\n     * Sets this Circle to be empty with a radius of zero.\n     * Does not change its position.\n     *\n     * @method Phaser.Geom.Circle#setEmpty\n     * @since 3.0.0\n     *\n     * @return {this} This Circle object.\n     */\n    setEmpty() {\n        this._radius = 0;\n        this._diameter = 0;\n        return this;\n    }\n    /**\n     * Sets the position of this Circle.\n     *\n     * @method Phaser.Geom.Circle#setPosition\n     * @since 3.0.0\n     *\n     * @param {number} [x=0] - The x position of the center of the circle.\n     * @param {number} [y=0] - The y position of the center of the circle.\n     *\n     * @return {this} This Circle object.\n     */\n    setPosition(x, y) {\n        if (y === undefined) {\n            y = x;\n        }\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    /**\n     * Checks to see if the Circle is empty: has a radius of zero.\n     *\n     * @method Phaser.Geom.Circle#isEmpty\n     * @since 3.0.0\n     *\n     * @return {boolean} True if the Circle is empty, otherwise false.\n     */\n    isEmpty() {\n        return this._radius <= 0;\n    }\n    /**\n     * The radius of the Circle.\n     *\n     * @name Phaser.Geom.Circle#radius\n     * @type {number}\n     * @since 3.0.0\n     */\n    get radius() {\n        return this._radius;\n    }\n    set radius(value) {\n        this._radius = value;\n        this._diameter = value * 2;\n    }\n    /**\n     * The diameter of the Circle.\n     *\n     * @name Phaser.Geom.Circle#diameter\n     * @type {number}\n     * @since 3.0.0\n     */\n    get diameter() {\n        return this._diameter;\n    }\n    set diameter(value) {\n        this._diameter = value;\n        this._radius = value * 0.5;\n    }\n    /**\n     * The left position of the Circle.\n     *\n     * @name Phaser.Geom.Circle#left\n     * @type {number}\n     * @since 3.0.0\n     */\n    get left() {\n        return this.x - this._radius;\n    }\n    set left(value) {\n        this.x = value + this._radius;\n    }\n    /**\n     * The right position of the Circle.\n     *\n     * @name Phaser.Geom.Circle#right\n     * @type {number}\n     * @since 3.0.0\n     */\n    get right() {\n        return this.x + this._radius;\n    }\n    set right(value) {\n        this.x = value - this._radius;\n    }\n    /**\n     * The top position of the Circle.\n     *\n     * @name Phaser.Geom.Circle#top\n     * @type {number}\n     * @since 3.0.0\n     */\n    get top() {\n        return this.y - this._radius;\n    }\n    set top(value) {\n        this.y = value + this._radius;\n    }\n    /**\n     * The bottom position of the Circle.\n     *\n     * @name Phaser.Geom.Circle#bottom\n     * @type {number}\n     * @since 3.0.0\n     */\n    get bottom() {\n        return this.y + this._radius;\n    }\n    set bottom(value) {\n        this.y = value - this._radius;\n    }\n}\nexports.Circle = Circle;\n//# sourceMappingURL=Circle.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst DistanceBetween_1 = __importDefault(require(\"../../math/distance/DistanceBetween\"));\n/**\n * Checks if two Circles intersect.\n *\n * @function Phaser.Geom.Intersects.CircleToCircle\n * @since 3.0.0\n *\n * @param {Phaser.Geom.Circle} circleA - The first Circle to check for intersection.\n * @param {Phaser.Geom.Circle} circleB - The second Circle to check for intersection.\n *\n * @return {boolean} `true` if the two Circles intersect, otherwise `false`.\n */\nconst CircleToCircle = (circleA, circleB) => {\n    return (0, DistanceBetween_1.default)(circleA.x, circleA.y, circleB.x, circleB.y) <= circleA.radius + circleB.radius;\n};\nexports.default = CircleToCircle;\n//# sourceMappingURL=CircleToCircle.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Checks for intersection between a circle and a rectangle.\n *\n * @function Phaser.Geom.Intersects.CircleToRectangle\n * @since 3.0.0\n *\n * @param {Phaser.Geom.Circle} circle - The circle to be checked.\n * @param {Phaser.Geom.Rectangle} rect - The rectangle to be checked.\n *\n * @return {boolean} `true` if the two objects intersect, otherwise `false`.\n */\nconst CircleToRectangle = (circle, rect) => {\n    const halfWidth = rect.width / 2;\n    const halfHeight = rect.height / 2;\n    const cx = Math.abs(circle.x - rect.x - halfWidth);\n    const cy = Math.abs(circle.y - rect.y - halfHeight);\n    const xDist = halfWidth + circle.radius;\n    const yDist = halfHeight + circle.radius;\n    if (cx > xDist || cy > yDist) {\n        return false;\n    }\n    else if (cx <= halfWidth || cy <= halfHeight) {\n        return true;\n    }\n    else {\n        const xCornerDist = cx - halfWidth;\n        const yCornerDist = cy - halfHeight;\n        const xCornerDistSq = xCornerDist * xCornerDist;\n        const yCornerDistSq = yCornerDist * yCornerDist;\n        const maxCornerDistSq = circle.radius * circle.radius;\n        return xCornerDistSq + yCornerDistSq <= maxCornerDistSq;\n    }\n};\nexports.default = CircleToRectangle;\n//# sourceMappingURL=CircleToRectangle.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst OverlapRect_1 = __importDefault(require(\"./OverlapRect\"));\nconst Circle_1 = require(\"../../../geom/circle/Circle\");\nconst CircleToCircle_1 = __importDefault(require(\"../../../geom/intersects/CircleToCircle\"));\nconst CircleToRectangle_1 = __importDefault(require(\"../../../geom/intersects/CircleToRectangle\"));\n/**\n * This method will search the given circular area and return an array of all physics bodies that\n * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\n *\n * A body only has to intersect with the search area to be considered, it doesn't have to be fully\n * contained within it.\n *\n * If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,\n * otherwise the search is O(N) for Dynamic Bodies.\n *\n * @function Phaser.Physics.Arcade.Components.OverlapCirc\n * @since 3.21.0\n *\n * @param {number} x - The x coordinate of the center of the area to search within.\n * @param {number} y - The y coordinate of the center of the area to search within.\n * @param {number} radius - The radius of the area to search within.\n * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\n * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\n *\n * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\n */\nconst OverlapCirc = function (world, x, y, radius, includeDynamic = true, includeStatic = false) {\n    const bodiesInRect = (0, OverlapRect_1.default)(world, x - radius, y - radius, 2 * radius, 2 * radius, includeDynamic, includeStatic);\n    if (bodiesInRect.length === 0) {\n        return bodiesInRect;\n    }\n    const area = new Circle_1.Circle(x, y, radius);\n    const circFromBody = new Circle_1.Circle();\n    const bodiesInArea = [];\n    for (let i = 0; i < bodiesInRect.length; i++) {\n        const body = bodiesInRect[i];\n        if (body.isCircle) {\n            circFromBody.setTo(body.center.x, body.center.y, body.halfWidth);\n            if ((0, CircleToCircle_1.default)(area, circFromBody)) {\n                bodiesInArea.push(body);\n            }\n        }\n        else if ((0, CircleToRectangle_1.default)(area, body)) {\n            bodiesInArea.push(body);\n        }\n    }\n    return bodiesInArea;\n};\nexports.default = OverlapCirc;\n//# sourceMappingURL=OverlapCirc.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Find the angle of a segment from (point1.x, point1.y) -> (point2.x, point2.y).\n *\n * Calculates the angle of the vector from the first point to the second point.\n *\n * @function Phaser.Math.Angle.BetweenPoints\n * @since 3.0.0\n *\n * @param {Phaser.Types.Math.Vector2Like} point1 - The first point.\n * @param {Phaser.Types.Math.Vector2Like} point2 - The second point.\n *\n * @return {number} The angle in radians.\n */\nconst BetweenPoints = (point1, point2) => {\n    return Math.atan2(point2.y - point1.y, point2.x - point1.x);\n};\nexports.default = BetweenPoints;\n//# sourceMappingURL=BetweenPoints.js.map","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Check whether `a` is fuzzily greater than `b`.\n *\n * `a` is fuzzily greater than `b` if it is more than `b - epsilon`.\n *\n * @function Phaser.Math.Fuzzy.GreaterThan\n * @since 3.0.0\n *\n * @param {number} a - The first value.\n * @param {number} b - The second value.\n * @param {number} [epsilon=0.0001] - The epsilon.\n *\n * @return {boolean} `true` if `a` is fuzzily greater than than `b`, otherwise `false`.\n */\nconst GreaterThan = (a, b, epsilon) => {\n    if (epsilon === undefined) {\n        epsilon = 0.0001;\n    }\n    return a > b - epsilon;\n};\nexports.default = GreaterThan;\n//# sourceMappingURL=GreaterThan.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Check whether `a` is fuzzily less than `b`.\n *\n * `a` is fuzzily less than `b` if it is less than `b + epsilon`.\n *\n * @function Phaser.Math.Fuzzy.LessThan\n * @since 3.0.0\n *\n * @param {number} a - The first value.\n * @param {number} b - The second value.\n * @param {number} [epsilon=0.0001] - The epsilon.\n *\n * @return {boolean} `true` if `a` is fuzzily less than `b`, otherwise `false`.\n */\nconst LessThan = (a, b, epsilon) => {\n    if (epsilon === undefined) {\n        epsilon = 0.0001;\n    }\n    return a < b + epsilon;\n};\nexports.default = LessThan;\n//# sourceMappingURL=LessThan.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GetOverlapX = void 0;\nconst const_1 = __importDefault(require(\"./const\"));\n/**\n * Calculates and returns the horizontal overlap between two arcade physics bodies and sets their properties\n * accordingly, including: `touching.left`, `touching.right`, `touching.none` and `overlapX'.\n *\n * @function Phaser.Physics.Arcade.GetOverlapX\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\n *\n * @return {number} The amount of overlap.\n */\nconst GetOverlapX = (body1, body2, overlapOnly, bias) => {\n    let overlap = 0;\n    const maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;\n    if (body1._dx === 0 && body2._dx === 0) {\n        //  They overlap but neither of them are moving\n        body1.embedded = true;\n        body2.embedded = true;\n    }\n    else if (body1._dx > body2._dx) {\n        //  Body1 is moving right and / or Body2 is moving left\n        overlap = body1.right - body2.x;\n        if ((overlap > maxOverlap && !overlapOnly) ||\n            body1.checkCollision.right === false ||\n            body2.checkCollision.left === false) {\n            overlap = 0;\n        }\n        else {\n            body1.touching.none = false;\n            body1.touching.right = true;\n            body2.touching.none = false;\n            body2.touching.left = true;\n            if (body2.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY && !overlapOnly) {\n                body1.blocked.none = false;\n                body1.blocked.right = true;\n            }\n            if (body1.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY && !overlapOnly) {\n                body2.blocked.none = false;\n                body2.blocked.left = true;\n            }\n        }\n    }\n    else if (body1._dx < body2._dx) {\n        //  Body1 is moving left and/or Body2 is moving right\n        overlap = body1.x - body2.width - body2.x;\n        if ((-overlap > maxOverlap && !overlapOnly) ||\n            body1.checkCollision.left === false ||\n            body2.checkCollision.right === false) {\n            overlap = 0;\n        }\n        else {\n            body1.touching.none = false;\n            body1.touching.left = true;\n            body2.touching.none = false;\n            body2.touching.right = true;\n            if (body2.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY && !overlapOnly) {\n                body1.blocked.none = false;\n                body1.blocked.left = true;\n            }\n            if (body1.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY && !overlapOnly) {\n                body2.blocked.none = false;\n                body2.blocked.right = true;\n            }\n        }\n    }\n    //  Resets the overlapX to zero if there is no overlap, or to the actual pixel value if there is\n    body1.overlapX = overlap;\n    body2.overlapX = overlap;\n    return overlap;\n};\nexports.GetOverlapX = GetOverlapX;\n//# sourceMappingURL=GetOverlapX.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GetOverlapY = void 0;\nconst const_1 = __importDefault(require(\"./const\"));\n/**\n * Calculates and returns the vertical overlap between two arcade physics bodies and sets their properties\n * accordingly, including: `touching.up`, `touching.down`, `touching.none` and `overlapY'.\n *\n * @function Phaser.Physics.Arcade.GetOverlapY\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\n *\n * @return {number} The amount of overlap.\n */\nconst GetOverlapY = (body1, body2, overlapOnly, bias) => {\n    let overlap = 0;\n    const maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + bias;\n    if (body1._dy === 0 && body2._dy === 0) {\n        //  They overlap but neither of them are moving\n        body1.embedded = true;\n        body2.embedded = true;\n    }\n    else if (body1._dy > body2._dy) {\n        //  Body1 is moving down and/or Body2 is moving up\n        overlap = body1.bottom - body2.y;\n        if ((overlap > maxOverlap && !overlapOnly) ||\n            body1.checkCollision.down === false ||\n            body2.checkCollision.up === false) {\n            overlap = 0;\n        }\n        else {\n            body1.touching.none = false;\n            body1.touching.down = true;\n            body2.touching.none = false;\n            body2.touching.up = true;\n            if (body2.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY && !overlapOnly) {\n                body1.blocked.none = false;\n                body1.blocked.down = true;\n            }\n            if (body1.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY && !overlapOnly) {\n                body2.blocked.none = false;\n                body2.blocked.up = true;\n            }\n        }\n    }\n    else if (body1._dy < body2._dy) {\n        //  Body1 is moving up and/or Body2 is moving down\n        overlap = body1.y - body2.bottom;\n        if ((-overlap > maxOverlap && !overlapOnly) ||\n            body1.checkCollision.up === false ||\n            body2.checkCollision.down === false) {\n            overlap = 0;\n        }\n        else {\n            body1.touching.none = false;\n            body1.touching.up = true;\n            body2.touching.none = false;\n            body2.touching.down = true;\n            if (body2.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY && !overlapOnly) {\n                body1.blocked.none = false;\n                body1.blocked.up = true;\n            }\n            if (body1.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY && !overlapOnly) {\n                body2.blocked.none = false;\n                body2.blocked.down = true;\n            }\n        }\n    }\n    //  Resets the overlapY to zero if there is no overlap, or to the actual pixel value if there is\n    body1.overlapY = overlap;\n    body2.overlapY = overlap;\n    return overlap;\n};\nexports.GetOverlapY = GetOverlapY;\n//# sourceMappingURL=GetOverlapY.js.map","\"use strict\";\n/* eslint-disable no-prototype-builtins */\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//  Source object\n//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'\n//  The default value to use if the key doesn't exist\n/**\n * Retrieves a value from an object.\n *\n * @function Phaser.Utils.Objects.GetValue\n * @since 3.0.0\n *\n * @param {object} source - The object to retrieve the value from.\n * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.\n * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.\n *\n * @return {*} The value of the requested key.\n */\nconst GetValue = (source, key, defaultValue) => {\n    if (!source || typeof source === 'number') {\n        return defaultValue;\n    }\n    else if (source.hasOwnProperty(key)) {\n        return source[key];\n    }\n    else if (key.indexOf('.') !== -1) {\n        const keys = key.split('.');\n        let parent = source;\n        let value = defaultValue;\n        //  Use for loop here so we can break early\n        for (let i = 0; i < keys.length; i++) {\n            if (parent.hasOwnProperty(keys[i])) {\n                //  Yes it has a key property, let's carry on down\n                value = parent[keys[i]];\n                parent = parent[keys[i]];\n            }\n            else {\n                //  Can't go any further, so reset to default\n                value = defaultValue;\n                break;\n            }\n        }\n        return value;\n    }\n    else {\n        return defaultValue;\n    }\n};\nexports.default = GetValue;\n//# sourceMappingURL=GetValue.js.map","!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rbush = void 0;\nconst rbush_1 = __importDefault(require(\"rbush\"));\nconst rbush = maxEntries => {\n    return new rbush_1.default(maxEntries);\n};\nexports.rbush = rbush;\nclass RTree extends rbush_1.default {\n    constructor(maxEntries) {\n        super(maxEntries);\n    }\n}\nexports.default = RTree;\n//# sourceMappingURL=RTree.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RunImmovableBody2 = exports.RunImmovableBody1 = exports.Run = exports.Check = exports.BlockCheck = exports.Set = void 0;\n// @ts-ignore\nlet body1;\nlet body2;\nlet body1Pushable;\nlet body2Pushable;\nlet body1MassImpact;\nlet body2MassImpact;\nlet body1FullImpact;\nlet body2FullImpact;\nlet body1MovingLeft;\nlet body1MovingRight;\nlet body1Stationary;\nlet body2MovingLeft;\nlet body2MovingRight;\nlet body2Stationary;\nlet body1OnLeft;\nlet body2OnLeft;\nlet overlap;\n/**\n * Sets all of the local processing values and calculates the velocity exchanges.\n *\n * Then runs `BlockCheck` and returns the value from it.\n *\n * This method is called by `Phaser.Physics.Arcade.SeparateX` and should not be\n * called directly.\n *\n * @function Phaser.Physics.Arcade.ProcessX.Set\n * @ignore\n * @since 3.50.0\n *\n * @param {Phaser.Physics.Arcade.Body} b1 - The first Body to separate.\n * @param {Phaser.Physics.Arcade.Body} b2 - The second Body to separate.\n * @param {number} ov - The overlap value.\n *\n * @return {number} The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked.\n */\nconst Set = (b1, b2, ov) => {\n    body1 = b1;\n    body2 = b2;\n    const v1 = body1.velocity.x;\n    const v2 = body2.velocity.x;\n    body1Pushable = body1.pushable;\n    body1MovingLeft = body1._dx < 0;\n    body1MovingRight = body1._dx > 0;\n    body1Stationary = body1._dx === 0;\n    body1OnLeft = Math.abs(body1.right - body2.x) <= Math.abs(body2.right - body1.x);\n    body1FullImpact = v2 - v1 * body1.bounce.x;\n    body2Pushable = body2.pushable;\n    body2MovingLeft = body2._dx < 0;\n    body2MovingRight = body2._dx > 0;\n    body2Stationary = body2._dx === 0;\n    body2OnLeft = !body1OnLeft;\n    body2FullImpact = v1 - v2 * body2.bounce.x;\n    //  negative delta = up, positive delta = down (inc. gravity)\n    overlap = Math.abs(ov);\n    return (0, exports.BlockCheck)();\n};\nexports.Set = Set;\n/**\n * Blocked Direction checks, because it doesn't matter if an object can be pushed\n * or not, blocked is blocked.\n *\n * @function Phaser.Physics.Arcade.ProcessX.BlockCheck\n * @ignore\n * @since 3.50.0\n *\n * @return {number} The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked.\n */\nconst BlockCheck = () => {\n    //  Body1 is moving right and Body2 is blocked from going right any further\n    if (body1MovingRight && body1OnLeft && body2.blocked.right) {\n        body1.processX(-overlap, body1FullImpact, false, true);\n        return 1;\n    }\n    //  Body1 is moving up and Body2 is blocked from going up any further\n    if (body1MovingLeft && body2OnLeft && body2.blocked.left) {\n        body1.processX(overlap, body1FullImpact, true);\n        return 1;\n    }\n    //  Body2 is moving right and Body1 is blocked from going right any further\n    if (body2MovingRight && body2OnLeft && body1.blocked.right) {\n        body2.processX(-overlap, body2FullImpact, false, true);\n        return 2;\n    }\n    //  Body2 is moving up and Body1 is blocked from going up any further\n    if (body2MovingLeft && body1OnLeft && body1.blocked.left) {\n        body2.processX(overlap, body2FullImpact, true);\n        return 2;\n    }\n    return 0;\n};\nexports.BlockCheck = BlockCheck;\n/**\n * The main check function. Runs through one of the four possible tests and returns the results.\n *\n * @function Phaser.Physics.Arcade.ProcessX.Check\n * @ignore\n * @since 3.50.0\n *\n * @return {boolean} `true` if a check passed, otherwise `false`.\n */\nconst Check = () => {\n    const v1 = body1.velocity.x;\n    const v2 = body2.velocity.x;\n    let nv1 = Math.sqrt((v2 * v2 * body2.mass) / body1.mass) * (v2 > 0 ? 1 : -1);\n    let nv2 = Math.sqrt((v1 * v1 * body1.mass) / body2.mass) * (v1 > 0 ? 1 : -1);\n    const avg = (nv1 + nv2) * 0.5;\n    nv1 -= avg;\n    nv2 -= avg;\n    body1MassImpact = avg + nv1 * body1.bounce.x;\n    body2MassImpact = avg + nv2 * body2.bounce.x;\n    //  Body1 hits Body2 on the right hand side\n    if (body1MovingLeft && body2OnLeft) {\n        return (0, exports.Run)(0);\n    }\n    //  Body2 hits Body1 on the right hand side\n    if (body2MovingLeft && body1OnLeft) {\n        return (0, exports.Run)(1);\n    }\n    //  Body1 hits Body2 on the left hand side\n    if (body1MovingRight && body1OnLeft) {\n        return (0, exports.Run)(2);\n    }\n    //  Body2 hits Body1 on the left hand side\n    if (body2MovingRight && body2OnLeft) {\n        return (0, exports.Run)(3);\n    }\n    return false;\n};\nexports.Check = Check;\n/**\n * The main check function. Runs through one of the four possible tests and returns the results.\n *\n * @function Phaser.Physics.Arcade.ProcessX.Run\n * @ignore\n * @since 3.50.0\n *\n * @param {number} side - The side to test. As passed in by the `Check` function.\n *\n * @return {boolean} Always returns `true`.\n */\nconst Run = side => {\n    if (body1Pushable && body2Pushable) {\n        //  Both pushable, or both moving at the same time, so equal rebound\n        overlap *= 0.5;\n        if (side === 0 || side === 3) {\n            //  body1MovingLeft && body2OnLeft\n            //  body2MovingRight && body2OnLeft\n            body1.processX(overlap, body1MassImpact);\n            body2.processX(-overlap, body2MassImpact);\n        }\n        else {\n            //  body2MovingLeft && body1OnLeft\n            //  body1MovingRight && body1OnLeft\n            body1.processX(-overlap, body1MassImpact);\n            body2.processX(overlap, body2MassImpact);\n        }\n    }\n    else if (body1Pushable && !body2Pushable) {\n        //  Body1 pushable, Body2 not\n        if (side === 0 || side === 3) {\n            //  body1MovingLeft && body2OnLeft\n            //  body2MovingRight && body2OnLeft\n            body1.processX(overlap, body1FullImpact, true);\n        }\n        else {\n            //  body2MovingLeft && body1OnLeft\n            //  body1MovingRight && body1OnLeft\n            body1.processX(-overlap, body1FullImpact, false, true);\n        }\n    }\n    else if (!body1Pushable && body2Pushable) {\n        //  Body2 pushable, Body1 not\n        if (side === 0 || side === 3) {\n            //  body1MovingLeft && body2OnLeft\n            //  body2MovingRight && body2OnLeft\n            body2.processX(-overlap, body2FullImpact, false, true);\n        }\n        else {\n            //  body2MovingLeft && body1OnLeft\n            //  body1MovingRight && body1OnLeft\n            body2.processX(overlap, body2FullImpact, true);\n        }\n    }\n    else {\n        //  Neither body is pushable, so base it on movement\n        const halfOverlap = overlap * 0.5;\n        if (side === 0) {\n            //  body1MovingLeft && body2OnLeft\n            if (body2Stationary) {\n                body1.processX(overlap, 0, true);\n                body2.processX(0, null, false, true);\n            }\n            else if (body2MovingRight) {\n                body1.processX(halfOverlap, 0, true);\n                body2.processX(-halfOverlap, 0, false, true);\n            }\n            else {\n                //  Body2 moving same direction as Body1\n                body1.processX(halfOverlap, body2.velocity.x, true);\n                body2.processX(-halfOverlap, null, false, true);\n            }\n        }\n        else if (side === 1) {\n            //  body2MovingLeft && body1OnLeft\n            if (body1Stationary) {\n                body1.processX(0, null, false, true);\n                body2.processX(overlap, 0, true);\n            }\n            else if (body1MovingRight) {\n                body1.processX(-halfOverlap, 0, false, true);\n                body2.processX(halfOverlap, 0, true);\n            }\n            else {\n                //  Body1 moving same direction as Body2\n                body1.processX(-halfOverlap, null, false, true);\n                body2.processX(halfOverlap, body1.velocity.x, true);\n            }\n        }\n        else if (side === 2) {\n            //  body1MovingRight && body1OnLeft\n            if (body2Stationary) {\n                body1.processX(-overlap, 0, false, true);\n                body2.processX(0, null, true);\n            }\n            else if (body2MovingLeft) {\n                body1.processX(-halfOverlap, 0, false, true);\n                body2.processX(halfOverlap, 0, true);\n            }\n            else {\n                //  Body2 moving same direction as Body1\n                body1.processX(-halfOverlap, body2.velocity.x, false, true);\n                body2.processX(halfOverlap, null, true);\n            }\n        }\n        else if (side === 3) {\n            //  body2MovingRight && body2OnLeft\n            if (body1Stationary) {\n                body1.processX(0, null, true);\n                body2.processX(-overlap, 0, false, true);\n            }\n            else if (body1MovingLeft) {\n                body1.processX(halfOverlap, 0, true);\n                body2.processX(-halfOverlap, 0, false, true);\n            }\n            else {\n                //  Body1 moving same direction as Body2\n                body1.processX(halfOverlap, body2.velocity.y, true);\n                body2.processX(-halfOverlap, null, false, true);\n            }\n        }\n    }\n    return true;\n};\nexports.Run = Run;\n/**\n * This function is run when Body1 is Immovable and Body2 is not.\n *\n * @function Phaser.Physics.Arcade.ProcessX.RunImmovableBody1\n * @ignore\n * @since 3.50.0\n *\n * @param {number} blockedState - The block state value.\n */\nconst RunImmovableBody1 = blockedState => {\n    if (blockedState === 1) {\n        //  But Body2 cannot go anywhere either, so we cancel out velocity\n        //  Separation happened in the block check\n        body2.velocity.x = 0;\n    }\n    else if (body1OnLeft) {\n        body2.processX(overlap, body2FullImpact, true);\n    }\n    else {\n        body2.processX(-overlap, body2FullImpact, false, true);\n    }\n    //  This is special case code that handles things like vertically moving platforms you can ride\n    if (body1.moves) {\n        body2.y += (body1.y - body1.prev.y) * body1.friction.y;\n        body2._dy = body2.y - body2.prev.y;\n    }\n};\nexports.RunImmovableBody1 = RunImmovableBody1;\n/**\n * This function is run when Body2 is Immovable and Body1 is not.\n *\n * @function Phaser.Physics.Arcade.ProcessX.RunImmovableBody2\n * @ignore\n * @since 3.50.0\n *\n * @param {number} blockedState - The block state value.\n */\nconst RunImmovableBody2 = blockedState => {\n    if (blockedState === 2) {\n        //  But Body1 cannot go anywhere either, so we cancel out velocity\n        //  Separation happened in the block check\n        body1.velocity.x = 0;\n    }\n    else if (body2OnLeft) {\n        body1.processX(overlap, body1FullImpact, true);\n    }\n    else {\n        body1.processX(-overlap, body1FullImpact, false, true);\n    }\n    //  This is special case code that handles things like vertically moving platforms you can ride\n    if (body2.moves) {\n        body1.y += (body2.y - body2.prev.y) * body2.friction.y;\n        body1._dy = body1.y - body1.prev.y;\n    }\n};\nexports.RunImmovableBody2 = RunImmovableBody2;\n//# sourceMappingURL=ProcessX.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SeparateX = void 0;\nconst GetOverlapX_1 = require(\"./GetOverlapX\");\nconst ProcessX = __importStar(require(\"./ProcessX\"));\n/**\n * Separates two overlapping bodies on the X-axis (horizontally).\n *\n * Separation involves moving two overlapping bodies so they don't overlap anymore and adjusting their velocities based on their mass. This is a core part of collision detection.\n *\n * The bodies won't be separated if there is no horizontal overlap between them, if they are static, or if either one uses custom logic for its separation.\n *\n * @function Phaser.Physics.Arcade.SeparateX\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\n * @param {boolean} overlapOnly - If `true`, the bodies will only have their overlap data set and no separation will take place.\n * @param {number} bias - A value to add to the delta value during overlap checking. Used to prevent sprite tunneling.\n *\n * @return {boolean} `true` if the two bodies overlap vertically, otherwise `false`.\n */\nconst SeparateX = (body1, body2, overlapOnly, bias) => {\n    const overlap = (0, GetOverlapX_1.GetOverlapX)(body1, body2, overlapOnly, bias);\n    const body1Immovable = body1.immovable;\n    const body2Immovable = body2.immovable;\n    //  Can't separate two immovable bodies, or a body with its own custom separation logic\n    if (overlapOnly ||\n        overlap === 0 ||\n        (body1Immovable && body2Immovable) ||\n        body1.customSeparateX ||\n        body2.customSeparateX) {\n        //  return true if there was some overlap, otherwise false\n        return overlap !== 0 || (body1.embedded && body2.embedded);\n    }\n    const blockedState = ProcessX.Set(body1, body2, overlap);\n    if (!body1Immovable && !body2Immovable) {\n        if (blockedState > 0) {\n            return true;\n        }\n        return ProcessX.Check();\n    }\n    else if (body1Immovable) {\n        ProcessX.RunImmovableBody1(blockedState);\n    }\n    else if (body2Immovable) {\n        ProcessX.RunImmovableBody2(blockedState);\n    }\n    //  If we got this far then there WAS overlap, and separation is complete, so return true\n    return true;\n};\nexports.SeparateX = SeparateX;\n//# sourceMappingURL=SeparateX.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RunImmovableBody2 = exports.RunImmovableBody1 = exports.Run = exports.Check = exports.BlockCheck = exports.Set = void 0;\n// @ts-ignore\nlet body1;\nlet body2;\nlet body1Pushable;\nlet body2Pushable;\nlet body1MassImpact;\nlet body2MassImpact;\nlet body1FullImpact;\nlet body2FullImpact;\nlet body1MovingUp;\nlet body1MovingDown;\nlet body1Stationary;\nlet body2MovingUp;\nlet body2MovingDown;\nlet body2Stationary;\nlet body1OnTop;\nlet body2OnTop;\nlet overlap;\n/**\n * Sets all of the local processing values and calculates the velocity exchanges.\n *\n * Then runs `BlockCheck` and returns the value from it.\n *\n * This method is called by `Phaser.Physics.Arcade.SeparateY` and should not be\n * called directly.\n *\n * @function Phaser.Physics.Arcade.ProcessY.Set\n * @ignore\n * @since 3.50.0\n *\n * @param {Phaser.Physics.Arcade.Body} b1 - The first Body to separate.\n * @param {Phaser.Physics.Arcade.Body} b2 - The second Body to separate.\n * @param {number} ov - The overlap value.\n *\n * @return {number} The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked.\n */\nconst Set = (b1, b2, ov) => {\n    body1 = b1;\n    body2 = b2;\n    const v1 = body1.velocity.y;\n    const v2 = body2.velocity.y;\n    body1Pushable = body1.pushable;\n    body1MovingUp = body1._dy < 0;\n    body1MovingDown = body1._dy > 0;\n    body1Stationary = body1._dy === 0;\n    body1OnTop = Math.abs(body1.bottom - body2.y) <= Math.abs(body2.bottom - body1.y);\n    body1FullImpact = v2 - v1 * body1.bounce.y;\n    body2Pushable = body2.pushable;\n    body2MovingUp = body2._dy < 0;\n    body2MovingDown = body2._dy > 0;\n    body2Stationary = body2._dy === 0;\n    body2OnTop = !body1OnTop;\n    body2FullImpact = v1 - v2 * body2.bounce.y;\n    //  negative delta = up, positive delta = down (inc. gravity)\n    overlap = Math.abs(ov);\n    return (0, exports.BlockCheck)();\n};\nexports.Set = Set;\n/**\n * Blocked Direction checks, because it doesn't matter if an object can be pushed\n * or not, blocked is blocked.\n *\n * @function Phaser.Physics.Arcade.ProcessY.BlockCheck\n * @ignore\n * @since 3.50.0\n *\n * @return {number} The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked.\n */\nconst BlockCheck = () => {\n    //  Body1 is moving down and Body2 is blocked from going down any further\n    if (body1MovingDown && body1OnTop && body2.blocked.down) {\n        body1.processY(-overlap, body1FullImpact, false, true);\n        return 1;\n    }\n    //  Body1 is moving up and Body2 is blocked from going up any further\n    if (body1MovingUp && body2OnTop && body2.blocked.up) {\n        body1.processY(overlap, body1FullImpact, true);\n        return 1;\n    }\n    //  Body2 is moving down and Body1 is blocked from going down any further\n    if (body2MovingDown && body2OnTop && body1.blocked.down) {\n        body2.processY(-overlap, body2FullImpact, false, true);\n        return 2;\n    }\n    //  Body2 is moving up and Body1 is blocked from going up any further\n    if (body2MovingUp && body1OnTop && body1.blocked.up) {\n        body2.processY(overlap, body2FullImpact, true);\n        return 2;\n    }\n    return 0;\n};\nexports.BlockCheck = BlockCheck;\n/**\n * The main check function. Runs through one of the four possible tests and returns the results.\n *\n * @function Phaser.Physics.Arcade.ProcessY.Check\n * @ignore\n * @since 3.50.0\n *\n * @return {boolean} `true` if a check passed, otherwise `false`.\n */\nconst Check = () => {\n    const v1 = body1.velocity.y;\n    const v2 = body2.velocity.y;\n    let nv1 = Math.sqrt((v2 * v2 * body2.mass) / body1.mass) * (v2 > 0 ? 1 : -1);\n    let nv2 = Math.sqrt((v1 * v1 * body1.mass) / body2.mass) * (v1 > 0 ? 1 : -1);\n    const avg = (nv1 + nv2) * 0.5;\n    nv1 -= avg;\n    nv2 -= avg;\n    body1MassImpact = avg + nv1 * body1.bounce.y;\n    body2MassImpact = avg + nv2 * body2.bounce.y;\n    //  Body1 hits Body2 on the bottom side\n    if (body1MovingUp && body2OnTop) {\n        return (0, exports.Run)(0);\n    }\n    //  Body2 hits Body1 on the bottom side\n    if (body2MovingUp && body1OnTop) {\n        return (0, exports.Run)(1);\n    }\n    //  Body1 hits Body2 on the top side\n    if (body1MovingDown && body1OnTop) {\n        return (0, exports.Run)(2);\n    }\n    //  Body2 hits Body1 on the top side\n    if (body2MovingDown && body2OnTop) {\n        return (0, exports.Run)(3);\n    }\n    return false;\n};\nexports.Check = Check;\n/**\n * The main check function. Runs through one of the four possible tests and returns the results.\n *\n * @function Phaser.Physics.Arcade.ProcessY.Run\n * @ignore\n * @since 3.50.0\n *\n * @param {number} side - The side to test. As passed in by the `Check` function.\n *\n * @return {boolean} Always returns `true`.\n */\nconst Run = side => {\n    if (body1Pushable && body2Pushable) {\n        //  Both pushable, or both moving at the same time, so equal rebound\n        overlap *= 0.5;\n        if (side === 0 || side === 3) {\n            //  body1MovingUp && body2OnTop\n            //  body2MovingDown && body2OnTop\n            body1.processY(overlap, body1MassImpact);\n            body2.processY(-overlap, body2MassImpact);\n        }\n        else {\n            //  body2MovingUp && body1OnTop\n            //  body1MovingDown && body1OnTop\n            body1.processY(-overlap, body1MassImpact);\n            body2.processY(overlap, body2MassImpact);\n        }\n    }\n    else if (body1Pushable && !body2Pushable) {\n        //  Body1 pushable, Body2 not\n        if (side === 0 || side === 3) {\n            //  body1MovingUp && body2OnTop\n            //  body2MovingDown && body2OnTop\n            body1.processY(overlap, body1FullImpact, true);\n        }\n        else {\n            //  body2MovingUp && body1OnTop\n            //  body1MovingDown && body1OnTop\n            body1.processY(-overlap, body1FullImpact, false, true);\n        }\n    }\n    else if (!body1Pushable && body2Pushable) {\n        //  Body2 pushable, Body1 not\n        if (side === 0 || side === 3) {\n            //  body1MovingUp && body2OnTop\n            //  body2MovingDown && body2OnTop\n            body2.processY(-overlap, body2FullImpact, false, true);\n        }\n        else {\n            //  body2MovingUp && body1OnTop\n            //  body1MovingDown && body1OnTop\n            body2.processY(overlap, body2FullImpact, true);\n        }\n    }\n    else {\n        //  Neither body is pushable, so base it on movement\n        const halfOverlap = overlap * 0.5;\n        if (side === 0) {\n            //  body1MovingUp && body2OnTop\n            if (body2Stationary) {\n                body1.processY(overlap, 0, true);\n                body2.processY(0, null, false, true);\n            }\n            else if (body2MovingDown) {\n                body1.processY(halfOverlap, 0, true);\n                body2.processY(-halfOverlap, 0, false, true);\n            }\n            else {\n                //  Body2 moving same direction as Body1\n                body1.processY(halfOverlap, body2.velocity.y, true);\n                body2.processY(-halfOverlap, null, false, true);\n            }\n        }\n        else if (side === 1) {\n            //  body2MovingUp && body1OnTop\n            if (body1Stationary) {\n                body1.processY(0, null, false, true);\n                body2.processY(overlap, 0, true);\n            }\n            else if (body1MovingDown) {\n                body1.processY(-halfOverlap, 0, false, true);\n                body2.processY(halfOverlap, 0, true);\n            }\n            else {\n                //  Body1 moving same direction as Body2\n                body1.processY(-halfOverlap, null, false, true);\n                body2.processY(halfOverlap, body1.velocity.y, true);\n            }\n        }\n        else if (side === 2) {\n            //  body1MovingDown && body1OnTop\n            if (body2Stationary) {\n                body1.processY(-overlap, 0, false, true);\n                body2.processY(0, null, true);\n            }\n            else if (body2MovingUp) {\n                body1.processY(-halfOverlap, 0, false, true);\n                body2.processY(halfOverlap, 0, true);\n            }\n            else {\n                //  Body2 moving same direction as Body1\n                body1.processY(-halfOverlap, body2.velocity.y, false, true);\n                body2.processY(halfOverlap, null, true);\n            }\n        }\n        else if (side === 3) {\n            //  body2MovingDown && body2OnTop\n            if (body1Stationary) {\n                body1.processY(0, null, true);\n                body2.processY(-overlap, 0, false, true);\n            }\n            else if (body1MovingUp) {\n                body1.processY(halfOverlap, 0, true);\n                body2.processY(-halfOverlap, 0, false, true);\n            }\n            else {\n                //  Body1 moving same direction as Body2\n                body1.processY(halfOverlap, body2.velocity.y, true);\n                body2.processY(-halfOverlap, null, false, true);\n            }\n        }\n    }\n    return true;\n};\nexports.Run = Run;\n/**\n * This function is run when Body1 is Immovable and Body2 is not.\n *\n * @function Phaser.Physics.Arcade.ProcessY.RunImmovableBody1\n * @ignore\n * @since 3.50.0\n *\n * @param {number} blockedState - The block state value.\n */\nconst RunImmovableBody1 = blockedState => {\n    if (blockedState === 1) {\n        //  But Body2 cannot go anywhere either, so we cancel out velocity\n        //  Separation happened in the block check\n        body2.velocity.y = 0;\n    }\n    else if (body1OnTop) {\n        body2.processY(overlap, body2FullImpact, true);\n    }\n    else {\n        body2.processY(-overlap, body2FullImpact, false, true);\n    }\n    //  This is special case code that handles things like horizontally moving platforms you can ride\n    if (body1.moves) {\n        body2.x += (body1.x - body1.prev.x) * body1.friction.x;\n        body2._dx = body2.x - body2.prev.x;\n    }\n};\nexports.RunImmovableBody1 = RunImmovableBody1;\n/**\n * This function is run when Body2 is Immovable and Body1 is not.\n *\n * @function Phaser.Physics.Arcade.ProcessY.RunImmovableBody2\n * @ignore\n * @since 3.50.0\n *\n * @param {number} blockedState - The block state value.\n */\nconst RunImmovableBody2 = blockedState => {\n    if (blockedState === 2) {\n        //  But Body1 cannot go anywhere either, so we cancel out velocity\n        //  Separation happened in the block check\n        body1.velocity.y = 0;\n    }\n    else if (body2OnTop) {\n        body1.processY(overlap, body1FullImpact, true);\n    }\n    else {\n        body1.processY(-overlap, body1FullImpact, false, true);\n    }\n    //  This is special case code that handles things like horizontally moving platforms you can ride\n    if (body2.moves) {\n        body1.x += (body2.x - body2.prev.x) * body2.friction.x;\n        body1._dx = body1.x - body1.prev.x;\n    }\n};\nexports.RunImmovableBody2 = RunImmovableBody2;\n//# sourceMappingURL=ProcessY.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SeparateY = void 0;\nconst GetOverlapY_1 = require(\"./GetOverlapY\");\nconst ProcessY = __importStar(require(\"./ProcessY\"));\n/**\n * Separates two overlapping bodies on the Y-axis (vertically).\n *\n * Separation involves moving two overlapping bodies so they don't overlap anymore and adjusting their velocities based on their mass. This is a core part of collision detection.\n *\n * The bodies won't be separated if there is no vertical overlap between them, if they are static, or if either one uses custom logic for its separation.\n *\n * @function Phaser.Physics.Arcade.SeparateY\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\n * @param {boolean} overlapOnly - If `true`, the bodies will only have their overlap data set and no separation will take place.\n * @param {number} bias - A value to add to the delta value during overlap checking. Used to prevent sprite tunneling.\n *\n * @return {boolean} `true` if the two bodies overlap vertically, otherwise `false`.\n */\nconst SeparateY = (body1, body2, overlapOnly, bias) => {\n    const overlap = (0, GetOverlapY_1.GetOverlapY)(body1, body2, overlapOnly, bias);\n    const body1Immovable = body1.immovable;\n    const body2Immovable = body2.immovable;\n    //  Can't separate two immovable bodies, or a body with its own custom separation logic\n    if (overlapOnly ||\n        overlap === 0 ||\n        (body1Immovable && body2Immovable) ||\n        body1.customSeparateY ||\n        body2.customSeparateY) {\n        //  return true if there was some overlap, otherwise false\n        return overlap !== 0 || (body1.embedded && body2.embedded);\n    }\n    const blockedState = ProcessY.Set(body1, body2, overlap);\n    if (!body1Immovable && !body2Immovable) {\n        if (blockedState > 0) {\n            return true;\n        }\n        return ProcessY.Check();\n    }\n    else if (body1Immovable) {\n        ProcessY.RunImmovableBody1(blockedState);\n    }\n    else if (body2Immovable) {\n        ProcessY.RunImmovableBody2(blockedState);\n    }\n    //  If we got this far then there WAS overlap, and separation is complete, so return true\n    return true;\n};\nexports.SeparateY = SeparateY;\n//# sourceMappingURL=SeparateY.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Wrap the given `value` between `min` and `max.\n *\n * @function Phaser.Math.Wrap\n * @since 3.0.0\n *\n * @param {number} value - The value to wrap.\n * @param {number} min - The minimum value.\n * @param {number} max - The maximum value.\n *\n * @return {number} The wrapped value.\n */\nconst Wrap = (value, min, max) => {\n    const range = max - min;\n    return min + ((((value - min) % range) + range) % range);\n};\nexports.default = Wrap;\n//# sourceMappingURL=Wrap.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Collider = void 0;\nclass Collider {\n    /**\n     * An Arcade Physics Collider will automatically check for collision, or overlaps, between two objects\n     * every step. If a collision, or overlap, occurs it will invoke the given callbacks.\n     *\n     * @param world The world in which the bodies will collide.\n     * @param overlapOnly Whether to check for collisions or overlaps.\n     * @param body1 The first object to check for collision.\n     * @param body2 The second object to check for collision.\n     * @param collideCallback The callback to invoke when the two objects collide.\n     * @param processCallback If a processCallback exists it must return true or collision checking will be skipped.\n     * @param callbackContext The context the collideCallback and processCallback will run in.\n     */\n    constructor(world, overlapOnly, body1, body2, collideCallback, processCallback, callbackContext) {\n        this.world = world;\n        this.overlapOnly = overlapOnly;\n        this.body1 = body1;\n        this.body2 = body2;\n        this.collideCallback = collideCallback;\n        this.processCallback = processCallback;\n        this.callbackContext = callbackContext;\n        /** The name of the collider (unused by Phaser). */\n        this.name = '';\n        /** Whether the collider is active. */\n        this.active = true;\n    }\n    /**\n     * A name for the Collider.\n     *\n     * Phaser does not use this value, it's for your own reference.\n     */\n    setName(name) {\n        this.name = name;\n        return this;\n    }\n    /** Called by World as part of its step processing, initial operation of collision checking. */\n    update() {\n        this.world.collideObjects(this.body1, this.body2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly);\n    }\n    /** Removes Collider from World and disposes of its resources. */\n    destroy() {\n        this.world.removeCollider(this);\n        this.active = false;\n        // @ts-ignore\n        this.world = null;\n        // @ts-ignore\n        this.body1 = null;\n        // @ts-ignore\n        this.body2 = null;\n        // @ts-ignore\n        this.collideCallback = null;\n        // @ts-ignore\n        this.processCallback = null;\n        this.callbackContext = null;\n    }\n}\nexports.Collider = Collider;\n//# sourceMappingURL=Collider.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @namespace Phaser.Structs.Events\n */\nexports.default = {\n    PROCESS_QUEUE_ADD: 'add',\n    PROCESS_QUEUE_REMOVE: 'remove'\n};\n//# sourceMappingURL=events.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProcessQueue = void 0;\n// var Class = require('../utils/Class');\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nconst events_1 = __importDefault(require(\"./events\"));\n/**\n * @classdesc\n * A Process Queue maintains three internal lists.\n *\n * The `pending` list is a selection of items which are due to be made 'active' in the next update.\n * The `active` list is a selection of items which are considered active and should be updated.\n * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.\n *\n * When new items are added to a Process Queue they are put in the pending list, rather than being added\n * immediately the active list. Equally, items that are removed are put into the destroy list, rather than\n * being destroyed immediately. This allows the Process Queue to carefully process each item at a specific, fixed\n * time, rather than at the time of the request from the API.\n *\n * @class ProcessQueue\n * @extends Phaser.Events.EventEmitter\n * @memberof Phaser.Structs\n * @constructor\n * @since 3.0.0\n *\n * @generic T\n */\nclass ProcessQueue extends eventemitter3_1.default {\n    constructor() {\n        super();\n        /**\n         * The `pending` list is a selection of items which are due to be made 'active' in the next update.\n         *\n         * @genericUse {T[]} - [$type]\n         *\n         * @name Phaser.Structs.ProcessQueue#_pending\n         * @type {Array.<*>}\n         * @private\n         * @default []\n         * @since 3.0.0\n         */\n        this._pending = [];\n        /**\n         * The `active` list is a selection of items which are considered active and should be updated.\n         *\n         * @genericUse {T[]} - [$type]\n         *\n         * @name Phaser.Structs.ProcessQueue#_active\n         * @type {Array.<*>}\n         * @private\n         * @default []\n         * @since 3.0.0\n         */\n        this._active = [];\n        /**\n         * The `destroy` list is a selection of items that were active and are awaiting being destroyed in the next update.\n         *\n         * @genericUse {T[]} - [$type]\n         *\n         * @name Phaser.Structs.ProcessQueue#_destroy\n         * @type {Array.<*>}\n         * @private\n         * @default []\n         * @since 3.0.0\n         */\n        this._destroy = [];\n        /**\n         * The total number of items awaiting processing.\n         *\n         * @name Phaser.Structs.ProcessQueue#_toProcess\n         * @type {number}\n         * @private\n         * @default 0\n         * @since 3.0.0\n         */\n        this._toProcess = 0;\n        /**\n         * If `true` only unique objects will be allowed in the queue.\n         *\n         * @name Phaser.Structs.ProcessQueue#checkQueue\n         * @type {boolean}\n         * @since 3.50.0\n         */\n        this.checkQueue = false;\n    }\n    /**\n     * Adds a new item to the Process Queue.\n     *\n     * The item is added to the pending list and made active in the next update.\n     *\n     * @method Phaser.Structs.ProcessQueue#add\n     * @since 3.0.0\n     *\n     * @genericUse {T} - [item]\n     * @genericUse {Phaser.Structs.ProcessQueue.<T>} - [$return]\n     *\n     * @param {*} item - The item to add to the queue.\n     *\n     * @return {*} The item that was added.\n     */\n    add(item) {\n        this._pending.push(item);\n        this._toProcess++;\n        return item;\n    }\n    /**\n     * Removes an item from the Process Queue.\n     *\n     * The item is added to the pending destroy and fully removed in the next update.\n     *\n     * @method Phaser.Structs.ProcessQueue#remove\n     * @since 3.0.0\n     *\n     * @genericUse {T} - [item]\n     * @genericUse {Phaser.Structs.ProcessQueue.<T>} - [$return]\n     *\n     * @param {*} item - The item to be removed from the queue.\n     *\n     * @return {*} The item that was removed.\n     */\n    remove(item) {\n        this._destroy.push(item);\n        this._toProcess++;\n        return item;\n    }\n    /**\n     * Removes all active items from this Process Queue.\n     *\n     * All the items are marked as 'pending destroy' and fully removed in the next update.\n     *\n     * @method Phaser.Structs.ProcessQueue#removeAll\n     * @since 3.20.0\n     *\n     * @return {this} This Process Queue object.\n     */\n    removeAll() {\n        var list = this._active;\n        var destroy = this._destroy;\n        var i = list.length;\n        while (i--) {\n            destroy.push(list[i]);\n            this._toProcess++;\n        }\n        return this;\n    }\n    /**\n     * Update this queue. First it will process any items awaiting destruction, and remove them.\n     *\n     * Then it will check to see if there are any items pending insertion, and move them to an\n     * active state. Finally, it will return a list of active items for further processing.\n     *\n     * @method Phaser.Structs.ProcessQueue#update\n     * @since 3.0.0\n     *\n     * @genericUse {T[]} - [$return]\n     *\n     * @return {Array.<*>} A list of active items.\n     */\n    update() {\n        if (this._toProcess === 0) {\n            //  Quick bail\n            return this._active;\n        }\n        var list = this._destroy;\n        var active = this._active;\n        var i;\n        var item;\n        //  Clear the 'destroy' list\n        for (i = 0; i < list.length; i++) {\n            item = list[i];\n            //  Remove from the 'active' array\n            var idx = active.indexOf(item);\n            if (idx !== -1) {\n                active.splice(idx, 1);\n                this.emit(events_1.default.PROCESS_QUEUE_REMOVE, item);\n            }\n        }\n        list.length = 0;\n        //  Process the pending addition list\n        //  This stops callbacks and out of sync events from populating the active array mid-way during an update\n        list = this._pending;\n        for (i = 0; i < list.length; i++) {\n            item = list[i];\n            if (!this.checkQueue || (this.checkQueue && active.indexOf(item) === -1)) {\n                active.push(item);\n                this.emit(events_1.default.PROCESS_QUEUE_ADD, item);\n            }\n        }\n        list.length = 0;\n        this._toProcess = 0;\n        //  The owner of this queue can now safely do whatever it needs to with the active list\n        return active;\n    }\n    /**\n     * Returns the current list of active items.\n     *\n     * This method returns a reference to the active list array, not a copy of it.\n     * Therefore, be careful to not modify this array outside of the ProcessQueue.\n     *\n     * @method Phaser.Structs.ProcessQueue#getActive\n     * @since 3.0.0\n     *\n     * @genericUse {T[]} - [$return]\n     *\n     * @return {Array.<*>} A list of active items.\n     */\n    getActive() {\n        return this._active;\n    }\n    /**\n     * The number of entries in the active list.\n     *\n     * @name Phaser.Structs.ProcessQueue#length\n     * @type {number}\n     * @readonly\n     * @since 3.20.0\n     */\n    get length() {\n        return this._active.length;\n    }\n    /**\n     * Immediately destroys this process queue, clearing all of its internal arrays and resetting the process totals.\n     *\n     * @method Phaser.Structs.ProcessQueue#destroy\n     * @since 3.0.0\n     */\n    destroy() {\n        this._toProcess = 0;\n        this._pending = [];\n        this._active = [];\n        this._destroy = [];\n    }\n}\nexports.ProcessQueue = ProcessQueue;\n//# sourceMappingURL=ProcessQueue.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.World = void 0;\nconst BetweenPoints_1 = __importDefault(require(\"../../math/angle/BetweenPoints\"));\nconst Clamp_1 = __importDefault(require(\"../../math/Clamp\"));\nconst DistanceBetween_1 = __importDefault(require(\"../../math/distance/DistanceBetween\"));\nconst eventemitter3_1 = __importDefault(require(\"eventemitter3\"));\nconst events_1 = __importDefault(require(\"./events\"));\nconst Equal_1 = __importDefault(require(\"../../math/fuzzy/Equal\"));\nconst GreaterThan_1 = __importDefault(require(\"../../math/fuzzy/GreaterThan\"));\nconst LessThan_1 = __importDefault(require(\"../../math/fuzzy/LessThan\"));\nconst GetOverlapX_1 = require(\"./GetOverlapX\");\nconst GetOverlapY_1 = require(\"./GetOverlapY\");\nconst GetValue_1 = __importDefault(require(\"../../utils/object/GetValue\"));\nconst RTree_1 = __importDefault(require(\"../../structs/RTree\"));\nconst Rectangle_1 = require(\"../../geom/rectangle/Rectangle\");\nconst SeparateX_1 = require(\"./SeparateX\");\nconst SeparateY_1 = require(\"./SeparateY\");\nconst Wrap_1 = __importDefault(require(\"../../math/Wrap\"));\nconst const_1 = __importDefault(require(\"./const\"));\nconst const_2 = __importDefault(require(\"../../math/const\"));\nconst Collider_1 = require(\"./Collider\");\nconst ProcessQueue_1 = require(\"../../structs/ProcessQueue\");\nconst Vector2_1 = require(\"../../math/Vector2\");\nclass World extends eventemitter3_1.default {\n    /**\n     *  The Arcade Physics World.\n     *\n     * The World is responsible for creating, managing, colliding and updating all of the bodies within it.\n     *\n     * An instance of the World belongs to a Phaser.Scene and is accessed via the property `physics.world`.\n     *\n     * @param scene The Scene this simulation belongs to.\n     * @param config An Arcade Physics Configuration object.\n     */\n    constructor(scene, config) {\n        super();\n        this.scene = scene;\n        this.config = config;\n        /** Dynamic Bodies in this simulation. */\n        this.bodies = new Set();\n        /** Static Bodies in this simulation. */\n        this.staticBodies = new Set();\n        /** Static Bodies marked for deletion. */\n        this.pendingDestroy = new Set();\n        /** The amount of elapsed ms since the last frame. */\n        this._elapsed = 0;\n        /** This simulation's collision processors. */\n        this.colliders = new ProcessQueue_1.ProcessQueue();\n        /** Acceleration of Bodies due to gravity, in pixels per second.  */\n        this.gravity = new Vector2_1.Vector2((0, GetValue_1.default)(config, 'gravity.x', 0), (0, GetValue_1.default)(config, 'gravity.y', 0));\n        this.bounds = new Rectangle_1.Rectangle((0, GetValue_1.default)(config, 'x', 0), (0, GetValue_1.default)(config, 'y', 0), (0, GetValue_1.default)(config, 'width', scene.sys.scale.width), (0, GetValue_1.default)(config, 'height', scene.sys.scale.height));\n        /** The boundary edges that Bodies can collide with. */\n        this.checkCollision = {\n            up: (0, GetValue_1.default)(config, 'checkCollision.up', true),\n            down: (0, GetValue_1.default)(config, 'checkCollision.down', true),\n            left: (0, GetValue_1.default)(config, 'checkCollision.left', true),\n            right: (0, GetValue_1.default)(config, 'checkCollision.right', true)\n        };\n        /**\n         * The number of physics steps to be taken per second.\n         *\n         * This property is read-only. Use the `setFPS` method to modify it at run-time.\n         */\n        this.fps = (0, GetValue_1.default)(config, 'fps', 60);\n        /**\n         * Should Physics use a fixed update time-step (true) or sync to the render fps (false)?.\n         * False value of this property disables fps and timeScale properties.\n         */\n        this.fixedStep = (0, GetValue_1.default)(config, 'fixedStep', true);\n        /** Internal frame time value. */\n        this._frameTime = 1 / this.fps;\n        /** Internal frame time ms value. */\n        this._frameTimeMS = 1000 * this._frameTime;\n        /** The number of steps that took place in the last frame. */\n        this.stepsLastFrame = 0;\n        /**\n         * Scaling factor applied to the frame rate.\n         *\n         * - 1.0 = normal speed\n         * - 2.0 = half speed\n         * - 0.5 = double speed\n         */\n        this.timeScale = (0, GetValue_1.default)(config, 'timeScale', 1);\n        this.OVERLAP_BIAS = (0, GetValue_1.default)(config, 'overlapBias', 4);\n        /**\n         * The maximum absolute value of a Body's overlap with a tile that will result in separation on *each axis*.\n         * Larger values favor separation.\n         * Smaller values favor no separation.\n         * The optimum value may be similar to the tile size.\n         * @default 16\n         */\n        this.TILE_BIAS = (0, GetValue_1.default)(config, 'tileBias', 16);\n        /**\n         * Always separate overlapping Bodies horizontally before vertically.\n         * False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater.\n         * @default false\n         */\n        this.forceX = (0, GetValue_1.default)(config, 'forceX', false);\n        /**\n         * Whether the simulation advances with the game loop.\n         * @default false\n         */\n        this.isPaused = (0, GetValue_1.default)(config, 'isPaused', false);\n        /**\n         * Temporary total of colliding Bodies.\n         * @default 0\n         */\n        this._total = 0;\n        /**\n         * Enables the debug display.\n         * @default false\n         */\n        this.drawDebug = (0, GetValue_1.default)(config, 'debug', false);\n        /**\n         * The graphics object drawing the debug display.\n         *\n         * @name Phaser.Physics.Arcade.World#debugGraphic\n         * @type {Phaser.GameObjects.Graphics}\n         * @since 3.0.0\n         */\n        this.debugGraphic;\n        this.defaults = {\n            debugShowBody: (0, GetValue_1.default)(config, 'debugShowBody', true),\n            debugShowStaticBody: (0, GetValue_1.default)(config, 'debugShowStaticBody', true),\n            debugShowVelocity: (0, GetValue_1.default)(config, 'debugShowVelocity', true),\n            bodyDebugColor: (0, GetValue_1.default)(config, 'debugBodyColor', 0xff00ff),\n            staticBodyDebugColor: (0, GetValue_1.default)(config, 'debugStaticBodyColor', 0x0000ff),\n            velocityDebugColor: (0, GetValue_1.default)(config, 'debugVelocityColor', 0x00ff00)\n        };\n        /**\n         * The maximum number of items per node on the RTree.\n         *\n         * This is ignored if `useTree` is `false`. If you have a large number of bodies in\n         * your world then you may find search performance improves by increasing this value,\n         * to allow more items per node and less node division.\n         *\n         * @name Phaser.Physics.Arcade.World#maxEntries\n         * @type {number}\n         * @default 16\n         * @since 3.0.0\n         */\n        this.maxEntries = (0, GetValue_1.default)(config, 'maxEntries', 16);\n        /**\n         * Should this Arcade Physics World use an RTree for Dynamic bodies?\n         *\n         * An RTree is a fast way of spatially sorting of all the bodies in the world.\n         * However, at certain limits, the cost of clearing and inserting the bodies into the\n         * tree every frame becomes more expensive than the search speed gains it provides.\n         *\n         * If you have a large number of dynamic bodies in your world then it may be best to\n         * disable the use of the RTree by setting this property to `false` in the physics config.\n         *\n         * The number it can cope with depends on browser and device, but a conservative estimate\n         * of around 5,000 bodies should be considered the max before disabling it.\n         *\n         * This only applies to dynamic bodies. Static bodies are always kept in an RTree,\n         * because they don't have to be cleared every frame, so you benefit from the\n         * massive search speeds all the time.\n         *\n         * @name Phaser.Physics.Arcade.World#useTree\n         * @type {boolean}\n         * @default true\n         * @since 3.10.0\n         */\n        this.useTree = (0, GetValue_1.default)(config, 'useTree', true);\n        /**\n         * The spatial index of Dynamic Bodies.\n         *\n         * @name Phaser.Physics.Arcade.World#tree\n         * @type {Phaser.Structs.RTree}\n         * @since 3.0.0\n         */\n        this.tree = new RTree_1.default(this.maxEntries);\n        /**\n         * The spatial index of Static Bodies.\n         *\n         * @name Phaser.Physics.Arcade.World#staticTree\n         * @type {Phaser.Structs.RTree}\n         * @since 3.0.0\n         */\n        this.staticTree = new RTree_1.default(this.maxEntries);\n        this.treeMinMax = { minX: 0, minY: 0, maxX: 0, maxY: 0 };\n        if (this.drawDebug) {\n            this.createDebugGraphic();\n        }\n    }\n    // /**\n    //  * Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group.\n    //  *\n    //  * The difference between this and the `enableBody` method is that you can pass arrays or Groups\n    //  * to this method.\n    //  *\n    //  * You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and\n    //  * acceleration. A static body remains fixed in place and as such is able to use an optimized search\n    //  * tree, making it ideal for static elements such as level objects. You can still collide and overlap\n    //  * with static bodies.\n    //  *\n    //  * Normally, rather than calling this method directly, you'd use the helper methods available in the\n    //  * Arcade Physics Factory, such as:\n    //  *\n    //  * ```javascript\n    //  * this.physics.add.image(x, y, textureKey);\n    //  * this.physics.add.sprite(x, y, textureKey);\n    //  * ```\n    //  *\n    //  * Calling factory methods encapsulates the creation of a Game Object and the creation of its\n    //  * body at the same time. If you are creating custom classes then you can pass them to this\n    //  * method to have their bodies created.\n    //  *\n    //  * @method Phaser.Physics.Arcade.World#enable\n    //  * @since 3.0.0\n    //  *\n    //  * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to create the bodies.\n    //  * @param {number} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\n    //  */\n    // enable(object, bodyType) {\n    //   if (bodyType === undefined) {\n    //     bodyType = CONST.DYNAMIC_BODY\n    //   }\n    //   if (!Array.isArray(object)) {\n    //     object = [object]\n    //   }\n    //   for (let i = 0; i < object.length; i++) {\n    //     let entry = object[i]\n    //     if (entry.isParent) {\n    //       let children = entry.getChildren()\n    //       for (let c = 0; c < children.length; c++) {\n    //         let child = children[c]\n    //         if (child.isParent) {\n    //           //  Handle Groups nested inside of Groups\n    //           this.enable(child, bodyType)\n    //         } else {\n    //           this.enableBody(child, bodyType)\n    //         }\n    //       }\n    //     } else {\n    //       this.enableBody(entry, bodyType)\n    //     }\n    //   }\n    // }\n    // /**\n    //  * Creates an Arcade Physics Body on a single Game Object.\n    //  *\n    //  * If the Game Object already has a body, this method will simply add it back into the simulation.\n    //  *\n    //  * You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and\n    //  * acceleration. A static body remains fixed in place and as such is able to use an optimized search\n    //  * tree, making it ideal for static elements such as level objects. You can still collide and overlap\n    //  * with static bodies.\n    //  *\n    //  * Normally, rather than calling this method directly, you'd use the helper methods available in the\n    //  * Arcade Physics Factory, such as:\n    //  *\n    //  * ```javascript\n    //  * this.physics.add.image(x, y, textureKey);\n    //  * this.physics.add.sprite(x, y, textureKey);\n    //  * ```\n    //  *\n    //  * Calling factory methods encapsulates the creation of a Game Object and the creation of its\n    //  * body at the same time. If you are creating custom classes then you can pass them to this\n    //  * method to have their bodies created.\n    //  *\n    //  * @method Phaser.Physics.Arcade.World#enableBody\n    //  * @since 3.0.0\n    //  *\n    //  * @param {Phaser.GameObjects.GameObject} object - The Game Object on which to create the body.\n    //  * @param {number} [bodyType] - The type of Body to create. Either `DYNAMIC_BODY` or `STATIC_BODY`.\n    //  *\n    //  * @return {Phaser.GameObjects.GameObject} The Game Object on which the body was created.\n    //  */\n    // enableBody(object, bodyType) {\n    //   if (bodyType === undefined) {\n    //     bodyType = CONST.DYNAMIC_BODY\n    //   }\n    //   if (!object.body) {\n    //     if (bodyType === CONST.DYNAMIC_BODY) {\n    //       object.body = new Body(this, object)\n    //     } else if (bodyType === CONST.STATIC_BODY) {\n    //       object.body = new StaticBody(this, object)\n    //     }\n    //   }\n    //   this.add(object.body)\n    //   return object\n    // }\n    /**\n     * Adds an existing Arcade Physics Body or StaticBody to the simulation.\n     *\n     * The body is enabled and added to the local search trees.\n     *\n     * @method Phaser.Physics.Arcade.World#add\n     * @since 3.10.0\n     *\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be added to the simulation.\n     *\n     * @return {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} The Body that was added to the simulation.\n     */\n    add(body) {\n        if (body.physicsType === const_1.default.PHYSICS_TYPE.DYNAMIC_BODY) {\n            this.bodies.add(body);\n            this.tree.insert(body);\n        }\n        else if (body.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY) {\n            this.staticBodies.add(body);\n            this.staticTree.insert(body);\n        }\n        body.enable = true;\n        return body;\n    }\n    /**\n     * Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group.\n     *\n     * The difference between this and the `disableBody` method is that you can pass arrays or Groups\n     * to this method.\n     *\n     * The body itself is not deleted, it just has its `enable` property set to false, which\n     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\n     *\n     * @method Phaser.Physics.Arcade.World#disable\n     * @since 3.0.0\n     *\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object - The object, or objects, on which to disable the bodies.\n     */\n    disable(object) {\n        if (!Array.isArray(object)) {\n            object = [object];\n        }\n        for (let i = 0; i < object.length; i++) {\n            const entry = object[i];\n            if (entry.isParent) {\n                const children = entry.getChildren();\n                for (let c = 0; c < children.length; c++) {\n                    const child = children[c];\n                    if (child.isParent) {\n                        //  Handle Groups nested inside of Groups\n                        this.disable(child);\n                    }\n                    else {\n                        this.disableBody(child.body);\n                    }\n                }\n            }\n            else {\n                this.disableBody(entry.body);\n            }\n        }\n    }\n    /**\n     * Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation.\n     *\n     * The body is disabled and removed from the local search trees.\n     *\n     * The body itself is not deleted, it just has its `enable` property set to false, which\n     * means you can re-enable it again at any point by passing it to enable `World.enable` or `World.add`.\n     *\n     * @method Phaser.Physics.Arcade.World#disableBody\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The Body to be disabled.\n     */\n    disableBody(body) {\n        this.remove(body);\n        body.enable = false;\n    }\n    /**\n     * Removes an existing Arcade Physics Body or StaticBody from the simulation.\n     *\n     * The body is disabled and removed from the local search trees.\n     *\n     * The body itself is not deleted, it just has its `enabled` property set to false, which\n     * means you can re-enable it again at any point by passing it to enable `enable` or `add`.\n     *\n     * @method Phaser.Physics.Arcade.World#remove\n     * @since 3.0.0\n     *\n     * @param {(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody)} body - The body to be removed from the simulation.\n     */\n    remove(body) {\n        if (body.physicsType === const_1.default.PHYSICS_TYPE.DYNAMIC_BODY) {\n            this.bodies.delete(body);\n            this.tree.remove(body);\n        }\n        else if (body.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY) {\n            this.staticBodies.delete(body);\n            this.staticTree.remove(body);\n        }\n    }\n    /**\n     * Creates a Graphics Game Object that the world will use to render the debug display to.\n     *\n     * This is called automatically when the World is instantiated if the `debug` config property\n     * was set to `true`. However, you can call it at any point should you need to display the\n     * debug Graphic from a fixed point.\n     *\n     * You can control which objects are drawn to the Graphics object, and the colors they use,\n     * by setting the debug properties in the physics config.\n     *\n     * You should not typically use this in a production game. Use it to aid during debugging.\n     *\n     * @method Phaser.Physics.Arcade.World#createDebugGraphic\n     * @since 3.0.0\n     *\n     * @return {Phaser.GameObjects.Graphics} The Graphics object that was created for use by the World.\n     */\n    createDebugGraphic() {\n        // let graphic = this.scene.sys.add.graphics({ x: 0, y: 0 })\n        // graphic.setDepth(Number.MAX_VALUE)\n        // this.debugGraphic = graphic\n        // this.drawDebug = true\n        // return graphic\n    }\n    /**\n     * Sets the position, size and properties of the World boundary.\n     *\n     * The World boundary is an invisible rectangle that defines the edges of the World.\n     * If a Body is set to collide with the world bounds then it will automatically stop\n     * when it reaches any of the edges. You can optionally set which edges of the boundary\n     * should be checked against.\n     *\n     * @method Phaser.Physics.Arcade.World#setBounds\n     * @since 3.0.0\n     *\n     * @param {number} x - The top-left x coordinate of the boundary.\n     * @param {number} y - The top-left y coordinate of the boundary.\n     * @param {number} width - The width of the boundary.\n     * @param {number} height - The height of the boundary.\n     * @param {boolean} [checkLeft] - Should bodies check against the left edge of the boundary?\n     * @param {boolean} [checkRight] - Should bodies check against the right edge of the boundary?\n     * @param {boolean} [checkUp] - Should bodies check against the top edge of the boundary?\n     * @param {boolean} [checkDown] - Should bodies check against the bottom edge of the boundary?\n     *\n     * @return {Phaser.Physics.Arcade.World} This World object.\n     */\n    setBounds(x, y, width, height, checkLeft, checkRight, checkUp, checkDown) {\n        this.bounds.setTo(x, y, width, height);\n        if (checkLeft !== undefined) {\n            this.setBoundsCollision(checkLeft, checkRight, checkUp, checkDown);\n        }\n        return this;\n    }\n    /**\n     * Enables or disables collisions on each edge of the World boundary.\n     *\n     * @method Phaser.Physics.Arcade.World#setBoundsCollision\n     * @since 3.0.0\n     *\n     * @param {boolean} [left=true] - Should bodies check against the left edge of the boundary?\n     * @param {boolean} [right=true] - Should bodies check against the right edge of the boundary?\n     * @param {boolean} [up=true] - Should bodies check against the top edge of the boundary?\n     * @param {boolean} [down=true] - Should bodies check against the bottom edge of the boundary?\n     *\n     * @return {Phaser.Physics.Arcade.World} This World object.\n     */\n    setBoundsCollision(left, right, up, down) {\n        if (left === undefined) {\n            left = true;\n        }\n        if (right === undefined) {\n            right = true;\n        }\n        if (up === undefined) {\n            up = true;\n        }\n        if (down === undefined) {\n            down = true;\n        }\n        this.checkCollision.left = left;\n        this.checkCollision.right = right;\n        this.checkCollision.up = up;\n        this.checkCollision.down = down;\n        return this;\n    }\n    /**\n     * Pauses the simulation.\n     *\n     * A paused simulation does not update any existing bodies, or run any Colliders.\n     *\n     * However, you can still enable and disable bodies within it, or manually run collide or overlap\n     * checks.\n     *\n     * @method Phaser.Physics.Arcade.World#pause\n     * @fires Phaser.Physics.Arcade.Events#PAUSE\n     * @since 3.0.0\n     *\n     * @return {Phaser.Physics.Arcade.World} This World object.\n     */\n    pause() {\n        this.isPaused = true;\n        this.emit(events_1.default.PAUSE);\n        return this;\n    }\n    /**\n     * Resumes the simulation, if paused.\n     *\n     * @method Phaser.Physics.Arcade.World#resume\n     * @fires Phaser.Physics.Arcade.Events#RESUME\n     * @since 3.0.0\n     *\n     * @return {Phaser.Physics.Arcade.World} This World object.\n     */\n    resume() {\n        this.isPaused = false;\n        this.emit(events_1.default.RESUME);\n        return this;\n    }\n    /**\n     * Creates a new Collider object and adds it to the simulation.\n     *\n     * A Collider is a way to automatically perform collision checks between two objects,\n     * calling the collide and process callbacks if they occur.\n     *\n     * Colliders are run as part of the World update, after all of the Bodies have updated.\n     *\n     * By creating a Collider you don't need then call `World.collide` in your `update` loop,\n     * as it will be handled for you automatically.\n     *\n     * @method Phaser.Physics.Arcade.World#addCollider\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.World#collide\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body1 - The first object to check for collision.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body2 - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\n     *\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\n     */\n    addCollider(body1, body2, collideCallback, processCallback, callbackContext) {\n        if (collideCallback === undefined) {\n            collideCallback = null;\n        }\n        if (processCallback === undefined) {\n            processCallback = null;\n        }\n        if (callbackContext === undefined) {\n            callbackContext = collideCallback;\n        }\n        const collider = new Collider_1.Collider(this, false, body1, body2, collideCallback, processCallback, callbackContext);\n        this.colliders.add(collider);\n        return collider;\n    }\n    /**\n     * Creates a new Overlap Collider object and adds it to the simulation.\n     *\n     * A Collider is a way to automatically perform overlap checks between two objects,\n     * calling the collide and process callbacks if they occur.\n     *\n     * Colliders are run as part of the World update, after all of the Bodies have updated.\n     *\n     * By creating a Collider you don't need then call `World.overlap` in your `update` loop,\n     * as it will be handled for you automatically.\n     *\n     * @method Phaser.Physics.Arcade.World#addOverlap\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body1 - The first object to check for overlap.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body2 - The second object to check for overlap.\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects overlap.\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects overlap. Must return a boolean.\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\n     *\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\n     */\n    addOverlap(body1, body2, collideCallback, processCallback, callbackContext) {\n        if (collideCallback === undefined) {\n            collideCallback = null;\n        }\n        if (processCallback === undefined) {\n            processCallback = null;\n        }\n        if (callbackContext === undefined) {\n            callbackContext = collideCallback;\n        }\n        const collider = new Collider_1.Collider(this, true, body1, body2, collideCallback, processCallback, callbackContext);\n        this.colliders.add(collider);\n        return collider;\n    }\n    /**\n     * Removes a Collider from the simulation so it is no longer processed.\n     *\n     * This method does not destroy the Collider. If you wish to add it back at a later stage you can call\n     * `World.colliders.add(Collider)`.\n     *\n     * If you no longer need the Collider you can call the `Collider.destroy` method instead, which will\n     * automatically clear all of its references and then remove it from the World. If you call destroy on\n     * a Collider you _don't_ need to pass it to this method too.\n     *\n     * @method Phaser.Physics.Arcade.World#removeCollider\n     * @since 3.0.0\n     *\n     * @param {Phaser.Physics.Arcade.Collider} collider - The Collider to remove from the simulation.\n     *\n     * @return {Phaser.Physics.Arcade.World} This World object.\n     */\n    removeCollider(collider) {\n        this.colliders.remove(collider);\n        return this;\n    }\n    /**\n     * Sets the frame rate to run the simulation at.\n     *\n     * The frame rate value is used to simulate a fixed update time step. This fixed\n     * time step allows for a straightforward implementation of a deterministic game state.\n     *\n     * This frame rate is independent of the frequency at which the game is rendering. The\n     * higher you set the fps, the more physics simulation steps will occur per game step.\n     * Conversely, the lower you set it, the less will take place.\n     *\n     * You can optionally advance the simulation directly yourself by calling the `step` method.\n     *\n     * @method Phaser.Physics.Arcade.World#setFPS\n     * @since 3.10.0\n     *\n     * @param {number} framerate - The frame rate to advance the simulation at.\n     *\n     * @return {this} This World object.\n     */\n    setFPS(framerate) {\n        this.fps = framerate;\n        this._frameTime = 1 / this.fps;\n        this._frameTimeMS = 1000 * this._frameTime;\n        return this;\n    }\n    /**\n     * Advances the simulation based on the elapsed time and fps rate.\n     *\n     * This is called automatically by your Scene and does not need to be invoked directly.\n     *\n     * @method Phaser.Physics.Arcade.World#update\n     * @fires Phaser.Physics.Arcade.Events#WORLD_STEP\n     * @since 3.0.0\n     *\n     * @param {number} time - The current timestamp as generated by the Request Animation Frame or SetTimeout.\n     * @param {number} delta - The delta time, in ms, elapsed since the last frame.\n     */\n    update(time, delta) {\n        if (this.isPaused || this.bodies.size === 0) {\n            return;\n        }\n        let i;\n        let fixedDelta = this._frameTime;\n        const msPerFrame = this._frameTimeMS * this.timeScale;\n        this._elapsed += delta;\n        //  Update all active bodies\n        let body;\n        const bodies = this.bodies;\n        //  Will a step happen this frame?\n        let willStep = this._elapsed >= msPerFrame;\n        if (!this.fixedStep) {\n            fixedDelta = delta * 0.001;\n            willStep = true;\n            this._elapsed = 0;\n        }\n        for (const body of bodies) {\n            if (body.enable) {\n                body.preUpdate(willStep, fixedDelta);\n            }\n        }\n        //  We know that a step will happen this frame, so let's bundle it all together to save branching and iteration costs\n        if (willStep) {\n            this._elapsed -= msPerFrame;\n            this.stepsLastFrame = 1;\n            //  Optionally populate our dynamic collision tree\n            if (this.useTree) {\n                this.tree.clear();\n                this.tree.load(Array.from(bodies));\n            }\n            //  Process any colliders\n            const colliders = this.colliders.update();\n            for (i = 0; i < colliders.length; i++) {\n                const collider = colliders[i];\n                if (collider.active) {\n                    collider.update();\n                }\n            }\n            this.emit(events_1.default.WORLD_STEP, fixedDelta);\n        }\n        //  Process any additional steps this frame\n        while (this._elapsed >= msPerFrame) {\n            this._elapsed -= msPerFrame;\n            this.step(fixedDelta);\n        }\n    }\n    /**\n     * Advances the simulation by a time increment.\n     *\n     * @method Phaser.Physics.Arcade.World#step\n     * @fires Phaser.Physics.Arcade.Events#WORLD_STEP\n     * @since 3.10.0\n     *\n     * @param {number} delta - The delta time amount, in seconds, by which to advance the simulation.\n     */\n    step(delta) {\n        //  Update all active bodies\n        let i;\n        let body;\n        const bodies = this.bodies;\n        const len = bodies.size;\n        for (const body of bodies) {\n            if (body.enable) {\n                body.update(delta);\n            }\n        }\n        //  Optionally populate our dynamic collision tree\n        if (this.useTree) {\n            this.tree.clear();\n            this.tree.load(Array.from(bodies));\n        }\n        //  Process any colliders\n        const colliders = this.colliders.update();\n        for (i = 0; i < colliders.length; i++) {\n            const collider = colliders[i];\n            if (collider.active) {\n                collider.update();\n            }\n        }\n        this.emit(events_1.default.WORLD_STEP, delta);\n        this.stepsLastFrame++;\n    }\n    /**\n     * Updates bodies, draws the debug display, and handles pending queue operations.\n     *\n     * @method Phaser.Physics.Arcade.World#postUpdate\n     * @since 3.0.0\n     */\n    postUpdate() {\n        let bodies = this.bodies;\n        let len;\n        const dynamic = this.bodies;\n        const staticBodies = this.staticBodies;\n        //  We don't need to postUpdate if there wasn't a step this frame\n        if (this.stepsLastFrame) {\n            this.stepsLastFrame = 0;\n            for (const body of bodies) {\n                if (body.enable) {\n                    body.postUpdate();\n                }\n            }\n        }\n        if (this.drawDebug) {\n            const graphics = this.debugGraphic;\n            graphics.clear();\n            for (const body of bodies) {\n                if (body.willDrawDebug()) {\n                    body.drawDebug(graphics);\n                }\n            }\n            bodies = staticBodies;\n            len = bodies.size;\n            for (const body of bodies) {\n                if (body.willDrawDebug()) {\n                    body.drawDebug(graphics);\n                }\n            }\n        }\n        const pending = this.pendingDestroy;\n        if (pending.size > 0) {\n            const dynamicTree = this.tree;\n            const staticTree = this.staticTree;\n            bodies = pending;\n            len = bodies.size;\n            for (const body of bodies) {\n                if (body.physicsType === const_1.default.PHYSICS_TYPE.DYNAMIC_BODY) {\n                    dynamicTree.remove(body);\n                    dynamic.delete(body);\n                }\n                else if (body.physicsType === const_1.default.PHYSICS_TYPE.STATIC_BODY) {\n                    staticTree.remove(body);\n                    staticBodies.delete(body);\n                }\n                // @ts-ignore\n                body.world = undefined;\n                // @ts-ignore\n                body.gameObject = undefined;\n            }\n            pending.clear();\n        }\n    }\n    /**\n     * Calculates a Body's velocity and updates its position.\n     *\n     * @method Phaser.Physics.Arcade.World#updateMotion\n     * @since 3.0.0\n     *\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to be updated.\n     * @param {number} delta - The delta value to be used in the motion calculations, in seconds.\n     */\n    updateMotion(body, delta) {\n        if (body.allowRotation) {\n            this.computeAngularVelocity(body, delta);\n        }\n        this.computeVelocity(body, delta);\n    }\n    /**\n     * Calculates a Body's angular velocity.\n     *\n     * @method Phaser.Physics.Arcade.World#computeAngularVelocity\n     * @since 3.10.0\n     *\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\n     * @param {number} delta - The delta value to be used in the calculation, in seconds.\n     */\n    computeAngularVelocity(body, delta) {\n        let velocity = body.angularVelocity;\n        const acceleration = body.angularAcceleration;\n        let drag = body.angularDrag;\n        const max = body.maxAngular;\n        if (acceleration) {\n            velocity += acceleration * delta;\n        }\n        else if (body.allowDrag && drag) {\n            drag *= delta;\n            if ((0, GreaterThan_1.default)(velocity - drag, 0, 0.1)) {\n                velocity -= drag;\n            }\n            else if ((0, LessThan_1.default)(velocity + drag, 0, 0.1)) {\n                velocity += drag;\n            }\n            else {\n                velocity = 0;\n            }\n        }\n        velocity = (0, Clamp_1.default)(velocity, -max, max);\n        const velocityDelta = velocity - body.angularVelocity;\n        body.angularVelocity += velocityDelta;\n        body.rotation += body.angularVelocity * delta;\n    }\n    /**\n     * Calculates a Body's per-axis velocity.\n     *\n     * @method Phaser.Physics.Arcade.World#computeVelocity\n     * @since 3.0.0\n     *\n     * @param {Phaser.Physics.Arcade.Body} body - The Body to compute the velocity for.\n     * @param {number} delta - The delta value to be used in the calculation, in seconds.\n     */\n    computeVelocity(body, delta) {\n        let velocityX = body.velocity.x;\n        const accelerationX = body.acceleration.x;\n        let dragX = body.drag.x;\n        const maxX = body.maxVelocity.x;\n        let velocityY = body.velocity.y;\n        const accelerationY = body.acceleration.y;\n        let dragY = body.drag.y;\n        const maxY = body.maxVelocity.y;\n        let speed = body.speed;\n        const maxSpeed = body.maxSpeed;\n        const allowDrag = body.allowDrag;\n        const useDamping = body.useDamping;\n        if (body.allowGravity) {\n            velocityX += (this.gravity.x + body.gravity.x) * delta;\n            velocityY += (this.gravity.y + body.gravity.y) * delta;\n        }\n        if (accelerationX) {\n            velocityX += accelerationX * delta;\n        }\n        else if (allowDrag && dragX) {\n            if (useDamping) {\n                //  Damping based deceleration\n                dragX = Math.pow(dragX, delta);\n                velocityX *= dragX;\n                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n                if ((0, Equal_1.default)(speed, 0, 0.001)) {\n                    velocityX = 0;\n                }\n            }\n            else {\n                //  Linear deceleration\n                dragX *= delta;\n                if ((0, GreaterThan_1.default)(velocityX - dragX, 0, 0.01)) {\n                    velocityX -= dragX;\n                }\n                else if ((0, LessThan_1.default)(velocityX + dragX, 0, 0.01)) {\n                    velocityX += dragX;\n                }\n                else {\n                    velocityX = 0;\n                }\n            }\n        }\n        if (accelerationY) {\n            velocityY += accelerationY * delta;\n        }\n        else if (allowDrag && dragY) {\n            if (useDamping) {\n                //  Damping based deceleration\n                dragY = Math.pow(dragY, delta);\n                velocityY *= dragY;\n                speed = Math.sqrt(velocityX * velocityX + velocityY * velocityY);\n                if ((0, Equal_1.default)(speed, 0, 0.001)) {\n                    velocityY = 0;\n                }\n            }\n            else {\n                //  Linear deceleration\n                dragY *= delta;\n                if ((0, GreaterThan_1.default)(velocityY - dragY, 0, 0.01)) {\n                    velocityY -= dragY;\n                }\n                else if ((0, LessThan_1.default)(velocityY + dragY, 0, 0.01)) {\n                    velocityY += dragY;\n                }\n                else {\n                    velocityY = 0;\n                }\n            }\n        }\n        velocityX = (0, Clamp_1.default)(velocityX, -maxX, maxX);\n        velocityY = (0, Clamp_1.default)(velocityY, -maxY, maxY);\n        body.velocity.set(velocityX, velocityY);\n        if (maxSpeed > -1 && speed > maxSpeed) {\n            body.velocity.normalize().scale(maxSpeed);\n            speed = maxSpeed;\n        }\n        body.speed = speed;\n    }\n    /**\n     * Separates two Bodies.\n     *\n     * @method Phaser.Physics.Arcade.World#separate\n     * @fires Phaser.Physics.Arcade.Events#COLLIDE\n     * @fires Phaser.Physics.Arcade.Events#OVERLAP\n     * @since 3.0.0\n     *\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\n     * @param {ArcadePhysicsCallback} [processCallback] - The process callback.\n     * @param {*} [callbackContext] - The context in which to invoke the callback.\n     * @param {boolean} [overlapOnly] - If this a collide or overlap check?\n     * @param {boolean} [intersects] - Assert that the bodies intersect and should not be tested before separation.\n     *\n     * @return {boolean} True if separation occurred, otherwise false.\n     */\n    separate(body1, body2, processCallback, callbackContext, overlapOnly, intersects) {\n        if ((!intersects && !body1.enable) ||\n            !body2.enable ||\n            body1.checkCollision.none ||\n            body2.checkCollision.none ||\n            !this.intersects(body1, body2)) {\n            return false;\n        }\n        //  They overlap. Is there a custom process callback? If it returns true then we can carry on, otherwise we should abort.\n        if (processCallback && processCallback.call(callbackContext, body1, body2) === false) {\n            return false;\n        }\n        //  Circle vs. Circle quick bail out\n        if (body1.isCircle && body2.isCircle) {\n            return this.separateCircle(body1, body2, overlapOnly);\n        }\n        // We define the behavior of bodies in a collision circle and rectangle\n        // If a collision occurs in the corner points of the rectangle, the body behave like circles\n        //  Either body1 or body2 is a circle\n        if (body1.isCircle !== body2.isCircle) {\n            const bodyRect = body1.isCircle ? body2 : body1;\n            const bodyCircle = body1.isCircle ? body1 : body2;\n            const rect = {\n                x: bodyRect.x,\n                y: bodyRect.y,\n                right: bodyRect.right,\n                bottom: bodyRect.bottom\n            };\n            const circle = bodyCircle.center;\n            if (circle.y < rect.y || circle.y > rect.bottom) {\n                if (circle.x < rect.x || circle.x > rect.right) {\n                    return this.separateCircle(body1, body2, overlapOnly);\n                }\n            }\n        }\n        let resultX = false;\n        let resultY = false;\n        //  Do we separate on x first or y first or both?\n        if (overlapOnly) {\n            //  No separation but we need to calculate overlapX, overlapY, etc.\n            resultX = (0, SeparateX_1.SeparateX)(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n            resultY = (0, SeparateY_1.SeparateY)(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n        }\n        else if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) {\n            resultX = (0, SeparateX_1.SeparateX)(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n            //  Are they still intersecting? Let's do the other axis then\n            if (this.intersects(body1, body2)) {\n                resultY = (0, SeparateY_1.SeparateY)(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n            }\n        }\n        else {\n            resultY = (0, SeparateY_1.SeparateY)(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n            //  Are they still intersecting? Let's do the other axis then\n            if (this.intersects(body1, body2)) {\n                resultX = (0, SeparateX_1.SeparateX)(body1, body2, overlapOnly, this.OVERLAP_BIAS);\n            }\n        }\n        const result = resultX || resultY;\n        if (result) {\n            if (overlapOnly) {\n                if (body1.onOverlap || body2.onOverlap) {\n                    this.emit(events_1.default.OVERLAP, body1, body2);\n                }\n            }\n            else if (body1.onCollide || body2.onCollide) {\n                this.emit(events_1.default.COLLIDE, body1, body2);\n            }\n        }\n        return result;\n    }\n    /**\n     * Separates two Bodies, when both are circular.\n     *\n     * @method Phaser.Physics.Arcade.World#separateCircle\n     * @fires Phaser.Physics.Arcade.Events#COLLIDE\n     * @fires Phaser.Physics.Arcade.Events#OVERLAP\n     * @since 3.0.0\n     *\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to be separated.\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to be separated.\n     * @param {boolean} [overlapOnly] - If this a collide or overlap check?\n     * @param {number} [bias] - A small value added to the calculations.\n     *\n     * @return {boolean} True if separation occurred, otherwise false.\n     */\n    separateCircle(body1, body2, overlapOnly, bias) {\n        //  Set the bounding box overlap values into the bodies themselves (hence we don't use the return values here)\n        (0, GetOverlapX_1.GetOverlapX)(body1, body2, false, bias);\n        (0, GetOverlapY_1.GetOverlapY)(body1, body2, false, bias);\n        let overlap = 0;\n        if (body1.isCircle !== body2.isCircle) {\n            const rect = {\n                x: body2.isCircle ? body1.position.x : body2.position.x,\n                y: body2.isCircle ? body1.position.y : body2.position.y,\n                right: body2.isCircle ? body1.right : body2.right,\n                bottom: body2.isCircle ? body1.bottom : body2.bottom\n            };\n            const circle = {\n                x: body1.isCircle ? body1.center.x : body2.center.x,\n                y: body1.isCircle ? body1.center.y : body2.center.y,\n                radius: body1.isCircle ? body1.halfWidth : body2.halfWidth\n            };\n            if (circle.y < rect.y) {\n                if (circle.x < rect.x) {\n                    overlap = (0, DistanceBetween_1.default)(circle.x, circle.y, rect.x, rect.y) - circle.radius;\n                }\n                else if (circle.x > rect.right) {\n                    overlap = (0, DistanceBetween_1.default)(circle.x, circle.y, rect.right, rect.y) - circle.radius;\n                }\n            }\n            else if (circle.y > rect.bottom) {\n                if (circle.x < rect.x) {\n                    overlap = (0, DistanceBetween_1.default)(circle.x, circle.y, rect.x, rect.bottom) - circle.radius;\n                }\n                else if (circle.x > rect.right) {\n                    overlap = (0, DistanceBetween_1.default)(circle.x, circle.y, rect.right, rect.bottom) - circle.radius;\n                }\n            }\n            overlap *= -1;\n        }\n        else {\n            overlap =\n                body1.halfWidth +\n                    body2.halfWidth -\n                    (0, DistanceBetween_1.default)(body1.center.x, body1.center.y, body2.center.x, body2.center.y);\n        }\n        body1.overlapR = overlap;\n        body2.overlapR = overlap;\n        //  Can't separate two immovable bodies, or a body with its own custom separation logic\n        if (overlapOnly ||\n            overlap === 0 ||\n            (body1.immovable && body2.immovable) ||\n            body1.customSeparateX ||\n            body2.customSeparateX) {\n            if (overlap !== 0 && (body1.onOverlap || body2.onOverlap)) {\n                this.emit(events_1.default.OVERLAP, body1, body2);\n            }\n            //  return true if there was some overlap, otherwise false\n            return overlap !== 0;\n        }\n        const dx = body1.center.x - body2.center.x;\n        const dy = body1.center.y - body2.center.y;\n        const d = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n        const nx = (body2.center.x - body1.center.x) / d || 0;\n        const ny = (body2.center.y - body1.center.y) / d || 0;\n        let p = (2 * (body1.velocity.x * nx + body1.velocity.y * ny - body2.velocity.x * nx - body2.velocity.y * ny)) /\n            (body1.mass + body2.mass);\n        if (body1.immovable || body2.immovable) {\n            p *= 2;\n        }\n        if (!body1.immovable) {\n            body1.velocity.x = body1.velocity.x - (p / body1.mass) * nx;\n            body1.velocity.y = body1.velocity.y - (p / body1.mass) * ny;\n        }\n        if (!body2.immovable) {\n            body2.velocity.x = body2.velocity.x + (p / body2.mass) * nx;\n            body2.velocity.y = body2.velocity.y + (p / body2.mass) * ny;\n        }\n        if (!body1.immovable && !body2.immovable) {\n            overlap /= 2;\n        }\n        // Note: This is inadequate for circle-rectangle separation\n        const angle = (0, BetweenPoints_1.default)(body1.center, body2.center);\n        const overlapX = (overlap + const_2.default.EPSILON) * Math.cos(angle);\n        const overlapY = (overlap + const_2.default.EPSILON) * Math.sin(angle);\n        if (!body1.immovable) {\n            body1.x -= overlapX;\n            body1.y -= overlapY;\n            body1.updateCenter();\n        }\n        if (!body2.immovable) {\n            body2.x += overlapX;\n            body2.y += overlapY;\n            body2.updateCenter();\n        }\n        body1.velocity.x *= body1.bounce.x;\n        body1.velocity.y *= body1.bounce.y;\n        body2.velocity.x *= body2.bounce.x;\n        body2.velocity.y *= body2.bounce.y;\n        if (body1.onCollide || body2.onCollide) {\n            this.emit(events_1.default.COLLIDE, body1, body2);\n        }\n        return true;\n    }\n    /**\n     * Checks to see if two Bodies intersect at all.\n     *\n     * @method Phaser.Physics.Arcade.World#intersects\n     * @since 3.0.0\n     *\n     * @param {Phaser.Physics.Arcade.Body} body1 - The first body to check.\n     * @param {Phaser.Physics.Arcade.Body} body2 - The second body to check.\n     *\n     * @return {boolean} True if the two bodies intersect, otherwise false.\n     */\n    intersects(body1, body2) {\n        if (body1 === body2)\n            return false;\n        if (!body1.isCircle && !body2.isCircle) {\n            //  Rect vs. Rect\n            return !(body1.right <= body2.position.x ||\n                body1.bottom <= body2.position.y ||\n                body1.position.x >= body2.right ||\n                body1.position.y >= body2.bottom);\n        }\n        else if (body1.isCircle) {\n            if (body2.isCircle) {\n                //  Circle vs. Circle\n                return ((0, DistanceBetween_1.default)(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <=\n                    body1.halfWidth + body2.halfWidth);\n            }\n            else {\n                //  Circle vs. Rect\n                return this.circleBodyIntersects(body1, body2);\n            }\n        }\n        else {\n            //  Rect vs. Circle\n            return this.circleBodyIntersects(body2, body1);\n        }\n    }\n    /**\n     * Tests if a circular Body intersects with another Body.\n     *\n     * @method Phaser.Physics.Arcade.World#circleBodyIntersects\n     * @since 3.0.0\n     *\n     * @param {Phaser.Physics.Arcade.Body} circle - The circular body to test.\n     * @param {Phaser.Physics.Arcade.Body} body - The rectangular body to test.\n     *\n     * @return {boolean} True if the two bodies intersect, otherwise false.\n     */\n    circleBodyIntersects(circle, body) {\n        const x = (0, Clamp_1.default)(circle.center.x, body.left, body.right);\n        const y = (0, Clamp_1.default)(circle.center.y, body.top, body.bottom);\n        const dx = (circle.center.x - x) * (circle.center.x - x);\n        const dy = (circle.center.y - y) * (circle.center.y - y);\n        return dx + dy <= circle.halfWidth * circle.halfWidth;\n    }\n    /**\n     * Tests if Game Objects overlap.\n     *\n     * See details in {@link Phaser.Physics.Arcade.World#collide}.\n     *\n     * @method Phaser.Physics.Arcade.World#overlap\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body1 - The first object or array of objects to check.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [body2] - The second object or array of objects to check, or `undefined`.\n     * @param {ArcadePhysicsCallback} [overlapCallback] - An optional callback function that is called if the objects overlap.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `overlapCallback` will only be called if this callback returns `true`.\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if at least one Game Object overlaps another.\n     *\n     * @see Phaser.Physics.Arcade.World#collide\n     */\n    overlap(body1, body2, overlapCallback, processCallback, callbackContext) {\n        if (overlapCallback === undefined) {\n            overlapCallback = null;\n        }\n        if (processCallback === undefined) {\n            processCallback = null;\n        }\n        if (callbackContext === undefined) {\n            callbackContext = overlapCallback;\n        }\n        return this.collideObjects(body1, body2, overlapCallback, processCallback, callbackContext, true);\n    }\n    /**\n     * Performs a collision check and separation between the two physics enabled objects given, which can be single\n     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\n     *\n     * If you don't require separation then use {@link Phaser.Physics.Arcade.World#overlap} instead.\n     *\n     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\n     *\n     * If **only** one Group is passed (as `body1`), each member of the Group will be collided against the other members.\n     *\n     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\n     *\n     * Two callbacks can be provided; they receive the colliding game objects as arguments.\n     * If an overlap is detected, the `processCallback` is called first. It can cancel the collision by returning false.\n     * Next the objects are separated and `collideCallback` is invoked.\n     *\n     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\n     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\n     * The separation that stops two objects penetrating may create a new penetration against a different object. If you\n     * require a high level of stability please consider using an alternative physics system, such as Matter.js.\n     *\n     * @method Phaser.Physics.Arcade.World#collide\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body1 - The first object or array of objects to check.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [body2] - The second object or array of objects to check, or `undefined`.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} `true` if any overlapping Game Objects were separated, otherwise `false`.\n     */\n    collide(body1, body2, collideCallback, processCallback, callbackContext) {\n        if (callbackContext === undefined) {\n            callbackContext = collideCallback;\n        }\n        return this.collideObjects(body1, body2, collideCallback, processCallback, callbackContext, false);\n    }\n    /**\n     * Internal helper function. Please use Phaser.Physics.Arcade.World#collide instead.\n     *\n     * @method Phaser.Physics.Arcade.World#collideObjects\n     * @private\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body1 - The first object to check for collision.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [body2] - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\n     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\n     * @param {any} callbackContext - The scope in which to call the callbacks.\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    collideObjects(body1, body2, collideCallback, processCallback, callbackContext, overlapOnly) {\n        let i;\n        let j;\n        // if (body1.isParent && body1.physicsType === undefined) {\n        //   body1 = body1.children.entries\n        // }\n        // if (body2 && body2.isParent && body2.physicsType === undefined) {\n        //   body2 = body2.children.entries\n        // }\n        const body1isArray = Array.isArray(body1);\n        const body2isArray = Array.isArray(body2);\n        this._total = 0;\n        if (!body1isArray && !body2isArray) {\n            //  Neither of them are arrays - do this first as it's the most common use-case\n            this.collideHandler(body1, body2, collideCallback, processCallback, callbackContext, overlapOnly);\n        }\n        else if (!body1isArray && body2isArray) {\n            //  Object 2 is an Array\n            for (i = 0; i < body2.length; i++) {\n                this.collideHandler(body1, body2[i], collideCallback, processCallback, callbackContext, overlapOnly);\n            }\n        }\n        else if (body1isArray && !body2isArray) {\n            //  Object 1 is an Array\n            if (!body2) {\n                //  Special case for array vs. self\n                for (i = 0; i < body1.length; i++) {\n                    const child = body1[i];\n                    for (j = i + 1; j < body1.length; j++) {\n                        if (i === j) {\n                            continue;\n                        }\n                        this.collideHandler(child, body1[j], collideCallback, processCallback, callbackContext, overlapOnly);\n                    }\n                }\n            }\n            else {\n                for (i = 0; i < body1.length; i++) {\n                    this.collideHandler(body1[i], body2, collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n            }\n        }\n        else if (body1isArray && body2isArray) {\n            //  They're both arrays\n            for (i = 0; i < body1.length; i++) {\n                for (j = 0; j < body2.length; j++) {\n                    this.collideHandler(body1[i], body2[j], collideCallback, processCallback, callbackContext, overlapOnly);\n                }\n            }\n        }\n        return this._total > 0;\n    }\n    /**\n     * Internal helper function. Please use Phaser.Physics.Arcade.World#collide and Phaser.Physics.Arcade.World#overlap instead.\n     *\n     * @method Phaser.Physics.Arcade.World#collideHandler\n     * @private\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body1 - The first object or array of objects to check.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} body2 - The second object or array of objects to check, or `undefined`.\n     * @param {ArcadePhysicsCallback} collideCallback - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} processCallback - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} callbackContext - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    collideHandler(body1, body2, collideCallback, processCallback, callbackContext, overlapOnly) {\n        //  Collide Group with Self\n        //  Only collide valid objects\n        // if (body2 === undefined && body1.isParent) {\n        //   return this.collideGroupVsGroup(body1, body1, collideCallback, processCallback, callbackContext, overlapOnly)\n        // }\n        //  If neither of the objects are set then bail out\n        if (!body1 || !body2)\n            return false;\n        // is body\n        if (!Array.isArray(body2) && body1.isBody && body2.isBody) {\n            return this.collideBodyVsBody(body1, body2, collideCallback, processCallback, callbackContext, overlapOnly);\n        }\n        //  A Body\n        /*if (body1.body) {\n          if (body2.body) {\n            return this.collideSpriteVsSprite(body1, body2, collideCallback, processCallback, callbackContext, overlapOnly)\n          } else if (body2.isParent) {\n            return this.collideSpriteVsGroup(body1, body2, collideCallback, processCallback, callbackContext, overlapOnly)\n          } else if (body2.isTilemap) {\n            return this.collideSpriteVsTilemapLayer(\n              body1,\n              body2,\n              collideCallback,\n              processCallback,\n              callbackContext,\n              overlapOnly\n            )\n          }\n        }*/\n        //  GROUPS\n        /*else if (body1.isParent) {\n          if (body2.body) {\n            return this.collideSpriteVsGroup(body2, body1, collideCallback, processCallback, callbackContext, overlapOnly)\n          } else if (body2.isParent) {\n            return this.collideGroupVsGroup(body1, body2, collideCallback, processCallback, callbackContext, overlapOnly)\n          } else if (body2.isTilemap) {\n            return this.collideGroupVsTilemapLayer(\n              body1,\n              body2,\n              collideCallback,\n              processCallback,\n              callbackContext,\n              overlapOnly\n            )\n          }\n        }*/\n        //  TILEMAP LAYERS\n        /*else if (body1.isTilemap) {\n          if (body2.body) {\n            return this.collideSpriteVsTilemapLayer(\n              body2,\n              body1,\n              collideCallback,\n              processCallback,\n              callbackContext,\n              overlapOnly\n            )\n          } else if (body2.isParent) {\n            return this.collideGroupVsTilemapLayer(\n              body2,\n              body1,\n              collideCallback,\n              processCallback,\n              callbackContext,\n              overlapOnly\n            )\n          }\n        }*/\n    }\n    /**\n     * Internal handler for Sprite vs. Sprite collisions.\n     * Please use Phaser.Physics.Arcade.World#collide instead.\n     *\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsSprite\n     * @private\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite1 - The first object to check for collision.\n     * @param {Phaser.GameObjects.GameObject} sprite2 - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // collideSpriteVsSprite(sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    //   if (!sprite1.body || !sprite2.body) {\n    //     return false\n    //   }\n    //   if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) {\n    //     if (collideCallback) {\n    //       collideCallback.call(callbackContext, sprite1, sprite2)\n    //     }\n    //     this._total++\n    //   }\n    //   return true\n    // }\n    collideBodyVsBody(body1, body2, collideCallback, processCallback, callbackContext, overlapOnly) {\n        if (!body1.isBody || !body2.isBody)\n            return false;\n        if (this.separate(body1, body2, processCallback, callbackContext, overlapOnly)) {\n            if (collideCallback) {\n                collideCallback.call(callbackContext, body1, body2);\n            }\n            this._total++;\n        }\n        return true;\n    }\n    /**\n     * Internal handler for Sprite vs. Group collisions.\n     * Please use Phaser.Physics.Arcade.World#collide instead.\n     *\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsGroup\n     * @private\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.GameObjects.Group} group - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} collideCallback - The callback to invoke when the two objects collide.\n     * @param {ArcadePhysicsCallback} processCallback - The callback to invoke when the two objects collide. Must return a boolean.\n     * @param {any} callbackContext - The scope in which to call the callbacks.\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\n     *\n     * @return {boolean} `true` if the Sprite collided with the given Group, otherwise `false`.\n     */\n    // collideSpriteVsGroup(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) {\n    //   let bodyA = sprite.body\n    //   if (group.length === 0 || !bodyA || !bodyA.enable || bodyA.checkCollision.none) {\n    //     return\n    //   }\n    //   //  Does sprite collide with anything?\n    //   let i\n    //   let len\n    //   let bodyB\n    //   if (this.useTree || group.physicsType === CONST.PHYSICS_TYPE.STATIC_BODY) {\n    //     let minMax = this.treeMinMax\n    //     minMax.minX = bodyA.left\n    //     minMax.minY = bodyA.top\n    //     minMax.maxX = bodyA.right\n    //     minMax.maxY = bodyA.bottom\n    //     let results =\n    //       group.physicsType === CONST.PHYSICS_TYPE.DYNAMIC_BODY\n    //         ? this.tree.search(minMax)\n    //         : this.staticTree.search(minMax)\n    //     len = results.length\n    //     for (i = 0; i < len; i++) {\n    //       bodyB = results[i]\n    //       if (bodyA === bodyB || !bodyB.enable || bodyB.checkCollision.none || !group.contains(bodyB.gameObject)) {\n    //         //  Skip if comparing against itself, or if bodyB isn't collidable, or if bodyB isn't actually part of the Group\n    //         continue\n    //       }\n    //       if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly, true)) {\n    //         if (collideCallback) {\n    //           collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject)\n    //         }\n    //         this._total++\n    //       }\n    //     }\n    //   } else {\n    //     let children = group.getChildren()\n    //     let skipIndex = group.children.entries.indexOf(sprite)\n    //     len = children.length\n    //     for (i = 0; i < len; i++) {\n    //       bodyB = children[i].body\n    //       if (!bodyB || i === skipIndex || !bodyB.enable) {\n    //         continue\n    //       }\n    //       if (this.separate(bodyA, bodyB, processCallback, callbackContext, overlapOnly)) {\n    //         if (collideCallback) {\n    //           collideCallback.call(callbackContext, bodyA.gameObject, bodyB.gameObject)\n    //         }\n    //         this._total++\n    //       }\n    //     }\n    //   }\n    // }\n    /**\n     * Internal handler for Group vs. Tilemap collisions.\n     * Please use Phaser.Physics.Arcade.World#collide instead.\n     *\n     * @method Phaser.Physics.Arcade.World#collideGroupVsTilemapLayer\n     * @private\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.Group} group - The first object to check for collision.\n     * @param {Phaser.Tilemaps.TilemapLayer} tilemapLayer - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} collideCallback - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} processCallback - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} callbackContext - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // collideGroupVsTilemapLayer(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {\n    // let children = group.getChildren()\n    // if (children.length === 0) {\n    //   return false\n    // }\n    // let didCollide = false\n    // for (let i = 0; i < children.length; i++) {\n    //   if (children[i].body) {\n    //     if (\n    //       this.collideSpriteVsTilemapLayer(\n    //         children[i],\n    //         tilemapLayer,\n    //         collideCallback,\n    //         processCallback,\n    //         callbackContext,\n    //         overlapOnly\n    //       )\n    //     ) {\n    //       didCollide = true\n    //     }\n    //   }\n    // }\n    // return didCollide\n    // }\n    /**\n     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\n     *\n     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\n     *\n     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\n     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\n     * you should filter them before passing them to this method.\n     *\n     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\n     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\n     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\n     * dynamic maps, this method can prove very useful.\n     *\n     * @method Phaser.Physics.Arcade.World#collideTiles\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\n     * @since 3.17.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {\n    // if (!sprite.body.enable || tiles.length === 0) {\n    //   return false\n    // } else {\n    //   return this.collideSpriteVsTilesHandler(\n    //     sprite,\n    //     tiles,\n    //     collideCallback,\n    //     processCallback,\n    //     callbackContext,\n    //     false,\n    //     false\n    //   )\n    // }\n    // }\n    /**\n     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\n     *\n     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\n     *\n     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\n     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\n     * you should filter them before passing them to this method.\n     *\n     * @method Phaser.Physics.Arcade.World#overlapTiles\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\n     * @since 3.17.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {\n    // if (!sprite.body.enable || tiles.length === 0) {\n    //   return false\n    // } else {\n    //   return this.collideSpriteVsTilesHandler(\n    //     sprite,\n    //     tiles,\n    //     collideCallback,\n    //     processCallback,\n    //     callbackContext,\n    //     true,\n    //     false\n    //   )\n    // }\n    // }\n    /**\n     * Internal handler for Sprite vs. Tilemap collisions.\n     * Please use Phaser.Physics.Arcade.World#collide instead.\n     *\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilemapLayer\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.Tilemaps.TilemapLayer} tilemapLayer - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // collideSpriteVsTilemapLayer(sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) {\n    // let body = sprite.body\n    // if (!body.enable || body.checkCollision.none) {\n    //   return false\n    // }\n    // let x = body.position.x\n    // let y = body.position.y\n    // let w = body.width\n    // let h = body.height\n    // let layerData = tilemapLayer.layer\n    // if (layerData.tileWidth > layerData.baseTileWidth) {\n    //   // The x origin of a tile is the left side, so x and width need to be adjusted.\n    //   let xDiff = (layerData.tileWidth - layerData.baseTileWidth) * tilemapLayer.scaleX\n    //   x -= xDiff\n    //   w += xDiff\n    // }\n    // if (layerData.tileHeight > layerData.baseTileHeight) {\n    //   // The y origin of a tile is the bottom side, so just the height needs to be adjusted.\n    //   let yDiff = (layerData.tileHeight - layerData.baseTileHeight) * tilemapLayer.scaleY\n    //   h += yDiff\n    // }\n    // let mapData = GetTilesWithinWorldXY(x, y, w, h, null, tilemapLayer.scene.cameras.main, tilemapLayer.layer)\n    // if (mapData.length === 0) {\n    //   return false\n    // } else {\n    //   return this.collideSpriteVsTilesHandler(\n    //     sprite,\n    //     mapData,\n    //     collideCallback,\n    //     processCallback,\n    //     callbackContext,\n    //     overlapOnly,\n    //     true\n    //   )\n    // }\n    // }\n    /**\n     * Internal handler for Sprite vs. Tilemap collisions.\n     * Please use Phaser.Physics.Arcade.World#collide instead.\n     *\n     * @method Phaser.Physics.Arcade.World#collideSpriteVsTilesHandler\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\n     * @private\n     * @since 3.17.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.Tilemaps.TilemapLayer} tilemapLayer - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     * @param {boolean} [overlapOnly] - Whether this is a collision or overlap check.\n     * @param {boolean} [isLayer] - Is this check coming from a TilemapLayer or an array of tiles?\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // collideSpriteVsTilesHandler(sprite, tiles, collideCallback, processCallback, callbackContext, overlapOnly, isLayer) {\n    //   let body = sprite.body\n    //   let tile\n    //   let tileWorldRect = { left: 0, right: 0, top: 0, bottom: 0 }\n    //   let tilemapLayer\n    //   let collision = false\n    //   for (let i = 0; i < tiles.length; i++) {\n    //     tile = tiles[i]\n    //     tilemapLayer = tile.tilemapLayer\n    //     let point = tilemapLayer.tileToWorldXY(tile.x, tile.y)\n    //     tileWorldRect.left = point.x\n    //     tileWorldRect.top = point.y\n    //     //  If the maps base tile size differs from the layer tile size, only the top of the rect\n    //     //  needs to be adjusted since its origin is (0, 1).\n    //     if (tile.baseHeight !== tile.height) {\n    //       tileWorldRect.top -= (tile.height - tile.baseHeight) * tilemapLayer.scaleY\n    //     }\n    //     tileWorldRect.right = tileWorldRect.left + tile.width * tilemapLayer.scaleX\n    //     tileWorldRect.bottom = tileWorldRect.top + tile.height * tilemapLayer.scaleY\n    //     if (\n    //       TileIntersectsBody(tileWorldRect, body) &&\n    //       (!processCallback || processCallback.call(callbackContext, sprite, tile)) &&\n    //       ProcessTileCallbacks(tile, sprite) &&\n    //       (overlapOnly || SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, this.TILE_BIAS, isLayer))\n    //     ) {\n    //       this._total++\n    //       collision = true\n    //       if (collideCallback) {\n    //         collideCallback.call(callbackContext, sprite, tile)\n    //       }\n    //       if (overlapOnly && body.onOverlap) {\n    //         this.emit(Events.TILE_OVERLAP, sprite, tile, body)\n    //       } else if (body.onCollide) {\n    //         this.emit(Events.TILE_COLLIDE, sprite, tile, body)\n    //       }\n    //     }\n    //   }\n    //   return collision\n    // }\n    /**\n     * Internal helper for Group vs. Group collisions.\n     * Please use Phaser.Physics.Arcade.World#collide instead.\n     *\n     * @method Phaser.Physics.Arcade.World#collideGroupVsGroup\n     * @private\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.Group} group1 - The first object to check for collision.\n     * @param {Phaser.GameObjects.Group} group2 - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     * @param {boolean} overlapOnly - Whether this is a collision or overlap check.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // collideGroupVsGroup(group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) {\n    //   if (group1.length === 0 || group2.length === 0) {\n    //     return\n    //   }\n    //   let children = group1.getChildren()\n    //   for (let i = 0; i < children.length; i++) {\n    //     this.collideSpriteVsGroup(children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly)\n    //   }\n    // }\n    /**\n     * Wrap an object's coordinates (or several objects' coordinates) within {@link Phaser.Physics.Arcade.World#bounds}.\n     *\n     * If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior).\n     *\n     * @method Phaser.Physics.Arcade.World#wrap\n     * @since 3.3.0\n     *\n     * @param {any} object - A Game Object, a Group, an object with `x` and `y` coordinates, or an array of such objects.\n     * @param {number} [padding=0] - An amount added to each boundary edge during the operation.\n     */\n    wrap(object, padding) {\n        if (object.body) {\n            this.wrapObject(object, padding);\n        }\n        else if (object.getChildren) {\n            this.wrapArray(object.getChildren(), padding);\n        }\n        else if (Array.isArray(object)) {\n            this.wrapArray(object, padding);\n        }\n        else {\n            this.wrapObject(object, padding);\n        }\n    }\n    /**\n     * Wrap each object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\n     *\n     * @method Phaser.Physics.Arcade.World#wrapArray\n     * @since 3.3.0\n     *\n     * @param {Array.<*>} objects - An array of objects to be wrapped.\n     * @param {number} [padding=0] - An amount added to the boundary.\n     */\n    wrapArray(objects, padding) {\n        for (let i = 0; i < objects.length; i++) {\n            this.wrapObject(objects[i], padding);\n        }\n    }\n    /**\n     * Wrap an object's coordinates within {@link Phaser.Physics.Arcade.World#bounds}.\n     *\n     * @method Phaser.Physics.Arcade.World#wrapObject\n     * @since 3.3.0\n     *\n     * @param {*} object - A Game Object, a Physics Body, or any object with `x` and `y` coordinates\n     * @param {number} [padding=0] - An amount added to the boundary.\n     */\n    wrapObject(object, padding) {\n        if (padding === undefined) {\n            padding = 0;\n        }\n        object.x = (0, Wrap_1.default)(object.x, this.bounds.left - padding, this.bounds.right + padding);\n        object.y = (0, Wrap_1.default)(object.y, this.bounds.top - padding, this.bounds.bottom + padding);\n    }\n    /**\n     * Shuts down the simulation, clearing physics data and removing listeners.\n     *\n     * @method Phaser.Physics.Arcade.World#shutdown\n     * @since 3.0.0\n     */\n    shutdown() {\n        this.tree.clear();\n        this.staticTree.clear();\n        this.bodies.clear();\n        this.staticBodies.clear();\n        this.colliders.destroy();\n        this.removeAllListeners();\n    }\n    /**\n     * Shuts down the simulation and disconnects it from the current scene.\n     *\n     * @method Phaser.Physics.Arcade.World#destroy\n     * @since 3.0.0\n     */\n    destroy() {\n        this.shutdown();\n        this.scene = null;\n    }\n}\nexports.World = World;\n//# sourceMappingURL=World.js.map","\"use strict\";\n/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2020 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArcadePhysics = void 0;\nconst DegToRad_1 = __importDefault(require(\"../../math/DegToRad\"));\nconst DistanceBetween_1 = __importDefault(require(\"../../math/distance/DistanceBetween\"));\nconst DistanceSquared_1 = __importDefault(require(\"../../math/distance/DistanceSquared\"));\nconst Factory_1 = require(\"./Factory\");\nconst OverlapCirc_1 = __importDefault(require(\"./components/OverlapCirc\"));\nconst OverlapRect_1 = __importDefault(require(\"./components/OverlapRect\"));\nconst Vector2_1 = require(\"../../math/Vector2\");\nconst World_1 = require(\"./World\");\n/**\n * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.\n * It also holds some useful methods for moving and rotating Arcade Physics Bodies.\n *\n * You can access it from within a Scene using `this.physics`.\n *\n * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\n * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\n * The separation that stops two objects penetrating may create a new penetration against a different object. If you\n * require a high level of stability please consider using an alternative physics system, such as Matter.js.\n *\n * @param {Phaser.Scene} scene - The Scene that this Plugin belongs to.\n */\nclass ArcadePhysics {\n    constructor(config) {\n        const scene = {\n            sys: {\n                scale: { width: config.width, height: config.height },\n                settings: {\n                    physics: config\n                }\n            }\n        };\n        /** The Scene that this Plugin belongs to. */\n        this.scene = scene;\n        /** The Scene's Systems. */\n        this.systems = scene.sys;\n        /** A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects. */\n        this.config = this.getConfig();\n        /** The physics simulation. */\n        this.world;\n        /** An object holding the Arcade Physics factory methods. */\n        this.add;\n        // scene.sys.events.once(SceneEvents.BOOT, this.boot, this)\n        // scene.sys.events.on(SceneEvents.START, this.start, this)\n        this.boot();\n    }\n    /**\n     * This method is called automatically, only once, when the Scene is first created.\n     * Do not invoke it directly.\n     */\n    boot() {\n        if (!this.world)\n            this.world = new World_1.World(this.scene, this.config);\n        if (!this.add)\n            this.add = new Factory_1.Factory(this.world);\n        // this.systems.events.once(SceneEvents.DESTROY, this.destroy, this)\n    }\n    /**\n     * This method is called automatically by the Scene when it is starting up.\n     * It is responsible for creating local systems, properties and listening for Scene events.\n     * Do not invoke it directly.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#start\n     * @private\n     * @since 3.5.0\n     */\n    start() {\n        if (!this.world) {\n            this.world = new World_1.World(this.scene, this.config);\n            this.add = new Factory_1.Factory(this.world);\n        }\n        const eventEmitter = this.systems.events;\n        // if (!GetFastValue(this.config, 'customUpdate', false)) {\n        //   eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world)\n        // }\n        // eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world)\n        // eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this)\n    }\n    /**\n     * Causes `World.update` to be automatically called each time the Scene\n     * emits and `UPDATE` event. This is the default setting, so only needs\n     * calling if you have specifically disabled it.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#enableUpdate\n     * @since 3.50.0\n     */\n    enableUpdate() {\n        // this.systems.events.on(SceneEvents.UPDATE, this.world.update, this.world)\n    }\n    /**\n     * Causes `World.update` to **not** be automatically called each time the Scene\n     * emits and `UPDATE` event.\n     *\n     * If you wish to run the World update at your own rate, or from your own\n     * component, then you should call this method to disable the built-in link,\n     * and then call `World.update(delta, time)` accordingly.\n     *\n     * Note that `World.postUpdate` is always automatically called when the Scene\n     * emits a `POST_UPDATE` event, regardless of this setting.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#disableUpdate\n     * @since 3.50.0\n     */\n    disableUpdate() {\n        // this.systems.events.off(SceneEvents.UPDATE, this.world.update, this.world)\n    }\n    /**\n     * Creates the physics configuration for the current Scene.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\n     * @since 3.0.0\n     *\n     * @return {Phaser.Types.Physics.Arcade.ArcadeWorldConfig} The physics configuration.\n     */\n    getConfig() {\n        var _a, _b, _c;\n        const gameConfig = ((_b = (_a = this.systems.game) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.physics) || {};\n        const sceneConfig = ((_c = this.systems.settings) === null || _c === void 0 ? void 0 : _c.physics) || {};\n        const config = Object.assign(Object.assign({}, gameConfig), sceneConfig);\n        return config;\n    }\n    /**\n     * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if at least one Game Object overlaps another.\n     *\n     * @see Phaser.Physics.Arcade.World#overlap\n     */\n    overlap(object1, object2, overlapCallback, processCallback, callbackContext) {\n        if (overlapCallback === undefined) {\n            overlapCallback = null;\n        }\n        if (processCallback === undefined) {\n            processCallback = null;\n        }\n        if (callbackContext === undefined) {\n            callbackContext = overlapCallback;\n        }\n        return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\n    }\n    /**\n     * Performs a collision check and separation between the two physics enabled objects given, which can be single\n     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\n     *\n     * If you don't require separation then use {@link #overlap} instead.\n     *\n     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\n     *\n     * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\n     *\n     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\n     *\n     * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\n     * objects are passed to it.\n     *\n     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\n     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\n     * The separation that stops two objects penetrating may create a new penetration against a different object. If you\n     * require a high level of stability please consider using an alternative physics system, such as Matter.js.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collide\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\n     *\n     * @see Phaser.Physics.Arcade.World#collide\n     */\n    collide(object1, object2, collideCallback, processCallback, callbackContext) {\n        if (collideCallback === undefined) {\n            collideCallback = null;\n        }\n        if (processCallback === undefined) {\n            processCallback = null;\n        }\n        if (callbackContext === undefined) {\n            callbackContext = collideCallback;\n        }\n        return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\n    }\n    /**\n     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\n     *\n     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\n     *\n     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\n     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\n     * you should filter them before passing them to this method.\n     *\n     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\n     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\n     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\n     * dynamic maps, this method can prove very useful.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collideTiles\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\n     * @since 3.17.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {\n    //   return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext)\n    // }\n    /**\n     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\n     *\n     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\n     *\n     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\n     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\n     * you should filter them before passing them to this method.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapTiles\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\n     * @since 3.17.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    // overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext) {\n    //   return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext)\n    // }\n    /**\n     * Pauses the simulation.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#pause\n     * @since 3.0.0\n     *\n     * @return {Phaser.Physics.Arcade.World} The simulation.\n     */\n    pause() {\n        return this.world.pause();\n    }\n    /**\n     * Resumes the simulation (if paused).\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#resume\n     * @since 3.0.0\n     *\n     * @return {Phaser.Physics.Arcade.World} The simulation.\n     */\n    resume() {\n        return this.world.resume();\n    }\n    /**\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\n     *\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\n     *\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n     * @param {number} x - The x coordinate to accelerate towards.\n     * @param {number} y - The y coordinate to accelerate towards.\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\n     *\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n     */\n    accelerateTo(gameObject, x, y, speed, xSpeedMax, ySpeedMax) {\n        if (speed === undefined) {\n            speed = 60;\n        }\n        const angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n        gameObject.body.acceleration.setToPolar(angle, speed);\n        if (xSpeedMax !== undefined && ySpeedMax !== undefined) {\n            gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);\n        }\n        return angle;\n    }\n    /**\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\n     *\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\n     *\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n     * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\n     *\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n     */\n    accelerateToObject(gameObject, destination, speed, xSpeedMax, ySpeedMax) {\n        return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);\n    }\n    /**\n     * Finds the Body or Game Object closest to a source point or object.\n     *\n     * If a `targets` argument is passed, this method finds the closest of those.\n     * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.\n     *\n     * If no `targets` argument is passed, this method finds the closest Dynamic Body.\n     *\n     * If two or more targets are the exact same distance from the source point, only the first target\n     * is returned.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#closest\n     * @since 3.0.0\n     *\n     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n     * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.\n     *\n     * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target closest to the given source point.\n     */\n    closest(source, targets = this.world.bodies) {\n        let min = Number.MAX_VALUE;\n        let closest = null;\n        const x = source.x;\n        const y = source.y;\n        const len = targets.size;\n        for (const target of targets) {\n            // @ts-ignore\n            const body = target.body || target;\n            if (source === target || source === body || source === body.gameObject || source === body.center) {\n                continue;\n            }\n            const distance = (0, DistanceSquared_1.default)(x, y, body.center.x, body.center.y);\n            if (distance < min) {\n                closest = target;\n                min = distance;\n            }\n        }\n        return closest;\n    }\n    /**\n     * Finds the Body or Game Object farthest from a source point or object.\n     *\n     * If a `targets` argument is passed, this method finds the farthest of those.\n     * The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies.\n     *\n     * If no `targets` argument is passed, this method finds the farthest Dynamic Body.\n     *\n     * If two or more targets are the exact same distance from the source point, only the first target\n     * is returned.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\n     * @since 3.0.0\n     *\n     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n     * @param {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[]|Phaser.GameObjects.GameObject[])} [targets] - The targets.\n     *\n     * @return {?(Phaser.Physics.Arcade.Body|Phaser.Physics.Arcade.StaticBody|Phaser.GameObjects.GameObject)} The target farthest from the given source point.\n     */\n    furthest(source, targets = this.world.bodies) {\n        let max = -1;\n        let farthest = null;\n        const x = source.x;\n        const y = source.y;\n        const len = targets.size;\n        for (const target of targets) {\n            // @ts-ignore\n            const body = target.body || target;\n            if (source === target || source === body || source === body.gameObject || source === body.center) {\n                continue;\n            }\n            const distance = (0, DistanceSquared_1.default)(x, y, body.center.x, body.center.y);\n            if (distance > max) {\n                farthest = target;\n                max = distance;\n            }\n        }\n        return farthest;\n    }\n    /**\n     * Move the given display object towards the x/y coordinates at a steady velocity.\n     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\n     * Timings are approximate due to the way browser timers work. Allow for a letiance of +- 50ms.\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n     * @param {number} x - The x coordinate to move towards.\n     * @param {number} y - The y coordinate to move towards.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n     *\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n     */\n    moveTo(body, x, y, speed = 60, maxTime = 0) {\n        const angle = Math.atan2(y - body.y, x - body.x);\n        if (maxTime > 0) {\n            //  We know how many pixels we need to move, but how fast?\n            speed = (0, DistanceBetween_1.default)(body.x, body.y, x, y) / (maxTime / 1000);\n        }\n        body.velocity.setToPolar(angle, speed);\n        return angle;\n    }\n    /**\n     * Move the given display object towards the destination object at a steady velocity.\n     * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\n     * Timings are approximate due to the way browser timers work. Allow for a letiance of +- 50ms.\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n     * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n     *\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n     */\n    moveToObject(body, destination, speed = 60, maxTime = 0) {\n        return this.moveTo(body, destination.x, destination.y, speed, maxTime);\n    }\n    /**\n     * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\n     * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\n     * @since 3.0.0\n     *\n     * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared.\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\n     *\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\n     */\n    velocityFromAngle(angle, speed, vec2) {\n        if (speed === undefined) {\n            speed = 60;\n        }\n        if (vec2 === undefined) {\n            vec2 = new Vector2_1.Vector2();\n        }\n        return vec2.setToPolar((0, DegToRad_1.default)(angle), speed);\n    }\n    /**\n     * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\n     * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\n     * @since 3.0.0\n     *\n     * @param {number} rotation - The angle in radians.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\n     *\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\n     */\n    velocityFromRotation(rotation, speed, vec2) {\n        if (speed === undefined) {\n            speed = 60;\n        }\n        if (vec2 === undefined) {\n            vec2 = new Vector2_1.Vector2();\n        }\n        return vec2.setToPolar(rotation, speed);\n    }\n    /**\n     * This method will search the given rectangular area and return an array of all physics bodies that\n     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\n     *\n     * A body only has to intersect with the search area to be considered, it doesn't have to be fully\n     * contained within it.\n     *\n     * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\n     * otherwise the search is O(N) for Dynamic Bodies.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapRect\n     * @since 3.17.0\n     *\n     * @param {number} x - The top-left x coordinate of the area to search within.\n     * @param {number} y - The top-left y coordinate of the area to search within.\n     * @param {number} width - The width of the area to search within.\n     * @param {number} height - The height of the area to search within.\n     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\n     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\n     *\n     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\n     */\n    overlapRect(x, y, width, height, includeDynamic = true, includeStatic = false) {\n        return (0, OverlapRect_1.default)(this.world, x, y, width, height, includeDynamic, includeStatic);\n    }\n    /**\n     * This method will search the given circular area and return an array of all physics bodies that\n     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\n     *\n     * A body only has to intersect with the search area to be considered, it doesn't have to be fully\n     * contained within it.\n     *\n     * If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,\n     * otherwise the search is O(N) for Dynamic Bodies.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapCirc\n     * @since 3.21.0\n     *\n     * @param {number} x - The x coordinate of the center of the area to search within.\n     * @param {number} y - The y coordinate of the center of the area to search within.\n     * @param {number} radius - The radius of the area to search within.\n     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\n     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\n     *\n     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\n     */\n    overlapCirc(x, y, radius, includeDynamic, includeStatic) {\n        return (0, OverlapCirc_1.default)(this.world, x, y, radius, includeDynamic, includeStatic);\n    }\n    /**\n     * The Scene that owns this plugin is shutting down.\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\n     * @since 3.0.0\n     */\n    shutdown() {\n        if (!this.world) {\n            //  Already destroyed\n            return;\n        }\n        const eventEmitter = this.systems.events;\n        // eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world)\n        // eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world)\n        // eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this)\n        this.add.destroy();\n        this.world.destroy();\n        // @ts-ignore\n        this.add = null;\n        // @ts-ignore\n        this.world = null;\n    }\n    /**\n     * The Scene that owns this plugin is being destroyed.\n     * We need to shutdown and then kill off all external references.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\n     * @since 3.0.0\n     */\n    destroy() {\n        this.shutdown();\n        // this.scene.sys.events.off(SceneEvents.START, this.start, this)\n        this.scene = null;\n        this.systems = null;\n    }\n}\nexports.ArcadePhysics = ArcadePhysics;\n//# sourceMappingURL=ArcadePhysics.js.map","import { Container, IApplication, Logger, Plugin } from 'dill-pixel';\n\nimport { ArcadePhysics } from 'arcade-physics/lib/physics/arcade/ArcadePhysics';\nimport { Body } from './Body';\nimport { Entity } from './Entity';\nimport { Graphics } from 'pixi.js';\n\nexport interface ArcadePhysicsPluginOptions {\n  fps?: number;\n  fixedStep?: boolean;\n  timeScale?: number;\n  gravity: { x: number; y: number };\n  y?: number;\n  width: number;\n  height: number;\n  checkCollision?: boolean;\n  tileBias?: number;\n  forceX?: boolean;\n  isPaused?: boolean;\n  debug?: boolean;\n  debugShowBody?: boolean;\n  debugShowStaticBody?: boolean;\n  debugShowVelocity?: boolean;\n  debugBodyColor?: number;\n  debugStaticBodyColor?: number;\n  debugVelocityColor?: number;\n  maxEntries?: number;\n  useTree?: boolean;\n  customUpdate?: boolean;\n}\n\nconst defaultOptions = {\n  debug: false,\n  gravity: { x: 0, y: 300 },\n};\n\nexport class ArcadePhysicsPlugin extends Plugin {\n  public static ID = 'ArcadePhysicsPlugin';\n  public container: Container;\n  public readonly id = 'ArcadePhysicsPlugin';\n  public options: ArcadePhysicsPluginOptions;\n  public physics: ArcadePhysics;\n  private _gfx: Graphics | null;\n\n  private _debug: boolean;\n\n  set debug(value: boolean) {\n    this._debug = value;\n    if (value) {\n      this.app.ticker.add(this._drawDebug);\n    } else {\n      this._gfx?.destroy();\n      this._gfx = null;\n      this.app.ticker.remove(this._drawDebug);\n    }\n  }\n\n  public async initialize(app: IApplication, options?: Partial<ArcadePhysicsPluginOptions>) {\n    ArcadePhysicsPlugin.ID = this.id;\n    this.options = { ...defaultOptions, width: app.size.width, height: app.size.height, ...options, debug: false };\n\n    Logger.log('ArcadePhysicsPlugin', 'initialize', this.options);\n    this.physics = new ArcadePhysics(this.options);\n\n    if (options?.debug) {\n      this.debug = true;\n    }\n  }\n\n  destroy() {\n    if (this._gfx) {\n      this._gfx.parent.removeChild(this._gfx);\n      this._gfx.destroy();\n    }\n    this.app.ticker.remove(this._drawDebug);\n\n    // destroy physics\n    this.physics.shutdown();\n    this.physics.destroy();\n\n    // @ts-expect-error can't be null\n    this.physics = null;\n\n    this._gfx = null;\n    this.debug = false;\n    super.destroy();\n  }\n\n  addBody(entity: Entity) {\n    if (!entity.body) {\n      Logger.error('ArcadePhysicsPlugin', 'addBody', 'Entity does not have a body');\n      return;\n    }\n    entity.body.entity = entity;\n  }\n\n  private _drawDebug() {\n    if (!this.container) {\n      return;\n    }\n    if (!this._gfx) {\n      this._gfx = new Graphics();\n      this.container.addChild(this._gfx);\n    }\n    this._gfx.clear();\n    if (!this.physics.world) {\n      return;\n    }\n    this.physics.world.bodies.forEach((body) => {\n      const entity = (body as Body).entity;\n      if (entity) {\n        const pos = entity.bodyPosition;\n        if (body.isCircle) {\n          this._gfx?.circle(pos.x + body.width * 0.5, pos.y + body.width * 0.5, body.width * 0.5);\n        } else {\n          this._gfx?.rect(pos.x, pos.y, body.width, body.height);\n        }\n      }\n    });\n    this._gfx.stroke({ width: 1, color: 0xff0000, alignment: 0.5 });\n    this.physics.world.staticBodies.forEach((body) => {\n      if (body.isCircle) {\n        this._gfx?.circle(body.x + body.width * 0.5, body.y + body.width * 0.5, body.width * 0.5);\n      } else {\n        this._gfx?.rect(body.x, body.y, body.width, body.height);\n      }\n    });\n    this._gfx.stroke({ width: 1, color: 0x00ff00, alignment: 0.5 });\n\n    this._gfx.rect(\n      this.physics.world.bounds.x,\n      this.physics.world.bounds.y,\n      this.physics.world.bounds.width,\n      this.physics.world.bounds.height,\n    );\n    this._gfx.stroke({ width: 1, color: 0xff0000, alignment: 0.5 });\n  }\n}\n","import { Constructor } from \"dill-pixel\";\nimport { Entity } from \"./Entity\";\n\n// mixin to add data accessor to bodies\n\nexport const HasEntity = <TBase extends Constructor>(Base: TBase) => {\n    return class extends Base {\n        _entity: Entity;\n\n        get entity(): Entity {\n            return this._entity;\n        }\n\n        set entity(value: Entity) {\n            this._entity = value;\n        }\n\n        constructor(...args: any[]) {\n            super(...args);\n        }\n    };\n};","import { Body as ArcadeBody } from 'arcade-physics/lib/physics/arcade/Body';\nimport { StaticBody as ArcadeStaticBody } from 'arcade-physics/lib/physics/arcade/StaticBody';\nimport { HasEntity } from './mixins';\n\nexport class Body extends HasEntity(ArcadeBody) {}\n\nexport class StaticBody extends HasEntity(ArcadeStaticBody) {}\n","import { Body, StaticBody } from './Body';\nimport { Bounds, Container as PIXIContainer, Point } from 'pixi.js';\n\nimport { ArcadePhysics } from 'arcade-physics/lib/physics/arcade/ArcadePhysics';\nimport { ArcadePhysicsPlugin } from './ArcadePhysicsPlugin';\nimport { Container } from 'dill-pixel';\nimport { World } from 'arcade-physics/lib/physics/arcade/World';\n\nexport interface IEntity {\n  readonly physics: ArcadePhysics;\n  readonly world: World;\n  body: Body | StaticBody;\n}\n\nexport type EntityType = 'actor' | 'solid';\n\nexport class Entity extends Container implements IEntity {\n  static pluginName: string = 'ArcadePhysicsPlugin';\n  type: EntityType = 'actor';\n  bodyType: 'circle' | 'rectangle' = 'rectangle';\n  body: Body | StaticBody;\n  bodyPosition: Point = new Point();\n  public offset: Point = new Point();\n  protected _cachedBounds: Bounds;\n\n  constructor() {\n    super({ autoUpdate: true, priority: 0, autoResize: false });\n  }\n\n  protected _view: PIXIContainer;\n\n  get view(): PIXIContainer {\n    return this._view;\n  }\n\n  set view(value: PIXIContainer) {\n    this._view = value;\n    this.updateBody();\n  }\n\n  get world(): World {\n    return this.physics.world;\n  }\n\n  get physics(): ArcadePhysics {\n    return this.app.getPlugin<ArcadePhysicsPlugin>(ArcadePhysicsPlugin.ID).physics;\n  }\n\n  get plugin(): ArcadePhysicsPlugin {\n    return this.app.getPlugin<ArcadePhysicsPlugin>(ArcadePhysicsPlugin.ID);\n  }\n\n  added() {\n    this.create();\n    this.postCreate();\n  }\n\n  public updateBody() {\n    if (!this.body) {\n      const bounds = this.getBoundingBox();\n      if (this.type === 'solid') {\n        this.body = this.physics.add.staticBody(\n          this.x + bounds.left,\n          this.y + bounds.top,\n          bounds.width,\n          bounds.height,\n        ) as StaticBody;\n      } else {\n        this.body = this.physics.add.body(\n          this.x + bounds.left,\n          this.y + bounds.top,\n          bounds.width,\n          bounds.height,\n        ) as Body;\n      }\n      if (this.bodyType === 'circle') {\n        this.body.setCircle(bounds.width * 0.5, 0, 0);\n      }\n    }\n  }\n\n  getBoundingBox() {\n    if (!this._cachedBounds) {\n      this._cachedBounds = this.getLocalBounds();\n      this._cachedBounds.scale(1 / this.plugin.container.worldTransform.d);\n    }\n    return this._cachedBounds;\n  }\n\n  update() {\n    if (!this.body || !this.view) {\n      return;\n    }\n\n    this.bodyPosition.x = this.body.x;\n    this.bodyPosition.y = this.body.y;\n\n    this.x = this.bodyPosition.x + this.getBoundingBox().width * 0.5 + this.offset.x;\n    this.y = this.bodyPosition.y + this.getBoundingBox().height * 0.5 + this.offset.y;\n\n    if (this.body instanceof Body) {\n      this.angle = this.body.rotation;\n    }\n  }\n\n  protected create() {\n    // create your body\n  }\n\n  protected postCreate() {\n    // add bodies to map\n    if (this.body) {\n      this.plugin.addBody(this);\n    }\n  }\n}\n","\"use strict\";\n/**\n * @author       Yannick Deubel (https://github.com/yandeu)\n * @copyright    Copyright (c) 2022 Yannick Deubel\n * @license      {@link https://opensource.org/licenses/MIT | MIT License}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArcadePhysics = void 0;\nvar ArcadePhysics_1 = require(\"./physics/arcade/ArcadePhysics\");\nObject.defineProperty(exports, \"ArcadePhysics\", { enumerable: true, get: function () { return ArcadePhysics_1.ArcadePhysics; } });\n//# sourceMappingURL=index.js.map"],"names":["_const","MATH_CONST","__importDefault","this","mod","DegToRad_1","const_1","require$$0","DegToRad","degrees","DistanceBetween_1","DistanceBetween","x1","y1","x2","y2","dx","dy","DistanceSquared_1","DistanceSquared","exports","PHYSICS_TYPE","FACING","events","Contains_1","Contains","rect","x","y","Perimeter_1","Perimeter","Class_1","hasGetterOrSetter","def","getProperty","definition","k","isClassDescriptor","hasNonConfigurable","obj","prop","extend","ctor","Class","mixin","myClass","mixins","i","initialize","Extends","base","GEOM_CONST","Point_1","require$$1","Point","GetPoint_1","GetPoint","rectangle","position","out","p","GetPoints_1","GetPoints","quantity","stepRate","line","Length_1","Length","Random_1","Random","t","Equal_1","Equal","a","b","epsilon","Vector2_1","FuzzyEqual","Vector2","src","azimuth","radius","v","angle","value","length","len","ax","ay","mat","m","max","normal","axis","delta","cos","sin","Line_1","require$$2","require$$3","require$$4","require$$5","Line","output","point","vec2","Rectangle_1","Rectangle","width","height","Body_1","Body_2","events_1","Body$1","world","clear","wasTouching","touching","blocked","willStep","vx","vy","mx","my","bounds","pos","check","bx","by","wasSet","ctx","_a","_b","defaultStrokeWidth","lineBetween","colorToHex","num","g","r","lineStyle","color","unknown","strokeCircle","bounceX","bounceY","onWorldBounds","setBounceX","setBounceY","left","right","up","down","Body","circle","StaticBody_1","StaticBody_2","Contains_2","StaticBody$1","offsetX","offsetY","strokeRect","w","h","StaticBody","Factory_1","Factory_2","Factory","body","staticBody","body1","body2","collideCallback","processCallback","callbackContext","OverlapRect_1","OverlapRect","includeDynamic","includeStatic","dynamicBodies","staticBodies","minMax","bodies","fakeBody","target","CircumferencePoint_1","CircumferencePoint","Clamp_1","Clamp","min","FromPercent_1","FromPercent","percent","Circumference_1","Circumference","u","Circle_1","Circle","CircleToCircle_1","CircleToCircle","circleA","circleB","CircleToRectangle_1","CircleToRectangle","halfWidth","halfHeight","cx","cy","xDist","yDist","xCornerDist","yCornerDist","xCornerDistSq","yCornerDistSq","maxCornerDistSq","OverlapCirc_1","OverlapCirc","bodiesInRect","area","circFromBody","bodiesInArea","BetweenPoints_1","BetweenPoints","point1","point2","has","prefix","Events","EE","fn","context","once","addListener","emitter","event","listener","evt","clearEvent","EventEmitter","names","name","handlers","l","ee","listeners","a1","a2","a3","a4","a5","args","j","module","GreaterThan_1","GreaterThan","LessThan_1","LessThan","GetOverlapX_1","GetOverlapX","overlapOnly","bias","overlap","maxOverlap","GetOverlapY_1","GetOverlapY","GetValue_1","GetValue","source","key","defaultValue","keys","parent","e","n","o","s","f","c","d","M","RTree_1","rbush_1","rbush","maxEntries","RTree","body1Pushable","body2Pushable","body1MassImpact","body2MassImpact","body1FullImpact","body2FullImpact","body1MovingLeft","body1MovingRight","body1Stationary","body2MovingLeft","body2MovingRight","body2Stationary","body1OnLeft","body2OnLeft","Set","b1","b2","ov","v1","v2","BlockCheck","Check","nv1","nv2","avg","Run","side","halfOverlap","RunImmovableBody1","blockedState","RunImmovableBody2","__createBinding","k2","desc","__setModuleDefault","__importStar","result","SeparateX_1","ProcessX","SeparateX","body1Immovable","body2Immovable","body1MovingUp","body1MovingDown","body2MovingUp","body2MovingDown","body1OnTop","body2OnTop","SeparateY_1","ProcessY","SeparateY","Wrap_1","Wrap","range","Collider_1","Collider_2","Collider","ProcessQueue_1","eventemitter3_1","ProcessQueue","item","list","destroy","active","idx","World_1","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14","require$$15","require$$16","const_2","require$$17","require$$18","require$$19","require$$20","World","scene","config","object","entry","children","child","checkLeft","checkRight","checkUp","checkDown","collider","framerate","time","fixedDelta","msPerFrame","colliders","dynamic","graphics","pending","dynamicTree","staticTree","velocity","acceleration","drag","velocityDelta","velocityX","accelerationX","dragX","maxX","velocityY","accelerationY","dragY","maxY","speed","maxSpeed","allowDrag","useDamping","intersects","bodyRect","bodyCircle","resultX","resultY","nx","ny","overlapX","overlapY","overlapCallback","body1isArray","body2isArray","padding","objects","ArcadePhysics_1","ArcadePhysics_2","ArcadePhysics","_c","gameConfig","sceneConfig","object1","object2","gameObject","xSpeedMax","ySpeedMax","destination","targets","closest","distance","farthest","maxTime","rotation","defaultOptions","_ArcadePhysicsPlugin","Plugin","app","options","Logger","entity","Graphics","ArcadePhysicsPlugin","HasEntity","Base","ArcadeBody","ArcadeStaticBody","_Entity","Container","Entity"],"mappings":"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AOC,CAAK,GAEtD,KAAK,WAEF;AAAA,EACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,61]}