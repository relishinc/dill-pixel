{"version":3,"file":"dill-pixel-plugin-snap-physics.mjs","sources":["../src/SpatialHashGrid.ts","../src/Entity.ts","../src/Solid.ts","../src/Wall.ts","../src/utils.ts","../src/System.ts","../src/SnapPhysicsPlugin.ts","../src/Actor.ts","../src/Sensor.ts"],"sourcesContent":["import { Graphics, Rectangle } from 'pixi.js';\nimport { Entity } from './Entity';\nimport { SpatialHashGridFilter } from './types';\nimport { System } from './System';\n\ntype GridKey = string;\n\nexport class SpatialHashGrid {\n  private cells: Map<GridKey, Set<Entity>> = new Map();\n\n  constructor(cellSize: number, insertEntities: boolean = false) {\n    this._cellSize = cellSize;\n    if (insertEntities) {\n      System.all.forEach((entity) => this.insert(entity));\n    }\n  }\n\n  private _cellSize: number;\n\n  get cellSize(): number {\n    return this._cellSize;\n  }\n\n  set cellSize(size: number) {\n    this._cellSize = size;\n    this.cells.clear();\n    this.updateAll();\n  }\n\n  destroy() {\n    this.cells.clear();\n  }\n\n  insert(entity: Entity): void {\n    const bounds = entity.getBoundingBox();\n\n    const startX = Math.floor(bounds.x / this._cellSize);\n    const startY = Math.floor(bounds.y / this._cellSize);\n    const endX = Math.floor((bounds.x + bounds.width) / this._cellSize);\n    const endY = Math.floor((bounds.y + bounds.height) / this._cellSize);\n\n    for (let x = startX; x <= endX; x++) {\n      for (let y = startY; y <= endY; y++) {\n        const key = this.getGridKey(x * this._cellSize, y * this._cellSize); // Use actual world coordinates\n        if (!this.cells.has(key)) {\n          this.cells.set(key, new Set());\n        }\n\n        this.cells.get(key)?.add(entity);\n      }\n    }\n  }\n\n  remove(entity: Entity): void {\n    this.cells.forEach((entities) => {\n      entities.delete(entity);\n    });\n  }\n\n  query(range: Rectangle, filter?: SpatialHashGridFilter | string[]): Entity[] {\n    const foundEntities = new Set<Entity>();\n\n    // Ensure we handle negative or reverse ranges appropriately\n    const startX = Math.floor(Math.min(range.x, range.x + range.width) / this._cellSize);\n    const startY = Math.floor(Math.min(range.y, range.y + range.height) / this._cellSize);\n    const endX = Math.floor(Math.max(range.x, range.x + range.width) / this._cellSize);\n    const endY = Math.floor(Math.max(range.y, range.y + range.height) / this._cellSize);\n\n    for (let x = startX; x <= endX; x++) {\n      for (let y = startY; y <= endY; y++) {\n        const key = this.getGridKey(x * this._cellSize, y * this._cellSize);\n\n        const cellEntities = this.cells.get(key);\n        if (cellEntities) {\n          cellEntities.forEach((entity) => {\n            if (filter !== undefined) {\n              if (Array.isArray(filter)) {\n                if (filter.includes(entity.type)) {\n                  foundEntities.add(entity);\n                }\n              } else {\n                if (filter(entity)) {\n                  foundEntities.add(entity);\n                }\n              }\n            } else {\n              foundEntities.add(entity);\n            }\n          });\n        }\n      }\n    }\n    return [...foundEntities];\n  }\n\n  updateAll() {\n    System.all.forEach((entity) => this.updateEntity(entity));\n  }\n\n  updateEntity(entity: Entity): void {\n    // Remove the entity from its current cell\n    this.remove(entity);\n\n    // Re-insert the entity into the grid based on its new position\n    this.insert(entity);\n  }\n\n  draw(gfx: Graphics) {\n    const rects = this._getDebugRects();\n    rects.forEach((rect) => {\n      gfx.rect(rect.left, rect.top, rect.width, rect.height);\n      gfx.stroke({ color: 0x00ff00 });\n    });\n  }\n\n  private _getDebugRects() {\n    const rects: Rectangle[] = [];\n    this.cells.forEach((_cell, key) => {\n      const [x, y] = key.split(':').map(Number);\n      if (_cell.size) {\n        rects.push(new Rectangle(x * this._cellSize, y * this._cellSize, this._cellSize, this._cellSize));\n      }\n    });\n    return rects;\n  }\n\n  private getGridKey(x: number, y: number): GridKey {\n    const cellX = Math.floor(x / this._cellSize);\n    const cellY = Math.floor(y / this._cellSize);\n    return `${cellX}:${cellY}`;\n  }\n}\n","import type { Container as PIXIContianer } from 'pixi.js';\nimport { Bounds, Rectangle, Sprite } from 'pixi.js';\nimport { Application, Container } from 'dill-pixel';\nimport { ICollider } from './ICollider';\nimport { System } from './System';\nimport { EntityType } from './types';\n\nexport class Entity<T = any, A extends Application = Application> extends Container<A> implements ICollider {\n  isActor: boolean = false;\n  isSolid: boolean = false;\n  isSensor: boolean = false;\n  debug: boolean = false;\n  debugColors = {\n    bounds: 0xff0000,\n    outerBounds: 0x00ff00,\n  };\n  type: EntityType = 'Solid';\n  view: PIXIContianer;\n  isCollideable: boolean = true;\n  xRemainder: number = 0;\n  yRemainder: number = 0;\n  config: T;\n\n  constructor(config?: Partial<T>) {\n    super();\n    this.config = config as T;\n  }\n\n  protected _cachedBounds: Bounds | Rectangle | null = null;\n\n  get cachedBounds(): Bounds | Rectangle {\n    if (!this._cachedBounds || this._dirtyBounds) {\n      const bounds = this.view.getBounds();\n      bounds.scale(1 / this.system.container.worldTransform.d);\n      this._cachedBounds = bounds;\n    }\n    return this._cachedBounds || new Rectangle();\n  }\n\n  set cachedBounds(value: Bounds) {\n    this._cachedBounds = value;\n  }\n\n  protected _dirtyBounds: boolean = true;\n\n  get dirtyBounds() {\n    return this._dirtyBounds;\n  }\n\n  set dirtyBounds(value: boolean) {\n    this._dirtyBounds = value;\n  }\n\n  get top(): number {\n    return this.getBoundingBox().top;\n  }\n\n  get bottom(): number {\n    return this.getBoundingBox().bottom;\n  }\n\n  get left(): number {\n    return this.getBoundingBox().left;\n  }\n\n  get right(): number {\n    return this.getBoundingBox().right;\n  }\n\n  get system(): typeof System {\n    return System;\n  }\n\n  get collideables(): Entity[] {\n    return [];\n  }\n\n  preUpdate() {}\n\n  update(deltaTime?: number) {\n    void deltaTime;\n  }\n\n  postUpdate() {}\n\n  getWorldBounds(): Bounds | Rectangle {\n    const pos = this.system.container.toLocal(this.view.getGlobalPosition());\n    const bounds = this.cachedBounds;\n    bounds.x = pos.x;\n    bounds.y = pos.y;\n\n    if (this.view instanceof Sprite && this.view.anchor) {\n      bounds.x -= this.view.width * this.view.anchor.x;\n      bounds.y -= this.view.height * this.view.anchor.y;\n    }\n\n    return bounds;\n  }\n\n  getBoundingBox(): Rectangle {\n    const bounds = this.getWorldBounds();\n    return bounds instanceof Bounds ? bounds.rectangle : bounds;\n  }\n\n  getOuterBoundingBox(): Rectangle | null {\n    return null;\n  }\n\n  // Simple collision detection between this solid and an actor\n  collidesWith(entity: Entity, dx: number = 0, dy: number = 0): boolean {\n    if (!entity) {\n      return false;\n    }\n    return System.getRectangleIntersection(entity, this, dx, dy);\n  }\n\n  protected initialize() {}\n}\n","import { Application } from 'dill-pixel';\nimport { Actor } from './Actor';\nimport { Entity } from './Entity';\nimport { System } from './System';\n\nexport class Solid<T = any, A extends Application = Application> extends Entity<T, A> {\n  type = 'Solid';\n  isSolid = true;\n\n  get collideables(): Entity[] {\n    return System.getNearbyEntities(this, (entity) => entity.isActor);\n  }\n\n  added() {\n    System.addSolid(this);\n  }\n\n  removed() {\n    System.removeSolid(this);\n  }\n\n  move(x: number, y: number): void {\n    this.xRemainder += x;\n    this.yRemainder += y;\n    const moveX = Math.round(this.xRemainder);\n    const moveY = Math.round(this.yRemainder);\n    const ridingActors = this.getAllRidingActors();\n    if (moveX !== 0 || moveY !== 0) {\n      // Temporarily make this solid non-collidable\n      this.isCollideable = false;\n      // Move on the Y axis\n      this.y += moveY;\n      this.yRemainder -= moveY;\n      this.handleActorInteractions(0, moveY, ridingActors);\n\n      // Move on the X axis\n      this.x += moveX;\n      this.xRemainder -= moveX;\n      this.handleActorInteractions(moveX, 0, ridingActors);\n\n      // Re-enable collisions\n      this.isCollideable = true;\n    }\n    System.updateEntity(this);\n  }\n\n  getAllRidingActors(): Actor[] {\n    // Implement logic to get all actors riding this solid\n    return (this.collideables as Actor[]).filter((actor: Actor) => {\n      return actor.riding.has(this);\n    });\n  }\n\n  public handleActorInteractions(\n    deltaX: number,\n    deltaY: number,\n    ridingActors: Actor[] = this.getAllRidingActors(),\n  ): void {\n    (this.collideables as Actor[]).forEach((actor) => {\n      if (ridingActors.includes(actor)) {\n        // Move riding actors along with this solid\n        if (actor.mostRiding === this) {\n          actor.moveY(deltaY);\n          actor.moveX(deltaX);\n        }\n      } else if (\n        !actor.passThroughTypes.includes(this.type) &&\n        !actor.isPassingThrough(this) &&\n        this.collidesWith(actor, deltaX, deltaY)\n      ) {\n        // Push actors only the minimum amount necessary to avoid overlap\n        const overlapX =\n          deltaX !== 0\n            ? deltaX > 0\n              ? this.getBoundingBox().right - actor.getBoundingBox().left\n              : this.getBoundingBox().left - actor.getBoundingBox().right\n            : 0;\n\n        if (overlapX !== 0) {\n          actor.moveX(overlapX, actor.squish, null, this);\n        }\n\n        const overlapY =\n          deltaY !== 0\n            ? deltaY > 0\n              ? this.getBoundingBox().bottom - actor.getBoundingBox().top\n              : this.getBoundingBox().top - actor.getBoundingBox().bottom\n            : 0;\n\n        if (overlapY !== 0) {\n          actor.moveY(overlapY, actor.squish, null, this);\n        }\n      }\n    });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected handleCollisionChange(_isColliding?: boolean) {}\n}\n","import { Texture } from 'pixi.js';\nimport { Solid as SnapSolid } from './Solid';\n\nexport type WallConfig = {\n  width: number;\n  height: number;\n  debugColor: number;\n};\n\nconst defaults: WallConfig = {\n  width: 10,\n  height: 10,\n  debugColor: 0x00ffff,\n};\n\nexport class Wall extends SnapSolid<WallConfig> {\n  type = 'Wall';\n\n  constructor(config: Partial<WallConfig> = {}) {\n    super({ ...defaults, ...config });\n    this.initialize();\n  }\n\n  protected initialize() {\n    this.view = this.add.sprite({\n      asset: Texture.WHITE,\n      width: this.config.width,\n      height: this.config.height,\n      tint: this.config.debugColor,\n      anchor: 0.5,\n    });\n  }\n}\n","import { Point, Rectangle } from 'pixi.js';\nimport { Entity } from './Entity';\nimport { ICollider } from './ICollider';\nimport { Collision } from './types';\n\nexport function checkPointIntersection(point: Point, collider: ICollider): boolean {\n  return point.x > collider.left && point.x < collider.right && point.y > collider.top && point.y < collider.bottom;\n}\n\ntype Overlap = {\n  x: number;\n  y: number;\n  area: number;\n};\n\nexport function getIntersectionArea(rectA: Rectangle, rectB: Rectangle): Overlap {\n  // Calculate the coordinates of the intersection rectangle\n  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n\n  // The area of the intersection is the product of overlapping width and height\n  return { x: xOverlap, y: yOverlap, area: xOverlap * yOverlap };\n}\n\nexport function checkCollision(\n  rectA: Rectangle,\n  rectB: Rectangle,\n  entity1: Entity,\n  entity2: Entity,\n): Collision | false {\n  const overlap: Collision = {\n    top: false,\n    bottom: false,\n    left: false,\n    right: false,\n    entity1,\n    entity2,\n    type: `${entity1?.type}|${entity2?.type}`,\n  };\n\n  if (rectA.intersects(rectB)) {\n    overlap.left = rectA.left < rectB.right && rectA.left > rectB.left;\n    overlap.right = rectA.right > rectB.left && rectA.right < rectB.right;\n    overlap.top = rectA.top < rectB.bottom && rectA.top > rectB.top;\n    overlap.bottom = rectA.bottom > rectB.top && rectA.bottom < rectB.bottom;\n    return overlap;\n  }\n  return false;\n}\n","import { Container, Graphics, Point, Ticker } from 'pixi.js';\nimport { IApplication, ICamera, Logger, Signal } from 'dill-pixel';\nimport { Actor } from './Actor';\nimport { Entity } from './Entity';\nimport { Sensor } from './Sensor';\nimport { Solid } from './Solid';\nimport { SpatialHashGrid } from './SpatialHashGrid';\nimport { Collision, EntityType, Side, SpatialHashGridFilter } from './types';\nimport { Wall } from './Wall';\nimport { getIntersectionArea } from './utils';\nimport { SnapPhysicsPlugin } from './SnapPhysicsPlugin';\n\ntype SystemBoundary = {\n  width: number;\n  height: number;\n  padding: number;\n};\n\ntype SnapPhysicsBoundaryOptions = {\n  width: number;\n  height: number;\n  thickness: number;\n  padding: number;\n  sides: Side[];\n};\ntype OptionalSnapPhysicsBoundaryOptions = Partial<SnapPhysicsBoundaryOptions>;\ntype RequiredWidthAndHeight = Required<Pick<SnapPhysicsBoundaryOptions, 'width' | 'height'>>;\ntype CustomSnapPhysicsBoundaryOptions = OptionalSnapPhysicsBoundaryOptions & RequiredWidthAndHeight;\n\ntype SnapPhysicsSystemOptions = {\n  gravity: number;\n  fps: number;\n  container: Container;\n  debug: boolean;\n  boundary: CustomSnapPhysicsBoundaryOptions;\n  collisionResolver: (collision: Collision) => boolean;\n  useSpatialHashGrid: boolean;\n  cellSize: number;\n};\n\nexport class System {\n  public static DEFAULT_COLLISION_THRESHOLD: number = 0;\n  public static plugin: SnapPhysicsPlugin;\n  public static app: IApplication;\n  public static container: Container<any>;\n  public static grid: SpatialHashGrid | null;\n  public static fps: number;\n  //\n  static debug: boolean = true;\n  static typeMap: Map<EntityType, Entity[]> = new Map();\n  static actors: Actor[] = [];\n  static solids: Solid[] = [];\n  static sensors: Sensor[] = [];\n  static gravity: number = 10;\n  static onCollision: Signal<(collision: Collision) => void> = new Signal<(collision: Collision) => void>();\n  static worldBounds: Wall[] = [];\n  static boundary: SystemBoundary;\n  static camera?: ICamera;\n  static collisionThreshold = 8;\n  static updateHooks: Set<(deltaTime: number) => void> = new Set();\n  static preUpdateHooks: Set<(deltaTime: number) => void> = new Set();\n  static postUpdateHooks: Set<(deltaTime: number) => void> = new Set();\n  private static gfx: Graphics;\n  private static _ticker: Ticker;\n\n  private static _enabled: boolean = false;\n\n  static get enabled() {\n    return System._enabled;\n  }\n\n  static set enabled(value: boolean) {\n    System._enabled = value;\n    if (System._enabled) {\n      if (!System._ticker) {\n        System._ticker = new Ticker();\n      }\n      System._ticker.maxFPS = System.fps;\n      System._ticker.start();\n      System._ticker.add(System.update);\n    } else {\n      if (System._ticker) {\n        System._ticker.stop();\n        System._ticker.destroy();\n        // @ts-expect-error ticker can't be null\n        System._ticker = null;\n      }\n    }\n  }\n\n  private static _collisionResolver: ((collision: Collision) => boolean) | null = null;\n\n  static set collisionResolver(collisionResolverMethod: (collision: Collision) => boolean) {\n    System._collisionResolver = collisionResolverMethod;\n  }\n\n  static get worldWidth() {\n    return System.boundary?.width ? System.boundary.width + (System.boundary.padding ?? 0) : System.container.width;\n  }\n\n  static get worldHeight() {\n    return System.boundary?.height ? System.boundary.height + (System.boundary.padding ?? 0) : System.container.height;\n  }\n\n  static get all(): Entity[] {\n    return [...System.actors, ...System.solids, ...System.sensors];\n  }\n\n  static get totalEntities(): number {\n    return System.actors.length + System.solids.length + System.sensors.length;\n  }\n\n  static useSpatialHashGrid(cellSize: number) {\n    if (System.grid) {\n      System.grid.cellSize = cellSize;\n    } else {\n      System.grid = new SpatialHashGrid(cellSize, true);\n    }\n    System.plugin.options.useSpatialHashGrid = true;\n  }\n\n  static removeSpatialHashGrid() {\n    if (System.grid) {\n      System.grid.destroy();\n      System.grid = null;\n    }\n  }\n\n  static resolveCollision(collision: Collision) {\n    // Implement collision resolution logic\n    return System._collisionResolver ? System._collisionResolver(collision) : true;\n  }\n\n  static addEntity(entity: Entity) {\n    if (!System.typeMap.has(entity.type)) {\n      System.typeMap.set(entity.type, []);\n    }\n    System.typeMap.get(entity.type)!.push(entity);\n\n    if (System.grid) {\n      System.grid.insert(entity);\n    }\n  }\n\n  static removeEntity(entity: Entity) {\n    if (System.grid) {\n      System.grid.remove(entity);\n    }\n    if (System.typeMap.has(entity.type)) {\n      const entities = System.typeMap.get(entity.type)!;\n      const index = entities.indexOf(entity);\n      if (index !== -1) {\n        entities.splice(index, 1);\n      }\n    }\n  }\n\n  static getEntitiesByType<T extends Entity = Entity>(...type: EntityType[]): T[] {\n    if (type.length === 0) {\n      return (System.typeMap.get(type[0]) as T[]) || [];\n    }\n    return type.reduce((acc: T[], t: EntityType) => {\n      const entities = System.typeMap.get(t) as T[];\n      if (entities?.length) {\n        return [...acc, ...entities];\n      }\n      return acc;\n    }, []);\n  }\n\n  static addActor(actor: Actor) {\n    System.actors.push(actor);\n    System.addEntity(actor);\n  }\n\n  static addSolid(solid: Solid) {\n    System.solids.push(solid);\n    System.addEntity(solid);\n  }\n\n  static addSensor(sensor: Sensor) {\n    System.sensors.push(sensor);\n    System.addEntity(sensor);\n  }\n\n  static removeActor(actor: Actor) {\n    System.removeEntity(actor);\n    const index = System.actors.indexOf(actor);\n    if (index !== -1) {\n      System.actors.splice(index, 1);\n    }\n  }\n\n  static removeSolid(solid: Solid) {\n    System.removeEntity(solid);\n    const index = System.solids.indexOf(solid);\n    if (index !== -1) {\n      System.solids.splice(index, 1);\n    }\n  }\n\n  static removeSensor(sensor: Sensor) {\n    System.removeEntity(sensor);\n    const index = System.sensors.indexOf(sensor);\n    if (index !== -1) {\n      System.sensors.splice(index, 1);\n    }\n  }\n\n  static getNearbyEntities(entity: Entity, onlyTypes?: string[]): Entity[];\n\n  static getNearbyEntities(entity: Entity, filter?: SpatialHashGridFilter): Entity[];\n\n  static getNearbyEntities(entity: Entity, filter?: SpatialHashGridFilter | string[]): Entity[] {\n    if (System.grid) {\n      const bounds = entity.getBoundingBox();\n      return System.grid.query(bounds, filter);\n    }\n    return System.all.filter((e: Entity) => {\n      if (filter) {\n        if (Array.isArray(filter)) {\n          return filter.includes(e.type);\n        } else {\n          return filter(e);\n        }\n      }\n      return true;\n    });\n  }\n\n  /**\n   * @param entity1\n   * @param entity2\n   * @param dx\n   * @param dy\n   */\n  static getRectangleIntersection(entity1: Entity, entity2: Entity, dx: number, dy: number): boolean {\n    const bounds1 = entity1.getBoundingBox();\n    const bounds2 = entity2.getBoundingBox().clone();\n    bounds2.x += dx;\n    bounds2.y += dy;\n    const intersection = getIntersectionArea(bounds1, bounds2);\n    return intersection.area > 0 && intersection.area > System.collisionThreshold;\n  }\n\n  static update(ticker: Ticker) {\n    if (!System.enabled) {\n      return;\n    }\n    const deltaTime = ticker.deltaTime;\n    if (!System.container) {\n      Logger.error('SnapPhysicsPlugin: World container not set!');\n    }\n\n    if (System.preUpdateHooks) {\n      System.preUpdateHooks.forEach((hook) => hook(deltaTime));\n    }\n    if (System.updateHooks) {\n      System.updateHooks.forEach((hook) => hook(deltaTime));\n    }\n\n    // Implement world step logic\n    System.all.forEach((entity: Entity) => {\n      entity.preUpdate();\n    });\n\n    System.solids.forEach((solid: Solid) => {\n      solid.update(deltaTime);\n    });\n    System.sensors.forEach((sensor: Sensor) => {\n      sensor.update(deltaTime);\n    });\n    System.actors.forEach((actor: Actor) => {\n      actor.update(deltaTime);\n    });\n\n    System.all.forEach((entity: Entity) => {\n      entity.postUpdate();\n    });\n\n    if (System.postUpdateHooks) {\n      System.postUpdateHooks.forEach((hook) => hook(deltaTime));\n    }\n\n    if (System.camera) {\n      System.camera.update();\n    }\n\n    if (System.debug) {\n      System.drawDebug();\n    } else {\n      if (System.gfx) {\n        System.gfx.clear();\n      }\n    }\n  }\n\n  static addBoundary(\n    width: number,\n    height: number,\n    size: number = 10,\n    padding: number = 5,\n    sides: Side[] = ['top', 'bottom', 'left', 'right'],\n  ) {\n    if (!System.container) {\n      throw new Error('System container not set. Set World.container before calling System.addBoundary().');\n    }\n    if (System.worldBounds.length > 0) {\n      // World bounds already added\n      // remove existing bounds\n      System.worldBounds.forEach((wall: Wall) => {\n        wall.parent.removeChild(wall);\n        wall.destroy();\n      });\n      System.worldBounds = [];\n    }\n    const pos = new Point(0, 0);\n    const container = System.container;\n    let wall: Wall;\n    if (sides.includes('bottom')) {\n      wall = container.addChild(new Wall({ width, height: size }));\n      wall.position.set(pos.x + width * 0.5, pos.y + height + padding);\n      System.worldBounds.push(wall);\n    }\n    if (sides.includes('top')) {\n      wall = container.addChild(new Wall({ width, height: size }));\n      wall.position.set(pos.x + width * 0.5, pos.y + size * 0.5);\n      System.worldBounds.push(wall);\n    }\n\n    if (sides.includes('left')) {\n      wall = container.addChild(new Wall({ width: size, height }));\n      wall.position.set(pos.x - size * 0.5 - padding, pos.y + height * 0.5 + size * 0.5);\n      System.worldBounds.push(wall);\n    }\n\n    if (sides.includes('right')) {\n      wall = container.addChild(new Wall({ width: size, height }));\n      wall.position.set(pos.x + width + padding + size * 0.5, pos.y + height * 0.5);\n      System.worldBounds.push(wall);\n    }\n\n    if (System.grid) {\n      System.worldBounds.forEach((wall: Wall) => {\n        System.grid?.remove(wall);\n        System.grid?.insert(wall);\n      });\n    }\n  }\n\n  static collide(collision: Collision) {\n    if (!collision.type && collision.entity1 && collision.entity2) {\n      collision.type = `${collision.entity1.type}|${collision.entity2.type}`;\n    }\n    this.onCollision.emit(collision);\n  }\n\n  static drawDebug() {\n    if (!System.container) {\n      return;\n    }\n    if (!System.gfx) {\n      System.gfx = new Graphics();\n      System.container.addChild(System.gfx);\n    }\n    // move to top\n    System.container.setChildIndex(System.gfx, System.container.children.length - 1);\n    System.gfx.clear();\n    [...System.actors, ...System.solids, ...System.sensors].forEach((entity: Entity) => {\n      const bounds = entity.getBoundingBox();\n      const outerBounds = entity.getOuterBoundingBox();\n      System.gfx\n        .rect(bounds.x, bounds.y, bounds.width, bounds.height)\n        .stroke({ width: 1, color: entity.debugColors.bounds, alignment: 0.5 });\n\n      if (outerBounds) {\n        System.gfx\n          .rect(outerBounds.x, outerBounds.y, outerBounds.width, outerBounds.height)\n          .stroke({ width: 1, color: entity.debugColors.outerBounds, alignment: 0.5 });\n      }\n    });\n\n    if (System.grid) {\n      System.grid.draw(System.gfx);\n    }\n  }\n\n  static setContainer(container: Container) {\n    System.container = container;\n  }\n\n  static initialize(opts: Partial<SnapPhysicsSystemOptions>) {\n    if (opts.gravity) {\n      System.gravity = opts.gravity;\n    }\n    if (opts.fps) {\n      System.fps = opts.fps;\n    }\n    if (opts.container) {\n      System.setContainer(opts.container);\n    }\n    if (opts.debug !== undefined) {\n      System.debug = opts.debug;\n    }\n    if (opts.collisionResolver) {\n      System.collisionResolver = opts.collisionResolver;\n    }\n    if (opts.boundary) {\n      System.boundary = {\n        width: opts.boundary.width,\n        height: opts.boundary.height,\n        padding: opts.boundary.padding ?? 0,\n      };\n      if (opts.boundary.width && opts.boundary.height) {\n        System.addBoundary(\n          opts.boundary.width,\n          opts.boundary.height,\n          opts.boundary.thickness,\n          opts.boundary.padding,\n          opts.boundary.sides,\n        );\n      } else {\n        Logger.error('SnapPhysicsPlugin System.initialize: Boundary width and height required.');\n      }\n    }\n\n    if (opts.useSpatialHashGrid) {\n      System.useSpatialHashGrid(opts.cellSize ?? 100);\n    }\n  }\n\n  static updateEntity(entity: Entity) {\n    if (System.grid) {\n      System.grid.updateEntity(entity);\n    }\n  }\n\n  static cleanup() {\n    System.enabled = false;\n    System.postUpdateHooks.clear();\n    System.preUpdateHooks.clear();\n    System.updateHooks.clear();\n    if (System.worldBounds) {\n      System.worldBounds.forEach((wall: Wall) => {\n        wall.parent.removeChild(wall);\n        wall.destroy();\n      });\n      System.worldBounds = [];\n    }\n\n    if (System.container) {\n      System.container.removeChildren();\n      // @ts-expect-error container can't be null\n      System.container = null;\n    }\n    if (System.gfx) {\n      System.gfx.clear();\n      // @ts-expect-error GFX can't be null\n      System.gfx = null;\n    }\n\n    if (System.grid) {\n      System.grid.destroy();\n      System.grid = null;\n    }\n\n    if (System.camera) {\n      // @ts-expect-error camera can't be null\n      System.camera = null;\n    }\n\n    System.solids = [];\n    System.actors = [];\n    System.sensors = [];\n    System.typeMap.clear();\n    System.worldBounds = [];\n  }\n}\n","import { IApplication, Plugin } from 'dill-pixel';\nimport { System } from './System';\n\ntype SnapPhysicsPluginOptions = {\n  useSpatialHashGrid: boolean;\n  gridCellSize: number;\n  fps: number;\n};\n\nconst defaultOptions = {\n  useSpatialHashGrid: false,\n  gridCellSize: -1,\n  fps: -1,\n};\n\nexport class SnapPhysicsPlugin extends Plugin {\n  public readonly id = 'SnapPhysicsPlugin';\n  public options: SnapPhysicsPluginOptions;\n\n  get gridCellSize(): number {\n    return this.options.gridCellSize;\n  }\n\n  set gridCellSize(value: number) {\n    this.options.gridCellSize = value;\n    if (this.options.useSpatialHashGrid && this.options.gridCellSize > 0) {\n      System.useSpatialHashGrid(this.options.gridCellSize);\n    }\n  }\n\n  get useSpatialHashGrid(): boolean {\n    return this.options.useSpatialHashGrid;\n  }\n\n  set useSpatialHashGrid(value: boolean) {\n    this.options.useSpatialHashGrid = value;\n\n    if (this.options.useSpatialHashGrid && this.options.gridCellSize > 0) {\n      System.useSpatialHashGrid(this.options.gridCellSize);\n    } else {\n      System.removeSpatialHashGrid();\n    }\n  }\n\n  set fps(value: number) {\n    this.options.fps = value;\n    System.fps = value;\n  }\n\n  public get system(): typeof System {\n    return System;\n  }\n\n  destroy() {\n    this.system.enabled = false;\n    System.cleanup();\n    super.destroy();\n  }\n\n  public async initialize(app: IApplication, options?: Partial<SnapPhysicsPluginOptions>) {\n    this.options = { ...defaultOptions, ...options };\n    this.system.app = app;\n    this.system.plugin = this;\n\n    if (this.options.useSpatialHashGrid && this.options.gridCellSize > 0) {\n      this.system.useSpatialHashGrid(this.options.gridCellSize);\n    }\n    if (this.options.fps > 0) {\n      System.fps = this.options.fps;\n    }\n  }\n}\n","import { Point, Rectangle } from 'pixi.js';\nimport { Application } from 'dill-pixel';\nimport { Entity } from './Entity';\nimport { System } from './System';\nimport { Collision, EntityType } from './types';\nimport { checkCollision } from './utils';\n\nexport class Actor<T = any, A extends Application = Application> extends Entity<T, A> {\n  type = 'Actor';\n  isActor = true;\n  passThroughTypes: EntityType[] = [];\n  passingThrough: Set<Entity> = new Set();\n  riding: Set<Entity> = new Set();\n  mostRiding: Entity | null = null;\n  protected _activeCollisions: Collision[];\n  get activeCollisions() {\n    return this._activeCollisions;\n  }\n\n  set activeCollisions(value) {\n    this._activeCollisions = value;\n  }\n\n  get ridingAllowed(): boolean {\n    return true;\n  }\n\n  get collideables(): Entity[] {\n    return System.getNearbyEntities(this, (e) => e.isSolid);\n  }\n\n  added() {\n    System.addActor(this);\n  }\n\n  removed() {\n    System.removeActor(this);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  squish(_collision?: Collision, _pushingEntity?: Entity, _direction?: Point) {}\n\n  postUpdate() {\n    // console.log('HIIHHIIH!', this.type);\n    this.setAllRiding();\n  }\n\n  moveX(\n    amount: number,\n    onCollide?: ((collision: Collision, pushingEntity?: Entity, direction?: Point) => void) | null,\n    onNoCollisions?: (() => void) | null,\n    pushingEntity?: Entity,\n  ): void {\n    this.xRemainder += amount;\n    let move = Math.round(this.xRemainder);\n    const sign = Math.sign(move);\n    if (pushingEntity) {\n      pushingEntity.isCollideable = false;\n    }\n    while (move !== 0) {\n      const nextX = this.x + (move ? sign : 0); // Predict the next X position\n      const collisions: Collision[] | false = this.collideAt(nextX - this.x, 0, this.getBoundingBox(), [\n        'left',\n        'right',\n      ]);\n      if (collisions) {\n        if (onCollide) {\n          collisions.forEach((collision) => {\n            onCollide(collision, pushingEntity, new Point(nextX - this.x, 0));\n          });\n        }\n        for (const collision of collisions) {\n          if (!this.isRiding(collision.entity2)) {\n            this.xRemainder = 0;\n          }\n        }\n        break;\n      } else {\n        this.x = nextX;\n        move -= sign;\n        this.xRemainder -= sign;\n        if (onNoCollisions) {\n          onNoCollisions();\n        }\n      }\n    }\n    System.updateEntity(this);\n    if (pushingEntity) {\n      pushingEntity.isCollideable = true;\n    }\n  }\n\n  moveY(\n    amount: number,\n    onCollide?: ((collision: Collision, pushingEntity?: Entity, direction?: Point) => void) | null,\n    onNoCollisions?: (() => void) | null,\n    pushingEntity?: Entity,\n  ): void {\n    this.yRemainder += amount;\n    let move = Math.round(this.yRemainder);\n    const sign = Math.sign(move);\n    if (pushingEntity) {\n      pushingEntity.isCollideable = false;\n    }\n\n    while (move !== 0) {\n      const nextY = this.y + (move ? sign : 0); // Predict the next Y position\n      const collisions: Collision[] | false = this.collideAt(0, nextY - this.y, this.getBoundingBox(), [\n        'top',\n        'bottom',\n      ]);\n      if (collisions) {\n        if (onCollide) {\n          collisions.forEach((collision) => onCollide(collision, pushingEntity, new Point(0, nextY - this.y)));\n        }\n        this.yRemainder = 0;\n        break;\n      } else {\n        this.y = nextY;\n        move -= sign;\n        this.yRemainder -= sign;\n        if (onNoCollisions) {\n          onNoCollisions();\n        }\n      }\n    }\n    System.updateEntity(this);\n    if (pushingEntity) {\n      pushingEntity.isCollideable = true;\n    }\n  }\n\n  // Simple bounding box collision check\n  collideAt(\n    x: number,\n    y: number,\n    box: Rectangle,\n    sides?: ('top' | 'right' | 'bottom' | 'left')[],\n  ): Collision[] | false {\n    const nextPosition = new Rectangle(box.x + x, box.y + y, box.width, box.height);\n    const collisions = [];\n    // Iterate through all solids in the level to check for collisions\n    for (const entity of this.collideables) {\n      if (!entity.isCollideable || this.passThroughTypes.includes(entity.type)) {\n        continue;\n      }\n\n      const solidBounds = entity.getBoundingBox();\n      let collisionResult = checkCollision(nextPosition, solidBounds, this, entity);\n      if (sides?.length && collisionResult) {\n        // check to be sure collision includes all sides\n        const collisionSides = sides.filter((side) => (collisionResult as Collision)[side]);\n        if (!collisionSides.length) {\n          collisionResult = false;\n        }\n      }\n      if (collisionResult) {\n        System.collide(collisionResult);\n        // if the collision resolver returns true,\n        // we should stop and return this collision\n        // this will stop actor movement if returned\n        if (System.resolveCollision(collisionResult)) {\n          collisions.push(collisionResult);\n        }\n      }\n    }\n    return collisions.length ? collisions : false;\n  }\n\n  isRiding(solid: Entity): boolean {\n    const thisBounds = this.getBoundingBox();\n    const solidBounds = solid.getBoundingBox();\n    const withinTolerance = Math.abs(thisBounds.bottom - solidBounds.top) <= 1;\n    return withinTolerance && thisBounds.left < solidBounds.right && thisBounds.right > solidBounds.left;\n  }\n\n  setPassingThrough(entity: Entity) {\n    this.passingThrough.add(entity);\n  }\n\n  removePassingThrough(entity: Entity) {\n    this.passingThrough.delete(entity);\n  }\n\n  isPassingThrough(entity: Entity) {\n    return this.passingThrough.has(entity);\n  }\n\n  private clearAllRiding() {\n    this.mostRiding = null;\n    this.riding.clear();\n  }\n\n  private setAllRiding() {\n    this.clearAllRiding();\n    this.collideables.forEach((entity) => {\n      if (this.isRiding(entity)) {\n        this.riding.add(entity);\n      }\n    });\n    let mostAmount = 0;\n    for (const entity of this.riding) {\n      // Check how much the actor is riding the entity\n      if (this.right > entity.left && this.left < entity.right) {\n        this.mostRiding = entity;\n        break;\n      }\n      let amount = 0;\n      if (this.right > entity.left && this.left < entity.left) {\n        // left edge\n        amount = this.right - entity.left;\n        if (amount > mostAmount) {\n          mostAmount = amount;\n          this.mostRiding = entity;\n        }\n      } else if (this.left < entity.right && this.right > entity.right) {\n        // right edge\n        amount = entity.right - this.left;\n        if (amount > mostAmount) {\n          mostAmount = amount;\n          this.mostRiding = entity;\n        }\n      }\n    }\n  }\n}\n","import { Application, Logger } from 'dill-pixel';\nimport { Actor } from './Actor';\nimport { Entity } from './Entity';\nimport { System } from './System';\nimport { checkCollision } from './utils';\nimport { Collision, EntityType } from './types';\n\nexport class Sensor<T = any, A extends Application = Application> extends Actor<T, A> {\n  type = 'Sensor';\n  isSensor = true;\n  isColliding = false;\n  /**\n   * Types of entities that can pass through this sensor without triggering a collision\n   * All actors by default, so sensors can still be pushed by and ride on solids,\n   * but we don't check collisions with other actors in the moveX and moveY methods\n   * You can call \"resolveAllCollisions\" to still resolve collisions for actors,\n   * but not have this sensor be \"pushed\" by them\n   */\n  passThroughTypes: EntityType[] = ['Actor', 'Player'];\n\n  get collideables(): Entity[] {\n    return System.actors;\n  }\n\n  added() {\n    System.addSensor(this);\n  }\n\n  removed() {\n    System.removeSensor(this);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  update(_deltaTime?: number) {\n    this.activeCollisions = this.resolveAllCollisions() || [];\n    this.isColliding = this.activeCollisions ? this.activeCollisions.length > 0 : false;\n  }\n\n  /**\n   * Resolve all collisions for this sensor\n   * ignores passThroughTypes\n   */\n  resolveAllCollisions(): null | Collision[] {\n    const collisions = [];\n    // Iterate through all solids in the level to check for collisions\n    for (const entity of this.collideables) {\n      if (!entity.isCollideable) {\n        continue;\n      }\n      const collisionResult = checkCollision(this.getBoundingBox(), entity.getBoundingBox(), this, entity);\n      if (collisionResult) {\n        collisions.push(collisionResult);\n      }\n      if (collisionResult) {\n        System.collide(collisionResult);\n        // if the collision resolver returns true,\n        // we should stop and return this collision\n        // this will stop actor movement if returned\n        if (System.resolveCollision(collisionResult)) {\n          collisions.push(collisionResult);\n        }\n      }\n    }\n    return collisions.length ? collisions : null;\n  }\n\n  getOuterCollisions(collideables = this.collideables) {\n    const outerBoundingBox = this.getOuterBoundingBox();\n    if (!outerBoundingBox) {\n      Logger.error(this.type, 'has no outer bounding box. Returning empty array.');\n      return [];\n    }\n    const collisions: Collision[] = [];\n    for (const entity of collideables) {\n      if (!entity.isCollideable) {\n        continue;\n      }\n      const collisionResult = checkCollision(outerBoundingBox, entity.getBoundingBox(), this, entity);\n      if (collisionResult) {\n        collisions.push(collisionResult);\n      }\n    }\n    return collisions;\n  }\n}\n"],"names":["SpatialHashGrid","cellSize","insertEntities","System","entity","size","bounds","startX","startY","endX","endY","x","y","key","_a","entities","range","filter","foundEntities","cellEntities","gfx","rect","rects","_cell","Rectangle","cellX","cellY","Entity","Container","config","value","deltaTime","pos","Sprite","Bounds","dx","dy","Solid","moveX","moveY","ridingActors","actor","deltaX","deltaY","overlapX","overlapY","_isColliding","defaults","Wall","SnapSolid","Texture","checkPointIntersection","point","collider","getIntersectionArea","rectA","rectB","xOverlap","yOverlap","checkCollision","entity1","entity2","overlap","_System","Ticker","collisionResolverMethod","collision","index","type","acc","t","solid","sensor","e","bounds1","bounds2","intersection","ticker","Logger","hook","width","height","padding","sides","wall","Point","container","_b","Graphics","outerBounds","opts","Signal","defaultOptions","SnapPhysicsPlugin","Plugin","app","options","Actor","_collision","_pushingEntity","_direction","amount","onCollide","onNoCollisions","pushingEntity","move","sign","nextX","collisions","nextY","box","nextPosition","solidBounds","collisionResult","side","thisBounds","mostAmount","Sensor","_deltaTime","collideables","outerBoundingBox"],"mappings":"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"}