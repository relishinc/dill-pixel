{"version":3,"file":"SceneManagerPlugin-CEnQA3aU.mjs","sources":["../src/plugins/SceneManagerPlugin.ts"],"sourcesContent":["import { Container } from 'pixi.js';\nimport { Application, IApplication } from '../core/Application';\nimport { IScene, Scene } from '../display/Scene';\nimport { Signal } from '../signals';\nimport { Logger } from '../utils/console/Logger';\nimport { isDev } from '../utils/env';\nimport { getDynamicModuleFromImportListItem } from '../utils/framework';\nimport { bindAllMethods } from '../utils/methodBinding';\nimport { createQueue, Queue } from '../utils/promise/Queue';\nimport { Constructor, ImportList, SceneImportList } from '../utils/types';\nimport type { IPlugin } from './Plugin';\nimport { Plugin } from './Plugin';\n\nexport interface ISceneManagerPlugin extends IPlugin {\n  isFirstScene: boolean;\n  onSceneChangeStart: Signal<(detail: { exiting: string | null; entering: string }) => void>;\n  onSceneChangeComplete: Signal<(detail: { current: string }) => void>;\n  loadScreen?: Scene;\n  view: Container;\n  scenes: ImportList<IScene>;\n\n  setDefaultLoadMethod(method: LoadSceneMethod): void;\n\n  loadDefaultScene(): Promise<void>;\n\n  loadScene(sceneIdOrLoadSceneConfig: LoadSceneConfig | string): Promise<void>;\n}\n\nexport type LoadSceneMethod =\n  | 'immediate'\n  | 'exitEnter'\n  | 'enterExit'\n  | 'enterBehind'\n  | 'interStitialExitEnter'\n  | 'exitInterstitialEnter';\n\nexport type LoadSceneConfig = {\n  id: string;\n  method?: LoadSceneMethod;\n};\n\nexport class SceneManagerPlugin extends Plugin implements ISceneManagerPlugin {\n  public readonly id: string = 'scenes';\n  public onSceneChangeStart: Signal<(detail: { exiting: string | null; entering: string }) => void> = new Signal<\n    (detail: { exiting: string | null; entering: string }) => void\n  >();\n  public onSceneChangeComplete: Signal<(detail: { current: string }) => void> = new Signal<\n    (detail: { current: string }) => void\n  >();\n  // TODO: loadScreen is a special scene that can be used right after the application starts\n  public loadScreen?: Scene;\n  // view container - gets added to the stage\n  public view: Container = new Container();\n  // maybe the user wants the enter animation to be different for the first scene\n  public isFirstScene: boolean = true;\n\n  // scene management\n  public scenes: SceneImportList<IScene> = [];\n  public currentScene: IScene;\n  public defaultScene: string;\n  private _sceneModules: Map<string, Constructor<IScene>> = new Map();\n  //\n  private _lastScene: IScene | null = null;\n  private _queue: Queue<any> | null;\n  private _defaultLoadMethod: LoadSceneMethod = 'immediate';\n  private _currentSceneId: string;\n  // debug\n  private _debugVisible: boolean = false;\n  private _debugMenu: HTMLDivElement;\n\n  // debug\n  private _sceneSelect: HTMLSelectElement;\n\n  constructor() {\n    super();\n    bindAllMethods(this);\n  }\n\n  public setDefaultLoadMethod(method: LoadSceneMethod) {\n    this._defaultLoadMethod = method;\n  }\n\n  public destroy(): void {}\n\n  public initialize(app: IApplication): Promise<void> {\n    this._debugVisible =\n      this.app.config?.showSceneDebugMenu === true || (isDev && this.app.config?.showSceneDebugMenu !== false);\n    this.view.sortableChildren = true;\n    this.scenes = app.config?.scenes || [];\n    if (this._debugVisible) {\n      this.defaultScene = this._getSceneFromHash() || '';\n    }\n    this.defaultScene = this.defaultScene || app.config?.defaultScene || this.scenes?.[0]?.id;\n    this._defaultLoadMethod = app.config.defaultSceneLoadMethod || 'immediate';\n    Logger.log('SceneManager initialize::', this.scenes);\n\n    if (this._debugVisible) {\n      this._createDebugMenu();\n    }\n    return Promise.resolve(undefined);\n  }\n\n  public async loadDefaultScene(): Promise<void> {\n    return this.loadScene(this.defaultScene);\n  }\n\n  public async loadScene(sceneIdOrLoadSceneConfig: string): Promise<void>;\n\n  public async loadScene(sceneIdOrLoadSceneConfig: LoadSceneConfig | string): Promise<void> {\n    if (this._queue) {\n      // TODO: maybe allow halting the queue and starting a fresh scene load\n      // for now, just ignore the request until the queue finishes\n      return;\n    }\n\n    this._lastScene = null;\n    const newSceneId =\n      typeof sceneIdOrLoadSceneConfig === 'string' ? sceneIdOrLoadSceneConfig : sceneIdOrLoadSceneConfig.id;\n\n    const method =\n      typeof sceneIdOrLoadSceneConfig === 'string'\n        ? this._defaultLoadMethod\n        : sceneIdOrLoadSceneConfig?.method || this._defaultLoadMethod;\n\n    if (this.currentScene) {\n      this._lastScene = this.currentScene;\n    }\n\n    // check if the scene item exists\n    const sceneItem = this.scenes.find((scene) => scene.id === newSceneId);\n    if (!sceneItem) {\n      throw new Error(`Scene item not found  for id ${newSceneId}`);\n    }\n\n    if (sceneItem?.plugins?.length) {\n      for (const plugin of sceneItem.plugins) {\n        const pluginListItem = this.app.getUnloadedPlugin(plugin);\n        if (pluginListItem) {\n          await this.app.loadPlugin(pluginListItem);\n        }\n      }\n    }\n\n    this._currentSceneId = newSceneId;\n\n    // found a scene item\n    this._queue = createQueue(this._createCurrentScene);\n\n    // TODO: finish adding scene changing behaviours\n    // TODO: add loading assets into this queue\n    // TODO: add progress updates\n    switch (method) {\n      case 'exitEnter':\n        this._queue.add(\n          this._exitLastScene,\n          this._destroyLastScene,\n          this._initializeCurrentScene,\n          this._addCurrentScene,\n          this._enterCurrentScene,\n          this._startCurrentScene,\n        );\n        break;\n      case 'enterExit':\n        this._queue.add(\n          this._initializeCurrentScene,\n          this._addCurrentScene,\n          this._enterCurrentScene,\n          this._startCurrentScene,\n          this._destroyLastScene,\n        );\n        break;\n      case 'enterBehind':\n        this._queue.add(\n          this._initializeCurrentScene,\n          this._addCurrentSceneBehind,\n          this._enterCurrentScene,\n          this._exitLastScene,\n          this._destroyLastScene,\n          this._startCurrentScene,\n        );\n        break;\n      default:\n        this._queue.add(\n          this._destroyLastScene,\n          this._initializeCurrentScene,\n          this._addCurrentScene,\n          this._enterCurrentScene,\n          this._startCurrentScene,\n        );\n        break;\n    }\n\n    this._queue.add(this._queueComplete);\n    this._queue.start();\n  }\n\n  protected getCoreSignals(): string[] {\n    return ['onSceneChangeStart', 'onSceneChangeComplete'];\n  }\n\n  protected getCoreFunctions(): string[] {\n    return ['loadScene'];\n  }\n\n  private async _createCurrentScene() {\n    const sceneItem = this.scenes.find((scene) => scene.id === this._currentSceneId)!;\n    let SceneClass: Constructor<IScene> | undefined = undefined;\n\n    if (this._sceneModules.has(this._currentSceneId)) {\n      SceneClass = this._sceneModules.get(this._currentSceneId);\n    } else {\n      const module = await getDynamicModuleFromImportListItem(sceneItem);\n      if (!module) {\n        throw new Error(`Couldn't load ${this._currentSceneId}\"`);\n      }\n\n      if ((module as any)[this._currentSceneId]) {\n        SceneClass = (module as any)[this._currentSceneId];\n      } else {\n        SceneClass = module;\n      }\n\n      if (SceneClass) {\n        this._sceneModules.set(this._currentSceneId, SceneClass);\n      }\n    }\n\n    if (!SceneClass) {\n      throw new Error(`Couldn't load ${this._currentSceneId}\"`);\n    }\n\n    this.currentScene = new SceneClass();\n    this.currentScene.id = this._currentSceneId;\n    this.onSceneChangeStart.emit({ exiting: this._lastScene?.id || null, entering: this.currentScene.id });\n  }\n\n  private _queueComplete() {\n    this.isFirstScene = false;\n    this._lastScene = null;\n    this.onSceneChangeComplete.emit({ current: this.currentScene.id });\n    this._queue = null;\n    return Promise.resolve();\n  }\n\n  private async _destroyLastScene(): Promise<void> {\n    if (!this._lastScene) {\n      return Promise.resolve();\n    }\n    this.view.removeChild(this._lastScene as any);\n    this._lastScene.destroy();\n    return Promise.resolve();\n  }\n\n  private async _exitLastScene(): Promise<void> {\n    if (!this._lastScene) {\n      return Promise.resolve();\n    }\n    await this._lastScene.exit();\n    return Promise.resolve();\n  }\n\n  private async _initializeCurrentScene(): Promise<void> {\n    await this.currentScene.initialize();\n\n    // wait one tick so everything in the scene has had a chance to render before triggering the resize\n    this.app.ticker.addOnce(() => {\n      this.currentScene.resize(this.app.size);\n    });\n\n    return Promise.resolve();\n  }\n\n  private _addCurrentScene(): Promise<void> {\n    this.view.addChild(this.currentScene as any);\n    return Promise.resolve();\n  }\n\n  private _addCurrentSceneBehind(): Promise<void> {\n    this.view.addChildAt(this.currentScene as any, 0);\n    return Promise.resolve();\n  }\n\n  private async _enterCurrentScene(): Promise<void> {\n    await this.currentScene.enter();\n    return Promise.resolve();\n  }\n\n  private async _startCurrentScene(): Promise<void> {\n    void this.currentScene.start();\n    return Promise.resolve();\n  }\n\n  private _createDebugMenu() {\n    this._debugMenu = document.createElement('div');\n    this._debugMenu.style.cssText =\n      'position: absolute; bottom: 0; left:0; width:48px; height:48px; z-index: 1000; background-color:rgba(0,0,0,0.8); color:white; border-top-right-radius:8px;';\n    const icon = document.createElement('i');\n    icon.style.cssText =\n      'cursor:pointer; position:absolute;width:100%; font-style:normal; font-size:20px; top:50%; left:50%; transform:translate(-50%, -50%); text-align:center; pointer-events:none';\n    icon.innerHTML = 'ðŸŽ¬';\n    this._debugMenu.appendChild(icon);\n\n    (Application.containerElement || document.body).appendChild(this._debugMenu);\n\n    this._sceneSelect = document.createElement('select');\n    this._sceneSelect.style.cssText =\n      'padding:0; border-radius:5px; opacity:0; width:48px; height:48px; cursor:pointer';\n    this._sceneSelect.value = this.defaultScene || '';\n\n    const defaultOption = document.createElement('option');\n    defaultOption.value = '';\n    defaultOption.innerHTML = 'Select a scene';\n\n    this._sceneSelect.appendChild(defaultOption);\n\n    this.scenes.forEach((value) => {\n      const option = document.createElement('option');\n      option.value = value.id;\n      option.innerHTML = value?.debugLabel || value.id;\n      if (value.id === this.defaultScene) {\n        option.selected = true;\n      }\n      this._sceneSelect.appendChild(option);\n    });\n\n    this._debugMenu.appendChild(this._sceneSelect);\n\n    this._debugMenu.addEventListener('change', (e: Event) => {\n      if (this._queue) {\n        e.preventDefault();\n        return;\n      }\n      const target = e.target as HTMLSelectElement;\n      const sceneId = target.value;\n      if (sceneId) {\n        window.location.hash = sceneId.toLowerCase();\n      }\n    });\n\n    window.addEventListener('hashchange', () => {\n      const sceneId = this._getSceneFromHash();\n      if (sceneId) {\n        this.loadScene(sceneId);\n      }\n    });\n\n    this.onSceneChangeStart.connect(this._disableDebugMenu);\n    this.onSceneChangeComplete.connect(this._enableDebugMenu);\n  }\n\n  private _enableDebugMenu() {\n    this._debugMenu?.querySelector('select')?.removeAttribute('disabled');\n  }\n\n  private _disableDebugMenu() {\n    this._debugMenu?.querySelector('select')?.setAttribute('disabled', 'disabled');\n  }\n\n  private _getSceneFromHash(): string | null {\n    let hash = window?.location?.hash;\n    if (hash) {\n      hash = hash.replace('#', '');\n      if (hash.length > 0) {\n        for (let i = 0; i < this.scenes.length; i++) {\n          if (this.scenes[i]?.id?.toLowerCase() === hash.toLowerCase()) {\n            return this.scenes[i].id;\n          }\n        }\n      }\n    }\n    return null;\n  }\n}\n"],"names":["SceneManagerPlugin","Plugin","Signal","Container","bindAllMethods","method","app","_a","isDev","_b","_c","_d","_f","_e","Logger","sceneIdOrLoadSceneConfig","newSceneId","sceneItem","scene","plugin","pluginListItem","createQueue","SceneClass","module","getDynamicModuleFromImportListItem","icon","Application","defaultOption","value","option","e","sceneId","hash","i"],"mappings":"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"}